
I01_SD_Card.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002cec  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00002cec  00002cec  00012cec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  00002cf4  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000006b0  2000043c  00003130  0002043c  2**2
                  ALLOC
  4 .stack        00002004  20000aec  000037e0  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  7 .debug_info   00011566  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000012a0  00000000  00000000  00031a23  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005c2b  00000000  00000000  00032cc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000368  00000000  00000000  000388ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000360  00000000  00000000  00038c56  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013984  00000000  00000000  00038fb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00004c05  00000000  00000000  0004c93a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000749ff  00000000  00000000  0005153f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000ba8  00000000  00000000  000c5f40  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	f0 2a 00 20 f5 03 00 00 f1 03 00 00 f1 03 00 00     .*. ............
	...
      2c:	f1 03 00 00 00 00 00 00 00 00 00 00 f1 03 00 00     ................
      3c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      4c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      5c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      6c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      7c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      8c:	f1 03 00 00 f1 03 00 00 00 00 00 00 00 00 00 00     ................
      9c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      ac:	f1 03 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002cf4 	.word	0x00002cf4

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002cf4 	.word	0x00002cf4
     10c:	00002cf4 	.word	0x00002cf4
     110:	00000000 	.word	0x00000000

00000114 <AppInit>:
 * Note:            This was taken from the _00_LED_ON provided by
 *                  Microchip Technology Inc. 
 *
 ******************************************************************************/
void AppInit(void)
{
     114:	b510      	push	{r4, lr}
	/*	Clock initialization (CPU, AHB, APBx, Asynchronous Peripheral Clocks)
		The System RC Oscillator (RCSYS) provides the source for the main clock
		at chip startup. It is set to 1MHz.
	*/
	ClocksInit();
     116:	4b04      	ldr	r3, [pc, #16]	; (128 <AppInit+0x14>)
     118:	4798      	blx	r3
	
	// Assign SS as OUTPUT
	REG_PORT_DIR0 = PORT_PA08;
     11a:	2380      	movs	r3, #128	; 0x80
     11c:	005b      	lsls	r3, r3, #1
     11e:	4a03      	ldr	r2, [pc, #12]	; (12c <AppInit+0x18>)
     120:	6013      	str	r3, [r2, #0]
	
	// Set SS OFF
	REG_PORT_OUTCLR0 = PORT_PA08;
     122:	4a03      	ldr	r2, [pc, #12]	; (130 <AppInit+0x1c>)
     124:	6013      	str	r3, [r2, #0]
} // AppInit()
     126:	bd10      	pop	{r4, pc}
     128:	000002d9 	.word	0x000002d9
     12c:	41004400 	.word	0x41004400
     130:	41004414 	.word	0x41004414

00000134 <AppRun>:
 *
 * Note:
 *
 ******************************************************************************/
void AppRun(void)
{
     134:	b530      	push	{r4, r5, lr}
     136:	b09b      	sub	sp, #108	; 0x6c
	// Initialize the UART at 9600 baud
	UART3_Init(9600);
     138:	2096      	movs	r0, #150	; 0x96
     13a:	0180      	lsls	r0, r0, #6
     13c:	4b42      	ldr	r3, [pc, #264]	; (248 <AppRun+0x114>)
     13e:	4798      	blx	r3
	delay_ms(500);
     140:	4d42      	ldr	r5, [pc, #264]	; (24c <AppRun+0x118>)
     142:	0028      	movs	r0, r5
     144:	4c42      	ldr	r4, [pc, #264]	; (250 <AppRun+0x11c>)
     146:	47a0      	blx	r4
	
	// Initialize SPI
	SPI_Initialize_Slow();
     148:	4b42      	ldr	r3, [pc, #264]	; (254 <AppRun+0x120>)
     14a:	4798      	blx	r3
	delay_ms(500);
     14c:	0028      	movs	r0, r5
     14e:	47a0      	blx	r4
	//////////////////////////////////////////////////////////////////////////
	// Writing to File
	//////////////////////////////////////////////////////////////////////////
	
	// Start to Init the SD Card
	UART3_Write_Text("start init\n");
     150:	4841      	ldr	r0, [pc, #260]	; (258 <AppRun+0x124>)
     152:	4c42      	ldr	r4, [pc, #264]	; (25c <AppRun+0x128>)
     154:	47a0      	blx	r4
	
	// Initialize the SD Card
    SDCard_Init();
     156:	4b42      	ldr	r3, [pc, #264]	; (260 <AppRun+0x12c>)
     158:	4798      	blx	r3
	 
	// Initialize Done
	UART3_Write_Text("init done\n");
     15a:	4842      	ldr	r0, [pc, #264]	; (264 <AppRun+0x130>)
     15c:	47a0      	blx	r4
	
	// Start to mount the SD card
	UART3_Write_Text("start mount\n");
     15e:	4842      	ldr	r0, [pc, #264]	; (268 <AppRun+0x134>)
     160:	47a0      	blx	r4
	
	// Mount the file
	FR= f_mount(&fs,data_file,0);
     162:	2200      	movs	r2, #0
     164:	4941      	ldr	r1, [pc, #260]	; (26c <AppRun+0x138>)
     166:	4842      	ldr	r0, [pc, #264]	; (270 <AppRun+0x13c>)
     168:	4b42      	ldr	r3, [pc, #264]	; (274 <AppRun+0x140>)
     16a:	4798      	blx	r3
     16c:	4d42      	ldr	r5, [pc, #264]	; (278 <AppRun+0x144>)
     16e:	7028      	strb	r0, [r5, #0]
	
	// Finish Mounting
	UART3_Write_Text("end mount\n");
     170:	4842      	ldr	r0, [pc, #264]	; (27c <AppRun+0x148>)
     172:	47a0      	blx	r4
	
	// Error with mount
	if(FR)
     174:	782b      	ldrb	r3, [r5, #0]
     176:	2b00      	cmp	r3, #0
     178:	d003      	beq.n	182 <AppRun+0x4e>
	{
		UART3_Write_Text("\nError mounting file system\r\n");
     17a:	4841      	ldr	r0, [pc, #260]	; (280 <AppRun+0x14c>)
     17c:	4b37      	ldr	r3, [pc, #220]	; (25c <AppRun+0x128>)
     17e:	4798      	blx	r3
     180:	e7fe      	b.n	180 <AppRun+0x4c>
		while(1);
	}
	
	// Start Open
	UART3_Write_Text("start open\n");
     182:	4840      	ldr	r0, [pc, #256]	; (284 <AppRun+0x150>)
     184:	4d35      	ldr	r5, [pc, #212]	; (25c <AppRun+0x128>)
     186:	47a8      	blx	r5
	
	// Open the SD Card for Writing
	FR = f_open(&fil, data_file, FA_WRITE | FA_OPEN_ALWAYS);
     188:	2212      	movs	r2, #18
     18a:	4938      	ldr	r1, [pc, #224]	; (26c <AppRun+0x138>)
     18c:	483e      	ldr	r0, [pc, #248]	; (288 <AppRun+0x154>)
     18e:	4b3f      	ldr	r3, [pc, #252]	; (28c <AppRun+0x158>)
     190:	4798      	blx	r3
     192:	4c39      	ldr	r4, [pc, #228]	; (278 <AppRun+0x144>)
     194:	7020      	strb	r0, [r4, #0]
	
	// Open Successful
	UART3_Write_Text("end open\n");
     196:	483e      	ldr	r0, [pc, #248]	; (290 <AppRun+0x15c>)
     198:	47a8      	blx	r5
	
	
	// Error Opening File
	if(FR)
     19a:	7823      	ldrb	r3, [r4, #0]
     19c:	2b00      	cmp	r3, #0
     19e:	d003      	beq.n	1a8 <AppRun+0x74>
	{
		UART3_Write_Text("Error opening file\r\n");
     1a0:	483c      	ldr	r0, [pc, #240]	; (294 <AppRun+0x160>)
     1a2:	4b2e      	ldr	r3, [pc, #184]	; (25c <AppRun+0x128>)
     1a4:	4798      	blx	r3
     1a6:	e7fe      	b.n	1a6 <AppRun+0x72>
		while(1);
	}
	
	// Open File to write some CSV Data
	FR = f_write(&fil, "Data1 ,Data2 ,Data3 ,Data4 \r\n", 29, &bw); 
     1a8:	4b3b      	ldr	r3, [pc, #236]	; (298 <AppRun+0x164>)
     1aa:	221d      	movs	r2, #29
     1ac:	493b      	ldr	r1, [pc, #236]	; (29c <AppRun+0x168>)
     1ae:	4836      	ldr	r0, [pc, #216]	; (288 <AppRun+0x154>)
     1b0:	4c3b      	ldr	r4, [pc, #236]	; (2a0 <AppRun+0x16c>)
     1b2:	47a0      	blx	r4
     1b4:	4b30      	ldr	r3, [pc, #192]	; (278 <AppRun+0x144>)
     1b6:	7018      	strb	r0, [r3, #0]
	
	
	// There is an Error
	if(FR)
     1b8:	2800      	cmp	r0, #0
     1ba:	d003      	beq.n	1c4 <AppRun+0x90>
	{
		UART3_Write_Text("\nError writing to file\r\n");
     1bc:	4839      	ldr	r0, [pc, #228]	; (2a4 <AppRun+0x170>)
     1be:	4b27      	ldr	r3, [pc, #156]	; (25c <AppRun+0x128>)
     1c0:	4798      	blx	r3
     1c2:	e7fe      	b.n	1c2 <AppRun+0x8e>
		while(1);
	}
	
	// Close the file
	FR = f_close(&fil);
     1c4:	4830      	ldr	r0, [pc, #192]	; (288 <AppRun+0x154>)
     1c6:	4b38      	ldr	r3, [pc, #224]	; (2a8 <AppRun+0x174>)
     1c8:	4798      	blx	r3
     1ca:	4b2b      	ldr	r3, [pc, #172]	; (278 <AppRun+0x144>)
     1cc:	7018      	strb	r0, [r3, #0]
	
	// There is an error
	if(FR)
     1ce:	2800      	cmp	r0, #0
     1d0:	d003      	beq.n	1da <AppRun+0xa6>
	{
		UART3_Write_Text("\nError closing file\r\n");
     1d2:	4836      	ldr	r0, [pc, #216]	; (2ac <AppRun+0x178>)
     1d4:	4b21      	ldr	r3, [pc, #132]	; (25c <AppRun+0x128>)
     1d6:	4798      	blx	r3
     1d8:	e7fe      	b.n	1d8 <AppRun+0xa4>
		while(1);
	}
		
    UART3_Write_Text("Successful Write File Done!\n");
     1da:	4835      	ldr	r0, [pc, #212]	; (2b0 <AppRun+0x17c>)
     1dc:	4c1f      	ldr	r4, [pc, #124]	; (25c <AppRun+0x128>)
     1de:	47a0      	blx	r4

    //////////////////////////////////////////////////////////////////////////
	// Reading Files
	//////////////////////////////////////////////////////////////////////////
	
     UART3_Write_Text("Start Read\n");
     1e0:	4834      	ldr	r0, [pc, #208]	; (2b4 <AppRun+0x180>)
     1e2:	47a0      	blx	r4
   
     // Open the SD Card for Writing
     FR = f_open(&fil, data_file, FA_READ );
     1e4:	2201      	movs	r2, #1
     1e6:	4921      	ldr	r1, [pc, #132]	; (26c <AppRun+0x138>)
     1e8:	4827      	ldr	r0, [pc, #156]	; (288 <AppRun+0x154>)
     1ea:	4b28      	ldr	r3, [pc, #160]	; (28c <AppRun+0x158>)
     1ec:	4798      	blx	r3
     1ee:	4d22      	ldr	r5, [pc, #136]	; (278 <AppRun+0x144>)
     1f0:	7028      	strb	r0, [r5, #0]
   
     UART3_Write_Text("Reading Good\n");
     1f2:	4831      	ldr	r0, [pc, #196]	; (2b8 <AppRun+0x184>)
     1f4:	47a0      	blx	r4
	 
	 // Reading Error
	 if (FR)
     1f6:	782b      	ldrb	r3, [r5, #0]
     1f8:	2b00      	cmp	r3, #0
     1fa:	d002      	beq.n	202 <AppRun+0xce>
	 {
		 UART3_Write_Text("Read Error\n");
     1fc:	482f      	ldr	r0, [pc, #188]	; (2bc <AppRun+0x188>)
     1fe:	4b17      	ldr	r3, [pc, #92]	; (25c <AppRun+0x128>)
     200:	4798      	blx	r3
	 }
	 
	 
	 // Print Read Contents
	 UART3_Write_Text("The file contains: \n");
     202:	482f      	ldr	r0, [pc, #188]	; (2c0 <AppRun+0x18c>)
     204:	4b15      	ldr	r3, [pc, #84]	; (25c <AppRun+0x128>)
     206:	4798      	blx	r3
	  
	 char line[100]; /* Line buffer */
	 
	 /* Read every line and display it */
	 while (f_gets(line, sizeof line, &fil)) {
     208:	4d1f      	ldr	r5, [pc, #124]	; (288 <AppRun+0x154>)
     20a:	4c2e      	ldr	r4, [pc, #184]	; (2c4 <AppRun+0x190>)
     20c:	e002      	b.n	214 <AppRun+0xe0>
		 UART3_Write_Text(line);
     20e:	a801      	add	r0, sp, #4
     210:	4b12      	ldr	r3, [pc, #72]	; (25c <AppRun+0x128>)
     212:	4798      	blx	r3
	 while (f_gets(line, sizeof line, &fil)) {
     214:	002a      	movs	r2, r5
     216:	2164      	movs	r1, #100	; 0x64
     218:	a801      	add	r0, sp, #4
     21a:	47a0      	blx	r4
     21c:	2800      	cmp	r0, #0
     21e:	d1f6      	bne.n	20e <AppRun+0xda>
	 }
	 
	 
	 // Reading Good
	 UART3_Write_Text("Reading Done\n");
     220:	4829      	ldr	r0, [pc, #164]	; (2c8 <AppRun+0x194>)
     222:	4c0e      	ldr	r4, [pc, #56]	; (25c <AppRun+0x128>)
     224:	47a0      	blx	r4
	 
	 // Close the file
	 UART3_Write_Text("Closing File\n");
     226:	4829      	ldr	r0, [pc, #164]	; (2cc <AppRun+0x198>)
     228:	47a0      	blx	r4
	 
	 // Close the file
	 FR = f_close(&fil);
     22a:	4817      	ldr	r0, [pc, #92]	; (288 <AppRun+0x154>)
     22c:	4b1e      	ldr	r3, [pc, #120]	; (2a8 <AppRun+0x174>)
     22e:	4798      	blx	r3
     230:	4b11      	ldr	r3, [pc, #68]	; (278 <AppRun+0x144>)
     232:	7018      	strb	r0, [r3, #0]
	 
	 // Close read Error
	 if(FR)
     234:	2800      	cmp	r0, #0
     236:	d002      	beq.n	23e <AppRun+0x10a>
	 {
		 UART3_Write_Text("Close Read Error\n");
     238:	4825      	ldr	r0, [pc, #148]	; (2d0 <AppRun+0x19c>)
     23a:	4b08      	ldr	r3, [pc, #32]	; (25c <AppRun+0x128>)
     23c:	4798      	blx	r3
	 }
	 
	 // All good on the close
	 UART3_Write_Text("Closing Success\n");
     23e:	4825      	ldr	r0, [pc, #148]	; (2d4 <AppRun+0x1a0>)
     240:	4b06      	ldr	r3, [pc, #24]	; (25c <AppRun+0x128>)
     242:	4798      	blx	r3
     244:	e7fe      	b.n	244 <AppRun+0x110>
     246:	46c0      	nop			; (mov r8, r8)
     248:	0000242d 	.word	0x0000242d
     24c:	003450dc 	.word	0x003450dc
     250:	000003e5 	.word	0x000003e5
     254:	0000234d 	.word	0x0000234d
     258:	000029d8 	.word	0x000029d8
     25c:	000024ed 	.word	0x000024ed
     260:	00001da9 	.word	0x00001da9
     264:	000029e4 	.word	0x000029e4
     268:	000029f0 	.word	0x000029f0
     26c:	20000000 	.word	0x20000000
     270:	2000046c 	.word	0x2000046c
     274:	00001611 	.word	0x00001611
     278:	2000069c 	.word	0x2000069c
     27c:	00002a00 	.word	0x00002a00
     280:	00002a0c 	.word	0x00002a0c
     284:	00002a2c 	.word	0x00002a2c
     288:	200006a4 	.word	0x200006a4
     28c:	00001681 	.word	0x00001681
     290:	00002a38 	.word	0x00002a38
     294:	00002a44 	.word	0x00002a44
     298:	200006a0 	.word	0x200006a0
     29c:	00002a5c 	.word	0x00002a5c
     2a0:	000019cd 	.word	0x000019cd
     2a4:	00002a7c 	.word	0x00002a7c
     2a8:	00001c75 	.word	0x00001c75
     2ac:	00002a98 	.word	0x00002a98
     2b0:	00002ab0 	.word	0x00002ab0
     2b4:	00002ad0 	.word	0x00002ad0
     2b8:	00002adc 	.word	0x00002adc
     2bc:	00002aec 	.word	0x00002aec
     2c0:	00002af8 	.word	0x00002af8
     2c4:	00001c9d 	.word	0x00001c9d
     2c8:	00002b10 	.word	0x00002b10
     2cc:	00002b20 	.word	0x00002b20
     2d0:	00002b30 	.word	0x00002b30
     2d4:	00002b44 	.word	0x00002b44

000002d8 <ClocksInit>:

	/* ----------------------------------------------------------------------------------------------
	* 1) Set Flash wait states for 48 MHz (per Table 37-40 in data sheet)
	*/
	
	NVMCTRL->CTRLB.bit.RWS = 1;		/* 1 wait state required @ 3.3V & 48MHz */
     2d8:	4a34      	ldr	r2, [pc, #208]	; (3ac <ClocksInit+0xd4>)
     2da:	6853      	ldr	r3, [r2, #4]
     2dc:	211e      	movs	r1, #30
     2de:	438b      	bics	r3, r1
     2e0:	391c      	subs	r1, #28
     2e2:	430b      	orrs	r3, r1
     2e4:	6053      	str	r3, [r2, #4]
		.bit.AAMPEN = 0,		/* Disable automatic amplitude control */
		.bit.EN32K = 1,			/* 32kHz output is disabled */
		.bit.XTALEN = 1			/* Crystal connected to XIN32/XOUT32 */
	};
	// Write these settings
	SYSCTRL->XOSC32K.reg = sysctrl_xosc32k.reg;
     2e6:	4b32      	ldr	r3, [pc, #200]	; (3b0 <ClocksInit+0xd8>)
     2e8:	2283      	movs	r2, #131	; 0x83
     2ea:	0092      	lsls	r2, r2, #2
     2ec:	829a      	strh	r2, [r3, #20]
	// Enable the Oscillator - Separate step per data sheet recommendation (sec 17.6.3)
	SYSCTRL->XOSC32K.bit.ENABLE = 1;
     2ee:	8a9a      	ldrh	r2, [r3, #20]
     2f0:	430a      	orrs	r2, r1
     2f2:	829a      	strh	r2, [r3, #20]
	
	// Wait for XOSC32K to stabilize
	while(!SYSCTRL->PCLKSR.bit.XOSC32KRDY);
     2f4:	001a      	movs	r2, r3
     2f6:	68d3      	ldr	r3, [r2, #12]
     2f8:	079b      	lsls	r3, r3, #30
     2fa:	d5fc      	bpl.n	2f6 <ClocksInit+0x1e>
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K	/* Apply division factor to Generator 1 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk1_gendiv.reg;
     2fc:	4b2d      	ldr	r3, [pc, #180]	; (3b4 <ClocksInit+0xdc>)
     2fe:	2202      	movs	r2, #2
     300:	32ff      	adds	r2, #255	; 0xff
     302:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 1 with XOSC32K as source
	GCLK_GENCTRL_Type gclk1_genctrl = 
     304:	4a2c      	ldr	r2, [pc, #176]	; (3b8 <ClocksInit+0xe0>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x05,		/* Generator source: XOSC32K output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K			/* Generator ID: 1 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk1_genctrl.reg;
     306:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     308:	001a      	movs	r2, r3
     30a:	7853      	ldrb	r3, [r2, #1]
     30c:	09db      	lsrs	r3, r3, #7
     30e:	d1fc      	bne.n	30a <ClocksInit+0x32>
		.bit.CLKEN = 1,			/* Enable the Generic Clock */
		.bit.GEN = GENERIC_CLOCK_GENERATOR_XOSC32K, 	/* Generic Clock Generator 1 is the source */
		.bit.ID = 0x00			/* Generic Clock Multiplexer 0 (DFLL48M Reference) */
	};
	// Write these settings
	GCLK->CLKCTRL.reg = gclk_clkctrl.reg;
     310:	4b28      	ldr	r3, [pc, #160]	; (3b4 <ClocksInit+0xdc>)
     312:	2282      	movs	r2, #130	; 0x82
     314:	01d2      	lsls	r2, r2, #7
     316:	805a      	strh	r2, [r3, #2]
	// Enable the DFLL48M in open loop mode. Without this step, attempts to go into closed loop mode at 48 MHz will
	// result in Processor Reset (you'll be at the in the Reset_Handler in startup_samd21.c).
	// PCLKSR.DFLLRDY must be one before writing to the DFLL Control register
	// Note that the DFLLRDY bit represents status of register synchronization - NOT clock stability
	// (see Data Sheet 17.6.14 Synchronization for detail)
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     318:	4a25      	ldr	r2, [pc, #148]	; (3b0 <ClocksInit+0xd8>)
     31a:	68d3      	ldr	r3, [r2, #12]
     31c:	06db      	lsls	r3, r3, #27
     31e:	d5fc      	bpl.n	31a <ClocksInit+0x42>
	SYSCTRL->DFLLCTRL.reg = (uint16_t)(SYSCTRL_DFLLCTRL_ENABLE);
     320:	2202      	movs	r2, #2
     322:	4b23      	ldr	r3, [pc, #140]	; (3b0 <ClocksInit+0xd8>)
     324:	849a      	strh	r2, [r3, #36]	; 0x24
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     326:	001a      	movs	r2, r3
     328:	68d3      	ldr	r3, [r2, #12]
     32a:	06db      	lsls	r3, r3, #27
     32c:	d5fc      	bpl.n	328 <ClocksInit+0x50>
		.bit.CSTEP = 31,		/* Coarse step - use half of the max value (63) */
		.bit.FSTEP = 511,		/* Fine step - use half of the max value (1023) */
		.bit.MUL = 1465			/* Multiplier = MAIN_CLK_FREQ (48MHz) / EXT_32K_CLK_FREQ (32768 Hz) */
	};
	// Write these settings
	SYSCTRL->DFLLMUL.reg = sysctrl_dfllmul.reg;
     32e:	4b20      	ldr	r3, [pc, #128]	; (3b0 <ClocksInit+0xd8>)
     330:	4a22      	ldr	r2, [pc, #136]	; (3bc <ClocksInit+0xe4>)
     332:	62da      	str	r2, [r3, #44]	; 0x2c
	// Wait for synchronization
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     334:	001a      	movs	r2, r3
     336:	68d3      	ldr	r3, [r2, #12]
     338:	06db      	lsls	r3, r3, #27
     33a:	d5fc      	bpl.n	336 <ClocksInit+0x5e>
	
	// To reduce lock time, load factory calibrated values into DFLLVAL (cf. Data Sheet 17.6.7.1)
	// Location of value is defined in Data Sheet Table 10-5. NVM Software Calibration Area Mapping
	
	// Get factory calibrated value for "DFLL48M COARSE CAL" from NVM Software Calibration Area
	tempDFLL48CalibrationCoarse = *(uint32_t*)FUSES_DFLL48M_COARSE_CAL_ADDR;
     33c:	4b20      	ldr	r3, [pc, #128]	; (3c0 <ClocksInit+0xe8>)
	tempDFLL48CalibrationCoarse &= FUSES_DFLL48M_COARSE_CAL_Msk;
	tempDFLL48CalibrationCoarse = tempDFLL48CalibrationCoarse>>FUSES_DFLL48M_COARSE_CAL_Pos;
	// Write the coarse calibration value
	SYSCTRL->DFLLVAL.bit.COARSE = tempDFLL48CalibrationCoarse;
     33e:	681a      	ldr	r2, [r3, #0]
     340:	491b      	ldr	r1, [pc, #108]	; (3b0 <ClocksInit+0xd8>)
     342:	6a8b      	ldr	r3, [r1, #40]	; 0x28
     344:	0e92      	lsrs	r2, r2, #26
     346:	0292      	lsls	r2, r2, #10
     348:	481e      	ldr	r0, [pc, #120]	; (3c4 <ClocksInit+0xec>)
     34a:	4003      	ands	r3, r0
     34c:	4313      	orrs	r3, r2
     34e:	628b      	str	r3, [r1, #40]	; 0x28
	// Switch DFLL48M to Closed Loop mode and enable WAITLOCK
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     350:	000a      	movs	r2, r1
     352:	68d3      	ldr	r3, [r2, #12]
     354:	06db      	lsls	r3, r3, #27
     356:	d5fc      	bpl.n	352 <ClocksInit+0x7a>
	SYSCTRL->DFLLCTRL.reg |= (uint16_t) (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_WAITLOCK);
     358:	4a15      	ldr	r2, [pc, #84]	; (3b0 <ClocksInit+0xd8>)
     35a:	8c93      	ldrh	r3, [r2, #36]	; 0x24
     35c:	491a      	ldr	r1, [pc, #104]	; (3c8 <ClocksInit+0xf0>)
     35e:	430b      	orrs	r3, r1
     360:	8493      	strh	r3, [r2, #36]	; 0x24
		.bit.IDC = 1,			/* Generator duty cycle is 50/50 */
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x07,		/* Generator source: DFLL48M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_MAIN			/* Generator ID: 0 */
	};
	GCLK->GENCTRL.reg = gclk_genctrl0.reg;
     362:	4b14      	ldr	r3, [pc, #80]	; (3b4 <ClocksInit+0xdc>)
     364:	4a19      	ldr	r2, [pc, #100]	; (3cc <ClocksInit+0xf4>)
     366:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     368:	001a      	movs	r2, r3
     36a:	7853      	ldrb	r3, [r2, #1]
     36c:	09db      	lsrs	r3, r3, #7
     36e:	d1fc      	bne.n	36a <ClocksInit+0x92>
		.bit.PMUX = 7,			/* Peripheral Function H selected (GCLK_IO[0]) */
		.bit.PMUXEN = 1,		/* Enable peripheral Multiplexer */
		.bit.PINMASK = (uint16_t)(1 << (28-16)) /* Select the pin(s) to be configured */
	};
	// Write these settings
	PORT->Group[0].WRCONFIG.reg = port0_wrconfig.reg;
     370:	4b17      	ldr	r3, [pc, #92]	; (3d0 <ClocksInit+0xf8>)
     372:	4a18      	ldr	r2, [pc, #96]	; (3d4 <ClocksInit+0xfc>)
     374:	629a      	str	r2, [r3, #40]	; 0x28
	
	/* ----------------------------------------------------------------------------------------------
	* 7) Modify prescaler value of OSC8M to produce 8MHz output
	*/

	SYSCTRL->OSC8M.bit.PRESC = 0;		/* Prescale by 1 */
     376:	4b0e      	ldr	r3, [pc, #56]	; (3b0 <ClocksInit+0xd8>)
     378:	6a1a      	ldr	r2, [r3, #32]
     37a:	4917      	ldr	r1, [pc, #92]	; (3d8 <ClocksInit+0x100>)
     37c:	400a      	ands	r2, r1
     37e:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;	/* Oscillator is always on if enabled */
     380:	6a1a      	ldr	r2, [r3, #32]
     382:	2180      	movs	r1, #128	; 0x80
     384:	438a      	bics	r2, r1
     386:	621a      	str	r2, [r3, #32]
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M		/* Apply division factor to Generator 3 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk3_gendiv.reg;
     388:	4b0a      	ldr	r3, [pc, #40]	; (3b4 <ClocksInit+0xdc>)
     38a:	2204      	movs	r2, #4
     38c:	32ff      	adds	r2, #255	; 0xff
     38e:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 3 with OSC8M as source
	GCLK_GENCTRL_Type gclk3_genctrl = 
     390:	4a12      	ldr	r2, [pc, #72]	; (3dc <ClocksInit+0x104>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x06,		/* Generator source: OSC8M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M			/* Generator ID: 3 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk3_genctrl.reg;
     392:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     394:	001a      	movs	r2, r3
     396:	7853      	ldrb	r3, [r2, #1]
     398:	09db      	lsrs	r3, r3, #7
     39a:	d1fc      	bne.n	396 <ClocksInit+0xbe>
	
	/* ----------------------------------------------------------------------------------------------
	* 9) Set CPU and APBx BUS Clocks to 48MHz
	*/
	PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
     39c:	4b10      	ldr	r3, [pc, #64]	; (3e0 <ClocksInit+0x108>)
     39e:	2200      	movs	r2, #0
     3a0:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
     3a2:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
     3a4:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
     3a6:	72da      	strb	r2, [r3, #11]
	
     3a8:	4770      	bx	lr
     3aa:	46c0      	nop			; (mov r8, r8)
     3ac:	41004000 	.word	0x41004000
     3b0:	40000800 	.word	0x40000800
     3b4:	40000c00 	.word	0x40000c00
     3b8:	00030501 	.word	0x00030501
     3bc:	7dff05b9 	.word	0x7dff05b9
     3c0:	00806024 	.word	0x00806024
     3c4:	ffff03ff 	.word	0xffff03ff
     3c8:	00000804 	.word	0x00000804
     3cc:	000b0700 	.word	0x000b0700
     3d0:	41004400 	.word	0x41004400
     3d4:	d7011000 	.word	0xd7011000
     3d8:	fffffcff 	.word	0xfffffcff
     3dc:	00030603 	.word	0x00030603
     3e0:	40000400 	.word	0x40000400

000003e4 <delay_n_cycles>:
 *
 ******************************************************************************/

void delay_n_cycles(unsigned long n)
{
	__asm (
     3e4:	f3bf 8f5f 	dmb	sy
     3e8:	3801      	subs	r0, #1
     3ea:	2800      	cmp	r0, #0
     3ec:	d1fa      	bne.n	3e4 <delay_n_cycles>
	"loop: DMB	\n"
	"SUB r0, r0, #1 \n"
	"CMP r0, #0  \n"
	"BNE loop         "
	);
} // delay_n_cycles()
     3ee:	4770      	bx	lr

000003f0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     3f0:	e7fe      	b.n	3f0 <Dummy_Handler>
	...

000003f4 <Reset_Handler>:
{
     3f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     3f6:	4a2a      	ldr	r2, [pc, #168]	; (4a0 <Reset_Handler+0xac>)
     3f8:	4b2a      	ldr	r3, [pc, #168]	; (4a4 <Reset_Handler+0xb0>)
     3fa:	429a      	cmp	r2, r3
     3fc:	d011      	beq.n	422 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     3fe:	001a      	movs	r2, r3
     400:	4b29      	ldr	r3, [pc, #164]	; (4a8 <Reset_Handler+0xb4>)
     402:	429a      	cmp	r2, r3
     404:	d20d      	bcs.n	422 <Reset_Handler+0x2e>
     406:	4a29      	ldr	r2, [pc, #164]	; (4ac <Reset_Handler+0xb8>)
     408:	3303      	adds	r3, #3
     40a:	1a9b      	subs	r3, r3, r2
     40c:	089b      	lsrs	r3, r3, #2
     40e:	3301      	adds	r3, #1
     410:	009b      	lsls	r3, r3, #2
     412:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     414:	4823      	ldr	r0, [pc, #140]	; (4a4 <Reset_Handler+0xb0>)
     416:	4922      	ldr	r1, [pc, #136]	; (4a0 <Reset_Handler+0xac>)
     418:	588c      	ldr	r4, [r1, r2]
     41a:	5084      	str	r4, [r0, r2]
     41c:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     41e:	429a      	cmp	r2, r3
     420:	d1fa      	bne.n	418 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     422:	4a23      	ldr	r2, [pc, #140]	; (4b0 <Reset_Handler+0xbc>)
     424:	4b23      	ldr	r3, [pc, #140]	; (4b4 <Reset_Handler+0xc0>)
     426:	429a      	cmp	r2, r3
     428:	d20a      	bcs.n	440 <Reset_Handler+0x4c>
     42a:	43d3      	mvns	r3, r2
     42c:	4921      	ldr	r1, [pc, #132]	; (4b4 <Reset_Handler+0xc0>)
     42e:	185b      	adds	r3, r3, r1
     430:	2103      	movs	r1, #3
     432:	438b      	bics	r3, r1
     434:	3304      	adds	r3, #4
     436:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     438:	2100      	movs	r1, #0
     43a:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     43c:	4293      	cmp	r3, r2
     43e:	d1fc      	bne.n	43a <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     440:	4a1d      	ldr	r2, [pc, #116]	; (4b8 <Reset_Handler+0xc4>)
     442:	21ff      	movs	r1, #255	; 0xff
     444:	4b1d      	ldr	r3, [pc, #116]	; (4bc <Reset_Handler+0xc8>)
     446:	438b      	bics	r3, r1
     448:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     44a:	39fd      	subs	r1, #253	; 0xfd
     44c:	2390      	movs	r3, #144	; 0x90
     44e:	005b      	lsls	r3, r3, #1
     450:	4a1b      	ldr	r2, [pc, #108]	; (4c0 <Reset_Handler+0xcc>)
     452:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     454:	4a1b      	ldr	r2, [pc, #108]	; (4c4 <Reset_Handler+0xd0>)
     456:	78d3      	ldrb	r3, [r2, #3]
     458:	2503      	movs	r5, #3
     45a:	43ab      	bics	r3, r5
     45c:	2402      	movs	r4, #2
     45e:	4323      	orrs	r3, r4
     460:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     462:	78d3      	ldrb	r3, [r2, #3]
     464:	270c      	movs	r7, #12
     466:	43bb      	bics	r3, r7
     468:	2608      	movs	r6, #8
     46a:	4333      	orrs	r3, r6
     46c:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     46e:	4b16      	ldr	r3, [pc, #88]	; (4c8 <Reset_Handler+0xd4>)
     470:	7b98      	ldrb	r0, [r3, #14]
     472:	2230      	movs	r2, #48	; 0x30
     474:	4390      	bics	r0, r2
     476:	2220      	movs	r2, #32
     478:	4310      	orrs	r0, r2
     47a:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     47c:	7b99      	ldrb	r1, [r3, #14]
     47e:	43b9      	bics	r1, r7
     480:	4331      	orrs	r1, r6
     482:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     484:	7b9a      	ldrb	r2, [r3, #14]
     486:	43aa      	bics	r2, r5
     488:	4322      	orrs	r2, r4
     48a:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     48c:	4a0f      	ldr	r2, [pc, #60]	; (4cc <Reset_Handler+0xd8>)
     48e:	6853      	ldr	r3, [r2, #4]
     490:	2180      	movs	r1, #128	; 0x80
     492:	430b      	orrs	r3, r1
     494:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     496:	4b0e      	ldr	r3, [pc, #56]	; (4d0 <Reset_Handler+0xdc>)
     498:	4798      	blx	r3
        main();
     49a:	4b0e      	ldr	r3, [pc, #56]	; (4d4 <Reset_Handler+0xe0>)
     49c:	4798      	blx	r3
     49e:	e7fe      	b.n	49e <Reset_Handler+0xaa>
     4a0:	00002cf4 	.word	0x00002cf4
     4a4:	20000000 	.word	0x20000000
     4a8:	2000043c 	.word	0x2000043c
     4ac:	20000004 	.word	0x20000004
     4b0:	2000043c 	.word	0x2000043c
     4b4:	20000aec 	.word	0x20000aec
     4b8:	e000ed00 	.word	0xe000ed00
     4bc:	00000000 	.word	0x00000000
     4c0:	41007000 	.word	0x41007000
     4c4:	41005000 	.word	0x41005000
     4c8:	41004800 	.word	0x41004800
     4cc:	41004000 	.word	0x41004000
     4d0:	00002839 	.word	0x00002839
     4d4:	00001cf1 	.word	0x00001cf1

000004d8 <disk_status>:
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status ( BYTE pdrv) /* Physical drive number to identify the drive */
{
     if(pdrv)
     4d8:	1e43      	subs	r3, r0, #1
     4da:	4198      	sbcs	r0, r3
     4dc:	b2c0      	uxtb	r0, r0
    {
        return STA_NOINIT;
    }
    return RES_OK;
}
     4de:	4770      	bx	lr

000004e0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (BYTE pdrv)
{
     4e0:	b510      	push	{r4, lr}
	DSTATUS stat;
	stat=SDCard_Init();  //SD card initialization
     4e2:	4b04      	ldr	r3, [pc, #16]	; (4f4 <disk_initialize+0x14>)
     4e4:	4798      	blx	r3
     4e6:	0003      	movs	r3, r0

	if(stat == STA_NODISK)
     4e8:	2802      	cmp	r0, #2
     4ea:	d002      	beq.n	4f2 <disk_initialize+0x12>
	{
		return STA_NODISK;
	}
	else if(stat != 0)
     4ec:	1e58      	subs	r0, r3, #1
     4ee:	4183      	sbcs	r3, r0
		return STA_NODISK;
     4f0:	b2d8      	uxtb	r0, r3
	}
	  else
	  {
		return 0;
	  }
}
     4f2:	bd10      	pop	{r4, pc}
     4f4:	00001da9 	.word	0x00001da9

000004f8 <disk_read>:
	BYTE pdrv,                                /* Physical drive number to identify the drive */
	BYTE *buff,                               /* Data buffer to store read data */
	DWORD sector,        /* Sector address in LBA */
	UINT count                               /* Number of sectors to read */
)
{
     4f8:	b570      	push	{r4, r5, r6, lr}
     4fa:	000e      	movs	r6, r1
     4fc:	0015      	movs	r5, r2
     4fe:	001c      	movs	r4, r3
    DRESULT res;
    if (pdrv || !count)
    {
        return RES_PARERR;
     500:	2304      	movs	r3, #4
    if (pdrv || !count)
     502:	2800      	cmp	r0, #0
     504:	d001      	beq.n	50a <disk_read+0x12>
    }
    else
    {
        return RES_ERROR;
    }
}
     506:	0018      	movs	r0, r3
     508:	bd70      	pop	{r4, r5, r6, pc}
    if (pdrv || !count)
     50a:	2c00      	cmp	r4, #0
     50c:	d0fb      	beq.n	506 <disk_read+0xe>
		if (count == 1)
     50e:	2c01      	cmp	r4, #1
     510:	d00b      	beq.n	52a <disk_read+0x32>
			UART3_Write_Text("read 2 \n");
     512:	4808      	ldr	r0, [pc, #32]	; (534 <disk_read+0x3c>)
     514:	4b08      	ldr	r3, [pc, #32]	; (538 <disk_read+0x40>)
     516:	4798      	blx	r3
			res = SDCard_ReadMultipleBlock(sector,buff,count);
     518:	b2e2      	uxtb	r2, r4
     51a:	0031      	movs	r1, r6
     51c:	0028      	movs	r0, r5
     51e:	4b07      	ldr	r3, [pc, #28]	; (53c <disk_read+0x44>)
     520:	4798      	blx	r3
    if(res == 0x00)
     522:	1e43      	subs	r3, r0, #1
     524:	4198      	sbcs	r0, r3
        return RES_PARERR;
     526:	b2c3      	uxtb	r3, r0
     528:	e7ed      	b.n	506 <disk_read+0xe>
			res = SDCard_ReadSingleBlock(sector,buff);
     52a:	0010      	movs	r0, r2
     52c:	4b04      	ldr	r3, [pc, #16]	; (540 <disk_read+0x48>)
     52e:	4798      	blx	r3
     530:	e7f7      	b.n	522 <disk_read+0x2a>
     532:	46c0      	nop			; (mov r8, r8)
     534:	00002b58 	.word	0x00002b58
     538:	000024ed 	.word	0x000024ed
     53c:	00002021 	.word	0x00002021
     540:	00001f55 	.word	0x00001f55

00000544 <disk_write>:
	BYTE pdrv,             /* Physical drive number to identify the drive */
	const BYTE *buff,      /* Data to be written */
	DWORD sector,          /* Sector address in LBA */
	UINT count             /* Number of sectors to write */
)
{
     544:	b570      	push	{r4, r5, r6, lr}
     546:	000e      	movs	r6, r1
     548:	0015      	movs	r5, r2
     54a:	001c      	movs	r4, r3
    DRESULT res;
	if (pdrv || !count)
    {
        return RES_PARERR;
     54c:	2304      	movs	r3, #4
	if (pdrv || !count)
     54e:	2800      	cmp	r0, #0
     550:	d001      	beq.n	556 <disk_write+0x12>
    }
    else
    {
        return RES_ERROR;
    }
}
     552:	0018      	movs	r0, r3
     554:	bd70      	pop	{r4, r5, r6, pc}
	if (pdrv || !count)
     556:	2c00      	cmp	r4, #0
     558:	d0fb      	beq.n	552 <disk_write+0xe>
    if(count == 1)
     55a:	2c01      	cmp	r4, #1
     55c:	d00b      	beq.n	576 <disk_write+0x32>
    	UART3_Write_Text("write 2 \n");
     55e:	480a      	ldr	r0, [pc, #40]	; (588 <disk_write+0x44>)
     560:	4b0a      	ldr	r3, [pc, #40]	; (58c <disk_write+0x48>)
     562:	4798      	blx	r3
        res = SDCard_WriteMultipleBlock(sector, buff, count);
     564:	b2e2      	uxtb	r2, r4
     566:	0031      	movs	r1, r6
     568:	0028      	movs	r0, r5
     56a:	4b09      	ldr	r3, [pc, #36]	; (590 <disk_write+0x4c>)
     56c:	4798      	blx	r3
    if(res == 0)
     56e:	1e43      	subs	r3, r0, #1
     570:	4198      	sbcs	r0, r3
        return RES_PARERR;
     572:	b2c3      	uxtb	r3, r0
     574:	e7ed      	b.n	552 <disk_write+0xe>
    	UART3_Write_Text("write 1 \n");
     576:	4807      	ldr	r0, [pc, #28]	; (594 <disk_write+0x50>)
     578:	4b04      	ldr	r3, [pc, #16]	; (58c <disk_write+0x48>)
     57a:	4798      	blx	r3
        res = SDCard_WriteSingleBlock(sector, buff);
     57c:	0031      	movs	r1, r6
     57e:	0028      	movs	r0, r5
     580:	4b05      	ldr	r3, [pc, #20]	; (598 <disk_write+0x54>)
     582:	4798      	blx	r3
     584:	e7f3      	b.n	56e <disk_write+0x2a>
     586:	46c0      	nop			; (mov r8, r8)
     588:	00002b70 	.word	0x00002b70
     58c:	000024ed 	.word	0x000024ed
     590:	000021a9 	.word	0x000021a9
     594:	00002b64 	.word	0x00002b64
     598:	000020c5 	.word	0x000020c5

0000059c <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,               /* Physical drive number (0..) */
	BYTE cmd,                /* Control code */
	void *buff               /* Buffer to send/receive control data */
)
{
     59c:	b510      	push	{r4, lr}
     59e:	b084      	sub	sp, #16
     5a0:	0014      	movs	r4, r2
	BYTE n, csd[16];
	DWORD csize;

	if (pdrv)
	{
		 return RES_PARERR;
     5a2:	2304      	movs	r3, #4
	if (pdrv)
     5a4:	2800      	cmp	r0, #0
     5a6:	d002      	beq.n	5ae <disk_ioctl+0x12>
		
		default:
		 res = RES_PARERR; break;
	}
	return res;
}
     5a8:	0018      	movs	r0, r3
     5aa:	b004      	add	sp, #16
     5ac:	bd10      	pop	{r4, pc}
	switch (cmd)
     5ae:	2901      	cmp	r1, #1
     5b0:	d026      	beq.n	600 <disk_ioctl+0x64>
     5b2:	2900      	cmp	r1, #0
     5b4:	d06c      	beq.n	690 <disk_ioctl+0xf4>
     5b6:	2902      	cmp	r1, #2
     5b8:	d065      	beq.n	686 <disk_ioctl+0xea>
     5ba:	2903      	cmp	r1, #3
     5bc:	d1f4      	bne.n	5a8 <disk_ioctl+0xc>
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5be:	2295      	movs	r2, #149	; 0x95
     5c0:	2100      	movs	r1, #0
     5c2:	2049      	movs	r0, #73	; 0x49
     5c4:	4b33      	ldr	r3, [pc, #204]	; (694 <disk_ioctl+0xf8>)
     5c6:	4798      	blx	r3
	res = RES_ERROR;
     5c8:	2301      	movs	r3, #1
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5ca:	2800      	cmp	r0, #0
     5cc:	d1ec      	bne.n	5a8 <disk_ioctl+0xc>
     5ce:	4669      	mov	r1, sp
     5d0:	3049      	adds	r0, #73	; 0x49
     5d2:	4b31      	ldr	r3, [pc, #196]	; (698 <disk_ioctl+0xfc>)
     5d4:	4798      	blx	r3
	res = RES_ERROR;
     5d6:	2301      	movs	r3, #1
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5d8:	2800      	cmp	r0, #0
     5da:	d0e5      	beq.n	5a8 <disk_ioctl+0xc>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     5dc:	466b      	mov	r3, sp
     5de:	7a9a      	ldrb	r2, [r3, #10]
     5e0:	0052      	lsls	r2, r2, #1
     5e2:	237e      	movs	r3, #126	; 0x7e
     5e4:	4013      	ands	r3, r2
     5e6:	466a      	mov	r2, sp
     5e8:	7ad2      	ldrb	r2, [r2, #11]
     5ea:	09d2      	lsrs	r2, r2, #7
     5ec:	189b      	adds	r3, r3, r2
     5ee:	3301      	adds	r3, #1
     5f0:	466a      	mov	r2, sp
     5f2:	7b52      	ldrb	r2, [r2, #13]
     5f4:	0992      	lsrs	r2, r2, #6
     5f6:	3a01      	subs	r2, #1
     5f8:	4093      	lsls	r3, r2
     5fa:	6023      	str	r3, [r4, #0]
					res = RES_OK;
     5fc:	2300      	movs	r3, #0
     5fe:	e7d3      	b.n	5a8 <disk_ioctl+0xc>
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     600:	2295      	movs	r2, #149	; 0x95
     602:	2100      	movs	r1, #0
     604:	2049      	movs	r0, #73	; 0x49
     606:	4b23      	ldr	r3, [pc, #140]	; (694 <disk_ioctl+0xf8>)
     608:	4798      	blx	r3
	res = RES_ERROR;
     60a:	2301      	movs	r3, #1
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     60c:	2800      	cmp	r0, #0
     60e:	d1cb      	bne.n	5a8 <disk_ioctl+0xc>
     610:	4669      	mov	r1, sp
     612:	3049      	adds	r0, #73	; 0x49
     614:	4b20      	ldr	r3, [pc, #128]	; (698 <disk_ioctl+0xfc>)
     616:	4798      	blx	r3
	res = RES_ERROR;
     618:	2301      	movs	r3, #1
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     61a:	2800      	cmp	r0, #0
     61c:	d0c4      	beq.n	5a8 <disk_ioctl+0xc>
					if((csd[0] >> 6) == 1) /* SDC ver 2.00 */
     61e:	466b      	mov	r3, sp
     620:	781b      	ldrb	r3, [r3, #0]
     622:	099b      	lsrs	r3, r3, #6
     624:	2b01      	cmp	r3, #1
     626:	d023      	beq.n	670 <disk_ioctl+0xd4>
						csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     628:	466b      	mov	r3, sp
     62a:	7a1b      	ldrb	r3, [r3, #8]
     62c:	099b      	lsrs	r3, r3, #6
     62e:	466a      	mov	r2, sp
     630:	79d2      	ldrb	r2, [r2, #7]
     632:	0092      	lsls	r2, r2, #2
     634:	189b      	adds	r3, r3, r2
     636:	466a      	mov	r2, sp
     638:	7992      	ldrb	r2, [r2, #6]
     63a:	0292      	lsls	r2, r2, #10
     63c:	21c0      	movs	r1, #192	; 0xc0
     63e:	0109      	lsls	r1, r1, #4
     640:	400a      	ands	r2, r1
     642:	189a      	adds	r2, r3, r2
     644:	3201      	adds	r2, #1
						n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     646:	466b      	mov	r3, sp
     648:	7959      	ldrb	r1, [r3, #5]
     64a:	230f      	movs	r3, #15
     64c:	400b      	ands	r3, r1
     64e:	4669      	mov	r1, sp
     650:	7a89      	ldrb	r1, [r1, #10]
     652:	09c9      	lsrs	r1, r1, #7
     654:	185b      	adds	r3, r3, r1
     656:	3302      	adds	r3, #2
     658:	4669      	mov	r1, sp
     65a:	7a48      	ldrb	r0, [r1, #9]
     65c:	0040      	lsls	r0, r0, #1
     65e:	2106      	movs	r1, #6
     660:	4001      	ands	r1, r0
     662:	185b      	adds	r3, r3, r1
						*(DWORD*)buff = (DWORD)csize << (n - 9);
     664:	b2db      	uxtb	r3, r3
     666:	3b09      	subs	r3, #9
     668:	409a      	lsls	r2, r3
     66a:	6022      	str	r2, [r4, #0]
					res = RES_OK;
     66c:	2300      	movs	r3, #0
     66e:	e79b      	b.n	5a8 <disk_ioctl+0xc>
						csize = csd[9] + ((WORD)csd[8] << 8) + 1;
     670:	466b      	mov	r3, sp
     672:	7a1b      	ldrb	r3, [r3, #8]
     674:	021b      	lsls	r3, r3, #8
     676:	466a      	mov	r2, sp
     678:	7a52      	ldrb	r2, [r2, #9]
     67a:	189b      	adds	r3, r3, r2
     67c:	3301      	adds	r3, #1
						*(DWORD*)buff = (DWORD)csize << 10;
     67e:	029b      	lsls	r3, r3, #10
     680:	6023      	str	r3, [r4, #0]
					res = RES_OK;
     682:	2300      	movs	r3, #0
     684:	e790      	b.n	5a8 <disk_ioctl+0xc>
				*(WORD*)buff = 512;
     686:	2380      	movs	r3, #128	; 0x80
     688:	009b      	lsls	r3, r3, #2
     68a:	8013      	strh	r3, [r2, #0]
				res = RES_OK;
     68c:	2300      	movs	r3, #0
				break;
     68e:	e78b      	b.n	5a8 <disk_ioctl+0xc>
		case CTRL_SYNC        : res = RES_OK; break;
     690:	2300      	movs	r3, #0
     692:	e789      	b.n	5a8 <disk_ioctl+0xc>
     694:	00001d29 	.word	0x00001d29
     698:	00001f21 	.word	0x00001f21

0000069c <get_fattime>:

// FATTIME Work around
DWORD get_fattime (void)
{
	return 0;
}
     69c:	2000      	movs	r0, #0
     69e:	4770      	bx	lr

000006a0 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
     6a0:	b510      	push	{r4, lr}
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
     6a2:	2a00      	cmp	r2, #0
     6a4:	d005      	beq.n	6b2 <mem_cpy+0x12>
     6a6:	2300      	movs	r3, #0
		*d++ = *s++;
     6a8:	5ccc      	ldrb	r4, [r1, r3]
     6aa:	54c4      	strb	r4, [r0, r3]
     6ac:	3301      	adds	r3, #1
	while (cnt--)
     6ae:	4293      	cmp	r3, r2
     6b0:	d1fa      	bne.n	6a8 <mem_cpy+0x8>
}
     6b2:	bd10      	pop	{r4, pc}

000006b4 <ld_clust>:
static
DWORD ld_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir	/* Pointer to the directory entry */
)
{
     6b4:	b510      	push	{r4, lr}
     6b6:	0004      	movs	r4, r0
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
     6b8:	7eca      	ldrb	r2, [r1, #27]
     6ba:	0212      	lsls	r2, r2, #8
     6bc:	7e88      	ldrb	r0, [r1, #26]
     6be:	4310      	orrs	r0, r2
	if (fs->fs_type == FS_FAT32)
     6c0:	7823      	ldrb	r3, [r4, #0]
     6c2:	2b03      	cmp	r3, #3
     6c4:	d000      	beq.n	6c8 <ld_clust+0x14>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
     6c6:	bd10      	pop	{r4, pc}
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
     6c8:	7d4a      	ldrb	r2, [r1, #21]
     6ca:	0212      	lsls	r2, r2, #8
     6cc:	7d0b      	ldrb	r3, [r1, #20]
     6ce:	4313      	orrs	r3, r2
     6d0:	041b      	lsls	r3, r3, #16
     6d2:	4318      	orrs	r0, r3
	return cl;
     6d4:	e7f7      	b.n	6c6 <ld_clust+0x12>

000006d6 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
     6d6:	b530      	push	{r4, r5, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
     6d8:	6801      	ldr	r1, [r0, #0]
     6da:	2900      	cmp	r1, #0
     6dc:	d01b      	beq.n	716 <get_ldnumber+0x40>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     6de:	780c      	ldrb	r4, [r1, #0]
     6e0:	2c20      	cmp	r4, #32
     6e2:	d911      	bls.n	708 <get_ldnumber+0x32>
     6e4:	2c3a      	cmp	r4, #58	; 0x3a
     6e6:	d01f      	beq.n	728 <get_ldnumber+0x52>
     6e8:	000b      	movs	r3, r1
     6ea:	3301      	adds	r3, #1
     6ec:	781a      	ldrb	r2, [r3, #0]
     6ee:	2a20      	cmp	r2, #32
     6f0:	d90c      	bls.n	70c <get_ldnumber+0x36>
     6f2:	2a3a      	cmp	r2, #58	; 0x3a
     6f4:	d1f9      	bne.n	6ea <get_ldnumber+0x14>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
     6f6:	1c4a      	adds	r2, r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
     6f8:	4293      	cmp	r3, r2
     6fa:	d10f      	bne.n	71c <get_ldnumber+0x46>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
     6fc:	2c30      	cmp	r4, #48	; 0x30
     6fe:	d110      	bne.n	722 <get_ldnumber+0x4c>
					vol = (int)i;
					*path = ++tt;
     700:	3102      	adds	r1, #2
     702:	6001      	str	r1, [r0, #0]
					vol = (int)i;
     704:	2500      	movs	r5, #0
     706:	e004      	b.n	712 <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     708:	0022      	movs	r2, r4
     70a:	000b      	movs	r3, r1
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
     70c:	2500      	movs	r5, #0
		if (*tt == ':') {	/* If a ':' is exist in the path name */
     70e:	2a3a      	cmp	r2, #58	; 0x3a
     710:	d0f1      	beq.n	6f6 <get_ldnumber+0x20>
#endif
	}
	return vol;
}
     712:	0028      	movs	r0, r5
     714:	bd30      	pop	{r4, r5, pc}
	int vol = -1;
     716:	2501      	movs	r5, #1
     718:	426d      	negs	r5, r5
     71a:	e7fa      	b.n	712 <get_ldnumber+0x3c>
     71c:	2501      	movs	r5, #1
     71e:	426d      	negs	r5, r5
     720:	e7f7      	b.n	712 <get_ldnumber+0x3c>
     722:	2501      	movs	r5, #1
     724:	426d      	negs	r5, r5
     726:	e7f4      	b.n	712 <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     728:	000b      	movs	r3, r1
     72a:	e7e4      	b.n	6f6 <get_ldnumber+0x20>

0000072c <sync_window>:
{
     72c:	b5f0      	push	{r4, r5, r6, r7, lr}
     72e:	b083      	sub	sp, #12
     730:	0004      	movs	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
     732:	7903      	ldrb	r3, [r0, #4]
	FRESULT res = FR_OK;
     734:	2000      	movs	r0, #0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
     736:	2b00      	cmp	r3, #0
     738:	d101      	bne.n	73e <sync_window+0x12>
}
     73a:	b003      	add	sp, #12
     73c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
     73e:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
     740:	2330      	movs	r3, #48	; 0x30
     742:	469c      	mov	ip, r3
     744:	44a4      	add	ip, r4
     746:	4663      	mov	r3, ip
     748:	4661      	mov	r1, ip
     74a:	9301      	str	r3, [sp, #4]
     74c:	7860      	ldrb	r0, [r4, #1]
     74e:	2301      	movs	r3, #1
     750:	002a      	movs	r2, r5
     752:	4e10      	ldr	r6, [pc, #64]	; (794 <sync_window+0x68>)
     754:	47b0      	blx	r6
     756:	0003      	movs	r3, r0
			res = FR_DISK_ERR;
     758:	2001      	movs	r0, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
     75a:	2b00      	cmp	r3, #0
     75c:	d1ed      	bne.n	73a <sync_window+0xe>
			fs->wflag = 0;
     75e:	7123      	strb	r3, [r4, #4]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
     760:	6a23      	ldr	r3, [r4, #32]
     762:	1aeb      	subs	r3, r5, r3
	FRESULT res = FR_OK;
     764:	2000      	movs	r0, #0
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
     766:	69a2      	ldr	r2, [r4, #24]
     768:	4293      	cmp	r3, r2
     76a:	d2e6      	bcs.n	73a <sync_window+0xe>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
     76c:	78e6      	ldrb	r6, [r4, #3]
     76e:	2e01      	cmp	r6, #1
     770:	d90d      	bls.n	78e <sync_window+0x62>
					disk_write(fs->drv, fs->win, wsect, 1);
     772:	4f08      	ldr	r7, [pc, #32]	; (794 <sync_window+0x68>)
					wsect += fs->fsize;
     774:	69a3      	ldr	r3, [r4, #24]
     776:	469c      	mov	ip, r3
     778:	4465      	add	r5, ip
					disk_write(fs->drv, fs->win, wsect, 1);
     77a:	7860      	ldrb	r0, [r4, #1]
     77c:	2301      	movs	r3, #1
     77e:	002a      	movs	r2, r5
     780:	9901      	ldr	r1, [sp, #4]
     782:	47b8      	blx	r7
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
     784:	3e01      	subs	r6, #1
     786:	2e01      	cmp	r6, #1
     788:	d1f4      	bne.n	774 <sync_window+0x48>
	FRESULT res = FR_OK;
     78a:	2000      	movs	r0, #0
     78c:	e7d5      	b.n	73a <sync_window+0xe>
     78e:	2000      	movs	r0, #0
     790:	e7d3      	b.n	73a <sync_window+0xe>
     792:	46c0      	nop			; (mov r8, r8)
     794:	00000545 	.word	0x00000545

00000798 <move_window>:
{
     798:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     79a:	0005      	movs	r5, r0
     79c:	000e      	movs	r6, r1
	FRESULT res = FR_OK;
     79e:	2400      	movs	r4, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
     7a0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     7a2:	428b      	cmp	r3, r1
     7a4:	d003      	beq.n	7ae <move_window+0x16>
		res = sync_window(fs);		/* Write-back changes */
     7a6:	4b0a      	ldr	r3, [pc, #40]	; (7d0 <move_window+0x38>)
     7a8:	4798      	blx	r3
     7aa:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {			/* Fill sector window with new data */
     7ac:	d001      	beq.n	7b2 <move_window+0x1a>
}
     7ae:	0020      	movs	r0, r4
     7b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
     7b2:	0029      	movs	r1, r5
     7b4:	3130      	adds	r1, #48	; 0x30
     7b6:	7868      	ldrb	r0, [r5, #1]
     7b8:	2301      	movs	r3, #1
     7ba:	0032      	movs	r2, r6
     7bc:	4f05      	ldr	r7, [pc, #20]	; (7d4 <move_window+0x3c>)
     7be:	47b8      	blx	r7
     7c0:	2800      	cmp	r0, #0
     7c2:	d002      	beq.n	7ca <move_window+0x32>
				res = FR_DISK_ERR;
     7c4:	3401      	adds	r4, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
     7c6:	2601      	movs	r6, #1
     7c8:	4276      	negs	r6, r6
			fs->winsect = sector;
     7ca:	62ee      	str	r6, [r5, #44]	; 0x2c
     7cc:	e7ef      	b.n	7ae <move_window+0x16>
     7ce:	46c0      	nop			; (mov r8, r8)
     7d0:	0000072d 	.word	0x0000072d
     7d4:	000004f9 	.word	0x000004f9

000007d8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     7d8:	b510      	push	{r4, lr}
     7da:	0004      	movs	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
     7dc:	2300      	movs	r3, #0
     7de:	7103      	strb	r3, [r0, #4]
     7e0:	3b01      	subs	r3, #1
     7e2:	62c3      	str	r3, [r0, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
     7e4:	4b1e      	ldr	r3, [pc, #120]	; (860 <check_fs+0x88>)
     7e6:	4798      	blx	r3
		return 3;
     7e8:	2303      	movs	r3, #3
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
     7ea:	2800      	cmp	r0, #0
     7ec:	d001      	beq.n	7f2 <check_fs+0x1a>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
     7ee:	0018      	movs	r0, r3
     7f0:	bd10      	pop	{r4, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
     7f2:	4b1c      	ldr	r3, [pc, #112]	; (864 <check_fs+0x8c>)
     7f4:	5ce3      	ldrb	r3, [r4, r3]
     7f6:	021b      	lsls	r3, r3, #8
     7f8:	4a1b      	ldr	r2, [pc, #108]	; (868 <check_fs+0x90>)
     7fa:	5ca2      	ldrb	r2, [r4, r2]
     7fc:	431a      	orrs	r2, r3
     7fe:	491b      	ldr	r1, [pc, #108]	; (86c <check_fs+0x94>)
     800:	b212      	sxth	r2, r2
		return 2;
     802:	2302      	movs	r3, #2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
     804:	428a      	cmp	r2, r1
     806:	d1f2      	bne.n	7ee <check_fs+0x16>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
     808:	3367      	adds	r3, #103	; 0x67
     80a:	5ce3      	ldrb	r3, [r4, r3]
     80c:	061b      	lsls	r3, r3, #24
     80e:	2268      	movs	r2, #104	; 0x68
     810:	5ca2      	ldrb	r2, [r4, r2]
     812:	0412      	lsls	r2, r2, #16
     814:	4313      	orrs	r3, r2
     816:	2266      	movs	r2, #102	; 0x66
     818:	5ca2      	ldrb	r2, [r4, r2]
     81a:	4313      	orrs	r3, r2
     81c:	2267      	movs	r2, #103	; 0x67
     81e:	5ca2      	ldrb	r2, [r4, r2]
     820:	0212      	lsls	r2, r2, #8
     822:	4313      	orrs	r3, r2
     824:	021b      	lsls	r3, r3, #8
     826:	0a1b      	lsrs	r3, r3, #8
     828:	4a11      	ldr	r2, [pc, #68]	; (870 <check_fs+0x98>)
     82a:	4293      	cmp	r3, r2
     82c:	d016      	beq.n	85c <check_fs+0x84>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
     82e:	2385      	movs	r3, #133	; 0x85
     830:	5ce3      	ldrb	r3, [r4, r3]
     832:	061b      	lsls	r3, r3, #24
     834:	2284      	movs	r2, #132	; 0x84
     836:	5ca2      	ldrb	r2, [r4, r2]
     838:	0412      	lsls	r2, r2, #16
     83a:	4313      	orrs	r3, r2
     83c:	2282      	movs	r2, #130	; 0x82
     83e:	5ca2      	ldrb	r2, [r4, r2]
     840:	4313      	orrs	r3, r2
     842:	2283      	movs	r2, #131	; 0x83
     844:	5ca2      	ldrb	r2, [r4, r2]
     846:	0212      	lsls	r2, r2, #8
     848:	4313      	orrs	r3, r2
     84a:	021b      	lsls	r3, r3, #8
     84c:	0a1b      	lsrs	r3, r3, #8
     84e:	4a09      	ldr	r2, [pc, #36]	; (874 <check_fs+0x9c>)
     850:	4694      	mov	ip, r2
     852:	4463      	add	r3, ip
     854:	1e58      	subs	r0, r3, #1
     856:	4183      	sbcs	r3, r0
		return 3;
     858:	b2db      	uxtb	r3, r3
     85a:	e7c8      	b.n	7ee <check_fs+0x16>
		return 0;
     85c:	2300      	movs	r3, #0
     85e:	e7c6      	b.n	7ee <check_fs+0x16>
     860:	00000799 	.word	0x00000799
     864:	0000022f 	.word	0x0000022f
     868:	0000022e 	.word	0x0000022e
     86c:	ffffaa55 	.word	0xffffaa55
     870:	00544146 	.word	0x00544146
     874:	ffabbeba 	.word	0xffabbeba

00000878 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
     878:	b510      	push	{r4, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     87a:	2800      	cmp	r0, #0
     87c:	d014      	beq.n	8a8 <validate+0x30>
     87e:	6802      	ldr	r2, [r0, #0]
     880:	2a00      	cmp	r2, #0
     882:	d013      	beq.n	8ac <validate+0x34>
     884:	7811      	ldrb	r1, [r2, #0]
		return FR_INVALID_OBJECT;
     886:	2309      	movs	r3, #9
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     888:	2900      	cmp	r1, #0
     88a:	d101      	bne.n	890 <validate+0x18>

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
     88c:	0018      	movs	r0, r3
     88e:	bd10      	pop	{r4, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     890:	88d4      	ldrh	r4, [r2, #6]
     892:	8881      	ldrh	r1, [r0, #4]
     894:	428c      	cmp	r4, r1
     896:	d1f9      	bne.n	88c <validate+0x14>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
     898:	7850      	ldrb	r0, [r2, #1]
     89a:	4b05      	ldr	r3, [pc, #20]	; (8b0 <validate+0x38>)
     89c:	4798      	blx	r3
		return FR_NOT_READY;
     89e:	2303      	movs	r3, #3
	return FR_OK;
     8a0:	07c0      	lsls	r0, r0, #31
     8a2:	17c0      	asrs	r0, r0, #31
     8a4:	4003      	ands	r3, r0
     8a6:	e7f1      	b.n	88c <validate+0x14>
		return FR_INVALID_OBJECT;
     8a8:	2309      	movs	r3, #9
     8aa:	e7ef      	b.n	88c <validate+0x14>
     8ac:	2309      	movs	r3, #9
     8ae:	e7ed      	b.n	88c <validate+0x14>
     8b0:	000004d9 	.word	0x000004d9

000008b4 <find_volume>:
{
     8b4:	b5f0      	push	{r4, r5, r6, r7, lr}
     8b6:	46d6      	mov	lr, sl
     8b8:	464f      	mov	r7, r9
     8ba:	4646      	mov	r6, r8
     8bc:	b5c0      	push	{r6, r7, lr}
     8be:	b084      	sub	sp, #16
     8c0:	0007      	movs	r7, r0
     8c2:	0016      	movs	r6, r2
	*rfs = 0;
     8c4:	2300      	movs	r3, #0
     8c6:	6003      	str	r3, [r0, #0]
	vol = get_ldnumber(path);
     8c8:	0008      	movs	r0, r1
     8ca:	4b9f      	ldr	r3, [pc, #636]	; (b48 <find_volume+0x294>)
     8cc:	4798      	blx	r3
     8ce:	0004      	movs	r4, r0
	if (vol < 0) return FR_INVALID_DRIVE;
     8d0:	230b      	movs	r3, #11
     8d2:	2800      	cmp	r0, #0
     8d4:	db1f      	blt.n	916 <find_volume+0x62>
	fs = FatFs[vol];					/* Get pointer to the file system object */
     8d6:	0083      	lsls	r3, r0, #2
     8d8:	4a9c      	ldr	r2, [pc, #624]	; (b4c <find_volume+0x298>)
     8da:	589d      	ldr	r5, [r3, r2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
     8dc:	2d00      	cmp	r5, #0
     8de:	d100      	bne.n	8e2 <find_volume+0x2e>
     8e0:	e1a7      	b.n	c32 <find_volume+0x37e>
	*rfs = fs;							/* Return pointer to the file system object */
     8e2:	603d      	str	r5, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
     8e4:	782b      	ldrb	r3, [r5, #0]
     8e6:	2b00      	cmp	r3, #0
     8e8:	d00c      	beq.n	904 <find_volume+0x50>
		stat = disk_status(fs->drv);
     8ea:	7868      	ldrb	r0, [r5, #1]
     8ec:	4b98      	ldr	r3, [pc, #608]	; (b50 <find_volume+0x29c>)
     8ee:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
     8f0:	07c3      	lsls	r3, r0, #31
     8f2:	d407      	bmi.n	904 <find_volume+0x50>
			return FR_OK;				/* The file system object is valid */
     8f4:	2300      	movs	r3, #0
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
     8f6:	2e00      	cmp	r6, #0
     8f8:	d00d      	beq.n	916 <find_volume+0x62>
     8fa:	0743      	lsls	r3, r0, #29
     8fc:	d400      	bmi.n	900 <find_volume+0x4c>
     8fe:	e19a      	b.n	c36 <find_volume+0x382>
				return FR_WRITE_PROTECTED;
     900:	230a      	movs	r3, #10
     902:	e008      	b.n	916 <find_volume+0x62>
	fs->fs_type = 0;					/* Clear the file system object */
     904:	2300      	movs	r3, #0
     906:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
     908:	b2e0      	uxtb	r0, r4
     90a:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
     90c:	4b91      	ldr	r3, [pc, #580]	; (b54 <find_volume+0x2a0>)
     90e:	4798      	blx	r3
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
     910:	2303      	movs	r3, #3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
     912:	07c2      	lsls	r2, r0, #31
     914:	d506      	bpl.n	924 <find_volume+0x70>
}
     916:	0018      	movs	r0, r3
     918:	b004      	add	sp, #16
     91a:	bc1c      	pop	{r2, r3, r4}
     91c:	4690      	mov	r8, r2
     91e:	4699      	mov	r9, r3
     920:	46a2      	mov	sl, r4
     922:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
     924:	2e00      	cmp	r6, #0
     926:	d002      	beq.n	92e <find_volume+0x7a>
		return FR_WRITE_PROTECTED;
     928:	3307      	adds	r3, #7
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
     92a:	0742      	lsls	r2, r0, #29
     92c:	d4f3      	bmi.n	916 <find_volume+0x62>
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
     92e:	2100      	movs	r1, #0
     930:	0028      	movs	r0, r5
     932:	4b89      	ldr	r3, [pc, #548]	; (b58 <find_volume+0x2a4>)
     934:	4798      	blx	r3
	bsect = 0;
     936:	2700      	movs	r7, #0
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
     938:	2801      	cmp	r0, #1
     93a:	d100      	bne.n	93e <find_volume+0x8a>
     93c:	e0b4      	b.n	aa8 <find_volume+0x1f4>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
     93e:	2803      	cmp	r0, #3
     940:	d100      	bne.n	944 <find_volume+0x90>
     942:	e17a      	b.n	c3a <find_volume+0x386>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
     944:	230d      	movs	r3, #13
     946:	2800      	cmp	r0, #0
     948:	d1e5      	bne.n	916 <find_volume+0x62>
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
     94a:	233c      	movs	r3, #60	; 0x3c
     94c:	5ceb      	ldrb	r3, [r5, r3]
     94e:	021b      	lsls	r3, r3, #8
     950:	223b      	movs	r2, #59	; 0x3b
     952:	5caa      	ldrb	r2, [r5, r2]
     954:	431a      	orrs	r2, r3
     956:	2180      	movs	r1, #128	; 0x80
     958:	0089      	lsls	r1, r1, #2
     95a:	b212      	sxth	r2, r2
		return FR_NO_FILESYSTEM;
     95c:	230d      	movs	r3, #13
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
     95e:	428a      	cmp	r2, r1
     960:	d1d9      	bne.n	916 <find_volume+0x62>
	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
     962:	333a      	adds	r3, #58	; 0x3a
     964:	5ceb      	ldrb	r3, [r5, r3]
     966:	021b      	lsls	r3, r3, #8
     968:	2246      	movs	r2, #70	; 0x46
     96a:	5cac      	ldrb	r4, [r5, r2]
     96c:	431c      	orrs	r4, r3
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
     96e:	d10d      	bne.n	98c <find_volume+0xd8>
     970:	2357      	movs	r3, #87	; 0x57
     972:	5cec      	ldrb	r4, [r5, r3]
     974:	0624      	lsls	r4, r4, #24
     976:	3b01      	subs	r3, #1
     978:	5ceb      	ldrb	r3, [r5, r3]
     97a:	041b      	lsls	r3, r3, #16
     97c:	431c      	orrs	r4, r3
     97e:	2354      	movs	r3, #84	; 0x54
     980:	5ceb      	ldrb	r3, [r5, r3]
     982:	431c      	orrs	r4, r3
     984:	2355      	movs	r3, #85	; 0x55
     986:	5ceb      	ldrb	r3, [r5, r3]
     988:	021b      	lsls	r3, r3, #8
     98a:	431c      	orrs	r4, r3
	fs->fsize = fasize;
     98c:	61ac      	str	r4, [r5, #24]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
     98e:	2340      	movs	r3, #64	; 0x40
     990:	5cea      	ldrb	r2, [r5, r3]
     992:	70ea      	strb	r2, [r5, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
     994:	1e51      	subs	r1, r2, #1
		return FR_NO_FILESYSTEM;
     996:	3b33      	subs	r3, #51	; 0x33
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
     998:	2901      	cmp	r1, #1
     99a:	d8bc      	bhi.n	916 <find_volume+0x62>
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
     99c:	3330      	adds	r3, #48	; 0x30
     99e:	5ce9      	ldrb	r1, [r5, r3]
     9a0:	70a9      	strb	r1, [r5, #2]
		return FR_NO_FILESYSTEM;
     9a2:	3b30      	subs	r3, #48	; 0x30
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
     9a4:	2900      	cmp	r1, #0
     9a6:	d0b6      	beq.n	916 <find_volume+0x62>
     9a8:	1e48      	subs	r0, r1, #1
     9aa:	4201      	tst	r1, r0
     9ac:	d1b3      	bne.n	916 <find_volume+0x62>
	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
     9ae:	3335      	adds	r3, #53	; 0x35
     9b0:	5ceb      	ldrb	r3, [r5, r3]
     9b2:	021b      	lsls	r3, r3, #8
     9b4:	2041      	movs	r0, #65	; 0x41
     9b6:	5c28      	ldrb	r0, [r5, r0]
     9b8:	4318      	orrs	r0, r3
     9ba:	4682      	mov	sl, r0
     9bc:	8128      	strh	r0, [r5, #8]
		return FR_NO_FILESYSTEM;
     9be:	230d      	movs	r3, #13
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
     9c0:	0700      	lsls	r0, r0, #28
     9c2:	d1a8      	bne.n	916 <find_volume+0x62>
	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
     9c4:	3337      	adds	r3, #55	; 0x37
     9c6:	5ceb      	ldrb	r3, [r5, r3]
     9c8:	021b      	lsls	r3, r3, #8
     9ca:	2043      	movs	r0, #67	; 0x43
     9cc:	5c28      	ldrb	r0, [r5, r0]
     9ce:	4318      	orrs	r0, r3
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
     9d0:	d10d      	bne.n	9ee <find_volume+0x13a>
     9d2:	2353      	movs	r3, #83	; 0x53
     9d4:	5ce8      	ldrb	r0, [r5, r3]
     9d6:	0600      	lsls	r0, r0, #24
     9d8:	3b01      	subs	r3, #1
     9da:	5ceb      	ldrb	r3, [r5, r3]
     9dc:	041b      	lsls	r3, r3, #16
     9de:	4318      	orrs	r0, r3
     9e0:	2350      	movs	r3, #80	; 0x50
     9e2:	5ceb      	ldrb	r3, [r5, r3]
     9e4:	4318      	orrs	r0, r3
     9e6:	2351      	movs	r3, #81	; 0x51
     9e8:	5ceb      	ldrb	r3, [r5, r3]
     9ea:	021b      	lsls	r3, r3, #8
     9ec:	4318      	orrs	r0, r3
	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
     9ee:	233f      	movs	r3, #63	; 0x3f
     9f0:	5ceb      	ldrb	r3, [r5, r3]
     9f2:	021b      	lsls	r3, r3, #8
     9f4:	263e      	movs	r6, #62	; 0x3e
     9f6:	5dae      	ldrb	r6, [r5, r6]
     9f8:	431e      	orrs	r6, r3
     9fa:	46b0      	mov	r8, r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
     9fc:	230d      	movs	r3, #13
     9fe:	2e00      	cmp	r6, #0
     a00:	d100      	bne.n	a04 <find_volume+0x150>
     a02:	e788      	b.n	916 <find_volume+0x62>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
     a04:	4362      	muls	r2, r4
     a06:	4691      	mov	r9, r2
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
     a08:	4653      	mov	r3, sl
     a0a:	091e      	lsrs	r6, r3, #4
     a0c:	4446      	add	r6, r8
     a0e:	444e      	add	r6, r9
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
     a10:	230d      	movs	r3, #13
     a12:	42b0      	cmp	r0, r6
     a14:	d200      	bcs.n	a18 <find_volume+0x164>
     a16:	e77e      	b.n	916 <find_volume+0x62>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
     a18:	1b80      	subs	r0, r0, r6
     a1a:	4b50      	ldr	r3, [pc, #320]	; (b5c <find_volume+0x2a8>)
     a1c:	4798      	blx	r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
     a1e:	230d      	movs	r3, #13
     a20:	2800      	cmp	r0, #0
     a22:	d100      	bne.n	a26 <find_volume+0x172>
     a24:	e777      	b.n	916 <find_volume+0x62>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
     a26:	4a4e      	ldr	r2, [pc, #312]	; (b60 <find_volume+0x2ac>)
     a28:	4282      	cmp	r2, r0
     a2a:	4192      	sbcs	r2, r2
     a2c:	4252      	negs	r2, r2
     a2e:	3201      	adds	r2, #1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
     a30:	4b4c      	ldr	r3, [pc, #304]	; (b64 <find_volume+0x2b0>)
     a32:	4298      	cmp	r0, r3
     a34:	d900      	bls.n	a38 <find_volume+0x184>
     a36:	e102      	b.n	c3e <find_volume+0x38a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
     a38:	3002      	adds	r0, #2
     a3a:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
     a3c:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
     a3e:	4643      	mov	r3, r8
     a40:	19d9      	adds	r1, r3, r7
     a42:	6229      	str	r1, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
     a44:	19f6      	adds	r6, r6, r7
     a46:	62ae      	str	r6, [r5, #40]	; 0x28
	if (fmt == FS_FAT32) {
     a48:	2a03      	cmp	r2, #3
     a4a:	d15b      	bne.n	b04 <find_volume+0x250>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
     a4c:	230d      	movs	r3, #13
     a4e:	4652      	mov	r2, sl
     a50:	2a00      	cmp	r2, #0
     a52:	d000      	beq.n	a56 <find_volume+0x1a2>
     a54:	e75f      	b.n	916 <find_volume+0x62>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
     a56:	3352      	adds	r3, #82	; 0x52
     a58:	5ceb      	ldrb	r3, [r5, r3]
     a5a:	061b      	lsls	r3, r3, #24
     a5c:	325e      	adds	r2, #94	; 0x5e
     a5e:	5caa      	ldrb	r2, [r5, r2]
     a60:	0412      	lsls	r2, r2, #16
     a62:	4313      	orrs	r3, r2
     a64:	225c      	movs	r2, #92	; 0x5c
     a66:	5caa      	ldrb	r2, [r5, r2]
     a68:	4313      	orrs	r3, r2
     a6a:	225d      	movs	r2, #93	; 0x5d
     a6c:	5caa      	ldrb	r2, [r5, r2]
     a6e:	0212      	lsls	r2, r2, #8
     a70:	4313      	orrs	r3, r2
     a72:	626b      	str	r3, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
     a74:	0082      	lsls	r2, r0, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     a76:	4b3c      	ldr	r3, [pc, #240]	; (b68 <find_volume+0x2b4>)
     a78:	469c      	mov	ip, r3
     a7a:	4462      	add	r2, ip
     a7c:	0a52      	lsrs	r2, r2, #9
		return FR_NO_FILESYSTEM;
     a7e:	3bf3      	subs	r3, #243	; 0xf3
     a80:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     a82:	4294      	cmp	r4, r2
     a84:	d200      	bcs.n	a88 <find_volume+0x1d4>
     a86:	e746      	b.n	916 <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
     a88:	2301      	movs	r3, #1
     a8a:	425b      	negs	r3, r3
     a8c:	612b      	str	r3, [r5, #16]
     a8e:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
     a90:	3381      	adds	r3, #129	; 0x81
     a92:	716b      	strb	r3, [r5, #5]
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
     a94:	3b1f      	subs	r3, #31
     a96:	5cea      	ldrb	r2, [r5, r3]
     a98:	0212      	lsls	r2, r2, #8
     a9a:	3b01      	subs	r3, #1
     a9c:	5ceb      	ldrb	r3, [r5, r3]
     a9e:	4313      	orrs	r3, r2
     aa0:	2b01      	cmp	r3, #1
     aa2:	d063      	beq.n	b6c <find_volume+0x2b8>
     aa4:	2203      	movs	r2, #3
     aa6:	e0bb      	b.n	c20 <find_volume+0x36c>
     aa8:	002a      	movs	r2, r5
     aaa:	32f3      	adds	r2, #243	; 0xf3
     aac:	32ff      	adds	r2, #255	; 0xff
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
     aae:	2000      	movs	r0, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     ab0:	2100      	movs	r1, #0
     ab2:	e005      	b.n	ac0 <find_volume+0x20c>
     ab4:	466c      	mov	r4, sp
     ab6:	5103      	str	r3, [r0, r4]
     ab8:	3210      	adds	r2, #16
     aba:	3004      	adds	r0, #4
		for (i = 0; i < 4; i++) {			/* Get partition offset */
     abc:	2810      	cmp	r0, #16
     abe:	d00e      	beq.n	ade <find_volume+0x22a>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     ac0:	7814      	ldrb	r4, [r2, #0]
     ac2:	000b      	movs	r3, r1
     ac4:	2c00      	cmp	r4, #0
     ac6:	d0f5      	beq.n	ab4 <find_volume+0x200>
     ac8:	79d3      	ldrb	r3, [r2, #7]
     aca:	061b      	lsls	r3, r3, #24
     acc:	7994      	ldrb	r4, [r2, #6]
     ace:	0424      	lsls	r4, r4, #16
     ad0:	4323      	orrs	r3, r4
     ad2:	7914      	ldrb	r4, [r2, #4]
     ad4:	4323      	orrs	r3, r4
     ad6:	7954      	ldrb	r4, [r2, #5]
     ad8:	0224      	lsls	r4, r4, #8
     ada:	4323      	orrs	r3, r4
     adc:	e7ea      	b.n	ab4 <find_volume+0x200>
     ade:	2600      	movs	r6, #0
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
     ae0:	2402      	movs	r4, #2
     ae2:	e003      	b.n	aec <find_volume+0x238>
     ae4:	3604      	adds	r6, #4
		} while (!LD2PT(vol) && fmt && ++i < 4);
     ae6:	2e10      	cmp	r6, #16
     ae8:	d100      	bne.n	aec <find_volume+0x238>
     aea:	e728      	b.n	93e <find_volume+0x8a>
			bsect = br[i];
     aec:	466b      	mov	r3, sp
     aee:	58f7      	ldr	r7, [r6, r3]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
     af0:	0020      	movs	r0, r4
     af2:	2f00      	cmp	r7, #0
     af4:	d0f6      	beq.n	ae4 <find_volume+0x230>
     af6:	0039      	movs	r1, r7
     af8:	0028      	movs	r0, r5
     afa:	4b17      	ldr	r3, [pc, #92]	; (b58 <find_volume+0x2a4>)
     afc:	4798      	blx	r3
		} while (!LD2PT(vol) && fmt && ++i < 4);
     afe:	2800      	cmp	r0, #0
     b00:	d1f0      	bne.n	ae4 <find_volume+0x230>
     b02:	e722      	b.n	94a <find_volume+0x96>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
     b04:	230d      	movs	r3, #13
     b06:	4656      	mov	r6, sl
     b08:	2e00      	cmp	r6, #0
     b0a:	d100      	bne.n	b0e <find_volume+0x25a>
     b0c:	e703      	b.n	916 <find_volume+0x62>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
     b0e:	4449      	add	r1, r9
     b10:	6269      	str	r1, [r5, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
     b12:	2a02      	cmp	r2, #2
     b14:	d110      	bne.n	b38 <find_volume+0x284>
     b16:	0040      	lsls	r0, r0, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     b18:	4b13      	ldr	r3, [pc, #76]	; (b68 <find_volume+0x2b4>)
     b1a:	469c      	mov	ip, r3
     b1c:	4460      	add	r0, ip
     b1e:	0a40      	lsrs	r0, r0, #9
		return FR_NO_FILESYSTEM;
     b20:	3bf3      	subs	r3, #243	; 0xf3
     b22:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     b24:	4284      	cmp	r4, r0
     b26:	d200      	bcs.n	b2a <find_volume+0x276>
     b28:	e6f5      	b.n	916 <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
     b2a:	2301      	movs	r3, #1
     b2c:	425b      	negs	r3, r3
     b2e:	612b      	str	r3, [r5, #16]
     b30:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
     b32:	3381      	adds	r3, #129	; 0x81
     b34:	716b      	strb	r3, [r5, #5]
     b36:	e073      	b.n	c20 <find_volume+0x36c>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
     b38:	2303      	movs	r3, #3
     b3a:	4343      	muls	r3, r0
     b3c:	085b      	lsrs	r3, r3, #1
     b3e:	2101      	movs	r1, #1
     b40:	4008      	ands	r0, r1
     b42:	1818      	adds	r0, r3, r0
     b44:	e7e8      	b.n	b18 <find_volume+0x264>
     b46:	46c0      	nop			; (mov r8, r8)
     b48:	000006d7 	.word	0x000006d7
     b4c:	20000458 	.word	0x20000458
     b50:	000004d9 	.word	0x000004d9
     b54:	000004e1 	.word	0x000004e1
     b58:	000007d9 	.word	0x000007d9
     b5c:	0000250d 	.word	0x0000250d
     b60:	00000ff5 	.word	0x00000ff5
     b64:	0000fff5 	.word	0x0000fff5
     b68:	000001ff 	.word	0x000001ff
		&& move_window(fs, bsect + 1) == FR_OK)
     b6c:	1c79      	adds	r1, r7, #1
     b6e:	0028      	movs	r0, r5
     b70:	4b37      	ldr	r3, [pc, #220]	; (c50 <find_volume+0x39c>)
     b72:	4798      	blx	r3
     b74:	2203      	movs	r2, #3
     b76:	2800      	cmp	r0, #0
     b78:	d152      	bne.n	c20 <find_volume+0x36c>
		fs->fsi_flag = 0;
     b7a:	2300      	movs	r3, #0
     b7c:	716b      	strb	r3, [r5, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
     b7e:	4b35      	ldr	r3, [pc, #212]	; (c54 <find_volume+0x3a0>)
     b80:	5cea      	ldrb	r2, [r5, r3]
     b82:	0212      	lsls	r2, r2, #8
     b84:	4b34      	ldr	r3, [pc, #208]	; (c58 <find_volume+0x3a4>)
     b86:	5ceb      	ldrb	r3, [r5, r3]
     b88:	4313      	orrs	r3, r2
     b8a:	4934      	ldr	r1, [pc, #208]	; (c5c <find_volume+0x3a8>)
     b8c:	b21b      	sxth	r3, r3
     b8e:	2203      	movs	r2, #3
     b90:	428b      	cmp	r3, r1
     b92:	d145      	bne.n	c20 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
     b94:	2333      	movs	r3, #51	; 0x33
     b96:	5ceb      	ldrb	r3, [r5, r3]
     b98:	061b      	lsls	r3, r3, #24
     b9a:	322f      	adds	r2, #47	; 0x2f
     b9c:	5caa      	ldrb	r2, [r5, r2]
     b9e:	0412      	lsls	r2, r2, #16
     ba0:	4313      	orrs	r3, r2
     ba2:	2230      	movs	r2, #48	; 0x30
     ba4:	5caa      	ldrb	r2, [r5, r2]
     ba6:	4313      	orrs	r3, r2
     ba8:	2231      	movs	r2, #49	; 0x31
     baa:	5caa      	ldrb	r2, [r5, r2]
     bac:	0212      	lsls	r2, r2, #8
     bae:	4313      	orrs	r3, r2
     bb0:	492b      	ldr	r1, [pc, #172]	; (c60 <find_volume+0x3ac>)
     bb2:	2203      	movs	r2, #3
     bb4:	428b      	cmp	r3, r1
     bb6:	d133      	bne.n	c20 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
     bb8:	4b2a      	ldr	r3, [pc, #168]	; (c64 <find_volume+0x3b0>)
     bba:	5ceb      	ldrb	r3, [r5, r3]
     bbc:	061b      	lsls	r3, r3, #24
     bbe:	4a2a      	ldr	r2, [pc, #168]	; (c68 <find_volume+0x3b4>)
     bc0:	5caa      	ldrb	r2, [r5, r2]
     bc2:	0412      	lsls	r2, r2, #16
     bc4:	4313      	orrs	r3, r2
     bc6:	2285      	movs	r2, #133	; 0x85
     bc8:	0092      	lsls	r2, r2, #2
     bca:	5caa      	ldrb	r2, [r5, r2]
     bcc:	4313      	orrs	r3, r2
     bce:	4a27      	ldr	r2, [pc, #156]	; (c6c <find_volume+0x3b8>)
     bd0:	5caa      	ldrb	r2, [r5, r2]
     bd2:	0212      	lsls	r2, r2, #8
     bd4:	4313      	orrs	r3, r2
     bd6:	4926      	ldr	r1, [pc, #152]	; (c70 <find_volume+0x3bc>)
     bd8:	2203      	movs	r2, #3
     bda:	428b      	cmp	r3, r1
     bdc:	d120      	bne.n	c20 <find_volume+0x36c>
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
     bde:	4b25      	ldr	r3, [pc, #148]	; (c74 <find_volume+0x3c0>)
     be0:	5ceb      	ldrb	r3, [r5, r3]
     be2:	061b      	lsls	r3, r3, #24
     be4:	4a24      	ldr	r2, [pc, #144]	; (c78 <find_volume+0x3c4>)
     be6:	5caa      	ldrb	r2, [r5, r2]
     be8:	0412      	lsls	r2, r2, #16
     bea:	4313      	orrs	r3, r2
     bec:	2286      	movs	r2, #134	; 0x86
     bee:	0092      	lsls	r2, r2, #2
     bf0:	5caa      	ldrb	r2, [r5, r2]
     bf2:	4313      	orrs	r3, r2
     bf4:	4a21      	ldr	r2, [pc, #132]	; (c7c <find_volume+0x3c8>)
     bf6:	5caa      	ldrb	r2, [r5, r2]
     bf8:	0212      	lsls	r2, r2, #8
     bfa:	4313      	orrs	r3, r2
     bfc:	612b      	str	r3, [r5, #16]
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
     bfe:	4b20      	ldr	r3, [pc, #128]	; (c80 <find_volume+0x3cc>)
     c00:	5ceb      	ldrb	r3, [r5, r3]
     c02:	061b      	lsls	r3, r3, #24
     c04:	4a1f      	ldr	r2, [pc, #124]	; (c84 <find_volume+0x3d0>)
     c06:	5caa      	ldrb	r2, [r5, r2]
     c08:	0412      	lsls	r2, r2, #16
     c0a:	4313      	orrs	r3, r2
     c0c:	2287      	movs	r2, #135	; 0x87
     c0e:	0092      	lsls	r2, r2, #2
     c10:	5caa      	ldrb	r2, [r5, r2]
     c12:	4313      	orrs	r3, r2
     c14:	4a1c      	ldr	r2, [pc, #112]	; (c88 <find_volume+0x3d4>)
     c16:	5caa      	ldrb	r2, [r5, r2]
     c18:	0212      	lsls	r2, r2, #8
     c1a:	4313      	orrs	r3, r2
     c1c:	60eb      	str	r3, [r5, #12]
     c1e:	2203      	movs	r2, #3
	fs->fs_type = fmt;	/* FAT sub-type */
     c20:	702a      	strb	r2, [r5, #0]
	fs->id = ++Fsid;	/* File system mount ID */
     c22:	4a1a      	ldr	r2, [pc, #104]	; (c8c <find_volume+0x3d8>)
     c24:	8893      	ldrh	r3, [r2, #4]
     c26:	3301      	adds	r3, #1
     c28:	b29b      	uxth	r3, r3
     c2a:	8093      	strh	r3, [r2, #4]
     c2c:	80eb      	strh	r3, [r5, #6]
	return FR_OK;
     c2e:	2300      	movs	r3, #0
     c30:	e671      	b.n	916 <find_volume+0x62>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
     c32:	230c      	movs	r3, #12
     c34:	e66f      	b.n	916 <find_volume+0x62>
			return FR_OK;				/* The file system object is valid */
     c36:	2300      	movs	r3, #0
     c38:	e66d      	b.n	916 <find_volume+0x62>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
     c3a:	2301      	movs	r3, #1
     c3c:	e66b      	b.n	916 <find_volume+0x62>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
     c3e:	3002      	adds	r0, #2
     c40:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
     c42:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
     c44:	4643      	mov	r3, r8
     c46:	19db      	adds	r3, r3, r7
     c48:	622b      	str	r3, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
     c4a:	19f6      	adds	r6, r6, r7
     c4c:	62ae      	str	r6, [r5, #40]	; 0x28
     c4e:	e6fd      	b.n	a4c <find_volume+0x198>
     c50:	00000799 	.word	0x00000799
     c54:	0000022f 	.word	0x0000022f
     c58:	0000022e 	.word	0x0000022e
     c5c:	ffffaa55 	.word	0xffffaa55
     c60:	41615252 	.word	0x41615252
     c64:	00000217 	.word	0x00000217
     c68:	00000216 	.word	0x00000216
     c6c:	00000215 	.word	0x00000215
     c70:	61417272 	.word	0x61417272
     c74:	0000021b 	.word	0x0000021b
     c78:	0000021a 	.word	0x0000021a
     c7c:	00000219 	.word	0x00000219
     c80:	0000021f 	.word	0x0000021f
     c84:	0000021e 	.word	0x0000021e
     c88:	0000021d 	.word	0x0000021d
     c8c:	20000458 	.word	0x20000458

00000c90 <sync_fs>:
{
     c90:	b570      	push	{r4, r5, r6, lr}
     c92:	0004      	movs	r4, r0
	res = sync_window(fs);
     c94:	4b2d      	ldr	r3, [pc, #180]	; (d4c <sync_fs+0xbc>)
     c96:	4798      	blx	r3
	if (res == FR_OK) {
     c98:	2800      	cmp	r0, #0
     c9a:	d10a      	bne.n	cb2 <sync_fs+0x22>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
     c9c:	7823      	ldrb	r3, [r4, #0]
     c9e:	2b03      	cmp	r3, #3
     ca0:	d008      	beq.n	cb4 <sync_fs+0x24>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
     ca2:	7860      	ldrb	r0, [r4, #1]
     ca4:	2200      	movs	r2, #0
     ca6:	2100      	movs	r1, #0
     ca8:	4b29      	ldr	r3, [pc, #164]	; (d50 <sync_fs+0xc0>)
     caa:	4798      	blx	r3
     cac:	1e43      	subs	r3, r0, #1
     cae:	4198      	sbcs	r0, r3
	res = sync_window(fs);
     cb0:	b2c0      	uxtb	r0, r0
}
     cb2:	bd70      	pop	{r4, r5, r6, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
     cb4:	7963      	ldrb	r3, [r4, #5]
     cb6:	2b01      	cmp	r3, #1
     cb8:	d1f3      	bne.n	ca2 <sync_fs+0x12>
			mem_set(fs->win, 0, SS(fs));
     cba:	0021      	movs	r1, r4
     cbc:	3130      	adds	r1, #48	; 0x30
     cbe:	000b      	movs	r3, r1
     cc0:	228c      	movs	r2, #140	; 0x8c
     cc2:	0092      	lsls	r2, r2, #2
     cc4:	18a0      	adds	r0, r4, r2
		*d++ = (BYTE)val;
     cc6:	2200      	movs	r2, #0
     cc8:	701a      	strb	r2, [r3, #0]
     cca:	3301      	adds	r3, #1
	while (cnt--)
     ccc:	4283      	cmp	r3, r0
     cce:	d1fb      	bne.n	cc8 <sync_fs+0x38>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
     cd0:	2255      	movs	r2, #85	; 0x55
     cd2:	4b20      	ldr	r3, [pc, #128]	; (d54 <sync_fs+0xc4>)
     cd4:	54e2      	strb	r2, [r4, r3]
     cd6:	3255      	adds	r2, #85	; 0x55
     cd8:	4b1f      	ldr	r3, [pc, #124]	; (d58 <sync_fs+0xc8>)
     cda:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
     cdc:	3bde      	subs	r3, #222	; 0xde
     cde:	3bff      	subs	r3, #255	; 0xff
     ce0:	3a7a      	subs	r2, #122	; 0x7a
     ce2:	54a3      	strb	r3, [r4, r2]
     ce4:	3201      	adds	r2, #1
     ce6:	54a3      	strb	r3, [r4, r2]
     ce8:	330f      	adds	r3, #15
     cea:	3201      	adds	r2, #1
     cec:	54a3      	strb	r3, [r4, r2]
     cee:	320f      	adds	r2, #15
     cf0:	2033      	movs	r0, #51	; 0x33
     cf2:	5422      	strb	r2, [r4, r0]
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
     cf4:	303f      	adds	r0, #63	; 0x3f
     cf6:	2585      	movs	r5, #133	; 0x85
     cf8:	00ad      	lsls	r5, r5, #2
     cfa:	5560      	strb	r0, [r4, r5]
     cfc:	4d17      	ldr	r5, [pc, #92]	; (d5c <sync_fs+0xcc>)
     cfe:	5560      	strb	r0, [r4, r5]
     d00:	4817      	ldr	r0, [pc, #92]	; (d60 <sync_fs+0xd0>)
     d02:	5422      	strb	r2, [r4, r0]
     d04:	4a17      	ldr	r2, [pc, #92]	; (d64 <sync_fs+0xd4>)
     d06:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
     d08:	6923      	ldr	r3, [r4, #16]
     d0a:	3201      	adds	r2, #1
     d0c:	54a3      	strb	r3, [r4, r2]
     d0e:	0a18      	lsrs	r0, r3, #8
     d10:	4a15      	ldr	r2, [pc, #84]	; (d68 <sync_fs+0xd8>)
     d12:	54a0      	strb	r0, [r4, r2]
     d14:	0c18      	lsrs	r0, r3, #16
     d16:	4a15      	ldr	r2, [pc, #84]	; (d6c <sync_fs+0xdc>)
     d18:	54a0      	strb	r0, [r4, r2]
     d1a:	0e1b      	lsrs	r3, r3, #24
     d1c:	4a14      	ldr	r2, [pc, #80]	; (d70 <sync_fs+0xe0>)
     d1e:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
     d20:	68e3      	ldr	r3, [r4, #12]
     d22:	3201      	adds	r2, #1
     d24:	54a3      	strb	r3, [r4, r2]
     d26:	0a18      	lsrs	r0, r3, #8
     d28:	4a12      	ldr	r2, [pc, #72]	; (d74 <sync_fs+0xe4>)
     d2a:	54a0      	strb	r0, [r4, r2]
     d2c:	0c18      	lsrs	r0, r3, #16
     d2e:	4a12      	ldr	r2, [pc, #72]	; (d78 <sync_fs+0xe8>)
     d30:	54a0      	strb	r0, [r4, r2]
     d32:	0e1b      	lsrs	r3, r3, #24
     d34:	4a11      	ldr	r2, [pc, #68]	; (d7c <sync_fs+0xec>)
     d36:	54a3      	strb	r3, [r4, r2]
			fs->winsect = fs->volbase + 1;
     d38:	69e3      	ldr	r3, [r4, #28]
     d3a:	1c5a      	adds	r2, r3, #1
     d3c:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
     d3e:	7860      	ldrb	r0, [r4, #1]
     d40:	2301      	movs	r3, #1
     d42:	4d0f      	ldr	r5, [pc, #60]	; (d80 <sync_fs+0xf0>)
     d44:	47a8      	blx	r5
			fs->fsi_flag = 0;
     d46:	2300      	movs	r3, #0
     d48:	7163      	strb	r3, [r4, #5]
     d4a:	e7aa      	b.n	ca2 <sync_fs+0x12>
     d4c:	0000072d 	.word	0x0000072d
     d50:	0000059d 	.word	0x0000059d
     d54:	0000022e 	.word	0x0000022e
     d58:	0000022f 	.word	0x0000022f
     d5c:	00000215 	.word	0x00000215
     d60:	00000216 	.word	0x00000216
     d64:	00000217 	.word	0x00000217
     d68:	00000219 	.word	0x00000219
     d6c:	0000021a 	.word	0x0000021a
     d70:	0000021b 	.word	0x0000021b
     d74:	0000021d 	.word	0x0000021d
     d78:	0000021e 	.word	0x0000021e
     d7c:	0000021f 	.word	0x0000021f
     d80:	00000545 	.word	0x00000545

00000d84 <clust2sect>:
{
     d84:	0002      	movs	r2, r0
	clst -= 2;
     d86:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
     d88:	6943      	ldr	r3, [r0, #20]
     d8a:	3b02      	subs	r3, #2
     d8c:	2000      	movs	r0, #0
     d8e:	4299      	cmp	r1, r3
     d90:	d203      	bcs.n	d9a <clust2sect+0x16>
	return clst * fs->csize + fs->database;
     d92:	7890      	ldrb	r0, [r2, #2]
     d94:	4341      	muls	r1, r0
     d96:	6a90      	ldr	r0, [r2, #40]	; 0x28
     d98:	1808      	adds	r0, r1, r0
}
     d9a:	4770      	bx	lr

00000d9c <get_fat>:
{
     d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d9e:	0005      	movs	r5, r0
     da0:	000c      	movs	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     da2:	2901      	cmp	r1, #1
     da4:	d972      	bls.n	e8c <get_fat+0xf0>
		val = 1;	/* Internal error */
     da6:	2001      	movs	r0, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     da8:	696b      	ldr	r3, [r5, #20]
     daa:	4299      	cmp	r1, r3
     dac:	d26f      	bcs.n	e8e <get_fat+0xf2>
		switch (fs->fs_type) {
     dae:	782b      	ldrb	r3, [r5, #0]
     db0:	2b02      	cmp	r3, #2
     db2:	d032      	beq.n	e1a <get_fat+0x7e>
     db4:	2b03      	cmp	r3, #3
     db6:	d047      	beq.n	e48 <get_fat+0xac>
			val = 1;	/* Internal error */
     db8:	2001      	movs	r0, #1
		switch (fs->fs_type) {
     dba:	2b01      	cmp	r3, #1
     dbc:	d167      	bne.n	e8e <get_fat+0xf2>
			bc = (UINT)clst; bc += bc / 2;
     dbe:	084e      	lsrs	r6, r1, #1
     dc0:	1876      	adds	r6, r6, r1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
     dc2:	0a71      	lsrs	r1, r6, #9
     dc4:	6a2b      	ldr	r3, [r5, #32]
     dc6:	469c      	mov	ip, r3
     dc8:	4461      	add	r1, ip
     dca:	0028      	movs	r0, r5
     dcc:	4b30      	ldr	r3, [pc, #192]	; (e90 <get_fat+0xf4>)
     dce:	4798      	blx	r3
     dd0:	2800      	cmp	r0, #0
     dd2:	d002      	beq.n	dda <get_fat+0x3e>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     dd4:	2001      	movs	r0, #1
     dd6:	4240      	negs	r0, r0
     dd8:	e059      	b.n	e8e <get_fat+0xf2>
			wc = fs->win[bc++ % SS(fs)];
     dda:	1c77      	adds	r7, r6, #1
     ddc:	05f3      	lsls	r3, r6, #23
     dde:	0ddb      	lsrs	r3, r3, #23
     de0:	18eb      	adds	r3, r5, r3
     de2:	3330      	adds	r3, #48	; 0x30
     de4:	781e      	ldrb	r6, [r3, #0]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
     de6:	0a79      	lsrs	r1, r7, #9
     de8:	6a2b      	ldr	r3, [r5, #32]
     dea:	469c      	mov	ip, r3
     dec:	4461      	add	r1, ip
     dee:	0028      	movs	r0, r5
     df0:	4b27      	ldr	r3, [pc, #156]	; (e90 <get_fat+0xf4>)
     df2:	4798      	blx	r3
     df4:	2800      	cmp	r0, #0
     df6:	d002      	beq.n	dfe <get_fat+0x62>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     df8:	2001      	movs	r0, #1
     dfa:	4240      	negs	r0, r0
     dfc:	e047      	b.n	e8e <get_fat+0xf2>
			wc |= fs->win[bc % SS(fs)] << 8;
     dfe:	05ff      	lsls	r7, r7, #23
     e00:	0dff      	lsrs	r7, r7, #23
     e02:	19ed      	adds	r5, r5, r7
     e04:	3530      	adds	r5, #48	; 0x30
     e06:	7828      	ldrb	r0, [r5, #0]
     e08:	0200      	lsls	r0, r0, #8
     e0a:	4330      	orrs	r0, r6
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
     e0c:	07e3      	lsls	r3, r4, #31
     e0e:	d501      	bpl.n	e14 <get_fat+0x78>
     e10:	0900      	lsrs	r0, r0, #4
     e12:	e03c      	b.n	e8e <get_fat+0xf2>
     e14:	0500      	lsls	r0, r0, #20
     e16:	0d00      	lsrs	r0, r0, #20
     e18:	e039      	b.n	e8e <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
     e1a:	0a09      	lsrs	r1, r1, #8
     e1c:	6a2b      	ldr	r3, [r5, #32]
     e1e:	469c      	mov	ip, r3
     e20:	4461      	add	r1, ip
     e22:	0028      	movs	r0, r5
     e24:	4b1a      	ldr	r3, [pc, #104]	; (e90 <get_fat+0xf4>)
     e26:	4798      	blx	r3
     e28:	2800      	cmp	r0, #0
     e2a:	d002      	beq.n	e32 <get_fat+0x96>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     e2c:	2001      	movs	r0, #1
     e2e:	4240      	negs	r0, r0
     e30:	e02d      	b.n	e8e <get_fat+0xf2>
			p = &fs->win[clst * 2 % SS(fs)];
     e32:	0064      	lsls	r4, r4, #1
     e34:	23ff      	movs	r3, #255	; 0xff
     e36:	005b      	lsls	r3, r3, #1
     e38:	401c      	ands	r4, r3
			val = LD_WORD(p);
     e3a:	192d      	adds	r5, r5, r4
     e3c:	3530      	adds	r5, #48	; 0x30
     e3e:	786b      	ldrb	r3, [r5, #1]
     e40:	021b      	lsls	r3, r3, #8
     e42:	7828      	ldrb	r0, [r5, #0]
     e44:	4318      	orrs	r0, r3
			break;
     e46:	e022      	b.n	e8e <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
     e48:	09c9      	lsrs	r1, r1, #7
     e4a:	6a2b      	ldr	r3, [r5, #32]
     e4c:	469c      	mov	ip, r3
     e4e:	4461      	add	r1, ip
     e50:	0028      	movs	r0, r5
     e52:	4b0f      	ldr	r3, [pc, #60]	; (e90 <get_fat+0xf4>)
     e54:	4798      	blx	r3
     e56:	2800      	cmp	r0, #0
     e58:	d002      	beq.n	e60 <get_fat+0xc4>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     e5a:	2001      	movs	r0, #1
     e5c:	4240      	negs	r0, r0
	return val;
     e5e:	e016      	b.n	e8e <get_fat+0xf2>
			p = &fs->win[clst * 4 % SS(fs)];
     e60:	00a4      	lsls	r4, r4, #2
     e62:	23fe      	movs	r3, #254	; 0xfe
     e64:	005b      	lsls	r3, r3, #1
     e66:	401c      	ands	r4, r3
     e68:	0023      	movs	r3, r4
     e6a:	3330      	adds	r3, #48	; 0x30
     e6c:	18eb      	adds	r3, r5, r3
			val = LD_DWORD(p) & 0x0FFFFFFF;
     e6e:	78d8      	ldrb	r0, [r3, #3]
     e70:	0600      	lsls	r0, r0, #24
     e72:	789a      	ldrb	r2, [r3, #2]
     e74:	0412      	lsls	r2, r2, #16
     e76:	4310      	orrs	r0, r2
     e78:	192c      	adds	r4, r5, r4
     e7a:	3430      	adds	r4, #48	; 0x30
     e7c:	7822      	ldrb	r2, [r4, #0]
     e7e:	4310      	orrs	r0, r2
     e80:	785b      	ldrb	r3, [r3, #1]
     e82:	021b      	lsls	r3, r3, #8
     e84:	4318      	orrs	r0, r3
     e86:	0100      	lsls	r0, r0, #4
     e88:	0900      	lsrs	r0, r0, #4
			break;
     e8a:	e000      	b.n	e8e <get_fat+0xf2>
		val = 1;	/* Internal error */
     e8c:	2001      	movs	r0, #1
}
     e8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     e90:	00000799 	.word	0x00000799

00000e94 <dir_sdi>:
{
     e94:	b5f0      	push	{r4, r5, r6, r7, lr}
     e96:	46c6      	mov	lr, r8
     e98:	b500      	push	{lr}
     e9a:	0005      	movs	r5, r0
     e9c:	000e      	movs	r6, r1
	dp->index = (WORD)idx;	/* Current index */
     e9e:	80e9      	strh	r1, [r5, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
     ea0:	6884      	ldr	r4, [r0, #8]
		return FR_INT_ERR;
     ea2:	2002      	movs	r0, #2
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
     ea4:	2c01      	cmp	r4, #1
     ea6:	d003      	beq.n	eb0 <dir_sdi+0x1c>
     ea8:	682b      	ldr	r3, [r5, #0]
     eaa:	695a      	ldr	r2, [r3, #20]
     eac:	4294      	cmp	r4, r2
     eae:	d302      	bcc.n	eb6 <dir_sdi+0x22>
}
     eb0:	bc04      	pop	{r2}
     eb2:	4690      	mov	r8, r2
     eb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
     eb6:	2c00      	cmp	r4, #0
     eb8:	d11b      	bne.n	ef2 <dir_sdi+0x5e>
     eba:	781a      	ldrb	r2, [r3, #0]
     ebc:	2a03      	cmp	r2, #3
     ebe:	d014      	beq.n	eea <dir_sdi+0x56>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
     ec0:	891a      	ldrh	r2, [r3, #8]
			return FR_INT_ERR;
     ec2:	2002      	movs	r0, #2
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
     ec4:	4296      	cmp	r6, r2
     ec6:	d2f3      	bcs.n	eb0 <dir_sdi+0x1c>
		sect = dp->fs->dirbase;
     ec8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	dp->clust = clst;	/* Current cluster# */
     eca:	60ec      	str	r4, [r5, #12]
	if (!sect) return FR_INT_ERR;
     ecc:	2002      	movs	r0, #2
     ece:	2b00      	cmp	r3, #0
     ed0:	d0ee      	beq.n	eb0 <dir_sdi+0x1c>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
     ed2:	0930      	lsrs	r0, r6, #4
     ed4:	18c3      	adds	r3, r0, r3
     ed6:	612b      	str	r3, [r5, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
     ed8:	682b      	ldr	r3, [r5, #0]
     eda:	3330      	adds	r3, #48	; 0x30
     edc:	220f      	movs	r2, #15
     ede:	4016      	ands	r6, r2
     ee0:	0176      	lsls	r6, r6, #5
     ee2:	199e      	adds	r6, r3, r6
     ee4:	616e      	str	r6, [r5, #20]
	return FR_OK;
     ee6:	2000      	movs	r0, #0
     ee8:	e7e2      	b.n	eb0 <dir_sdi+0x1c>
		clst = dp->fs->dirbase;
     eea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
     eec:	2a00      	cmp	r2, #0
     eee:	d0e7      	beq.n	ec0 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
     ef0:	0014      	movs	r4, r2
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
     ef2:	789f      	ldrb	r7, [r3, #2]
     ef4:	013f      	lsls	r7, r7, #4
		while (idx >= ic) {	/* Follow cluster chain */
     ef6:	42be      	cmp	r6, r7
     ef8:	d313      	bcc.n	f22 <dir_sdi+0x8e>
     efa:	1bf6      	subs	r6, r6, r7
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
     efc:	4b0f      	ldr	r3, [pc, #60]	; (f3c <dir_sdi+0xa8>)
     efe:	4698      	mov	r8, r3
     f00:	e000      	b.n	f04 <dir_sdi+0x70>
     f02:	001e      	movs	r6, r3
     f04:	0021      	movs	r1, r4
     f06:	6828      	ldr	r0, [r5, #0]
     f08:	47c0      	blx	r8
     f0a:	0004      	movs	r4, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
     f0c:	1c43      	adds	r3, r0, #1
     f0e:	d00e      	beq.n	f2e <dir_sdi+0x9a>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
     f10:	2801      	cmp	r0, #1
     f12:	d90e      	bls.n	f32 <dir_sdi+0x9e>
     f14:	682b      	ldr	r3, [r5, #0]
     f16:	695b      	ldr	r3, [r3, #20]
     f18:	4298      	cmp	r0, r3
     f1a:	d20c      	bcs.n	f36 <dir_sdi+0xa2>
     f1c:	1bf3      	subs	r3, r6, r7
		while (idx >= ic) {	/* Follow cluster chain */
     f1e:	42be      	cmp	r6, r7
     f20:	d2ef      	bcs.n	f02 <dir_sdi+0x6e>
		sect = clust2sect(dp->fs, clst);
     f22:	0021      	movs	r1, r4
     f24:	6828      	ldr	r0, [r5, #0]
     f26:	4b06      	ldr	r3, [pc, #24]	; (f40 <dir_sdi+0xac>)
     f28:	4798      	blx	r3
     f2a:	0003      	movs	r3, r0
     f2c:	e7cd      	b.n	eca <dir_sdi+0x36>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
     f2e:	2001      	movs	r0, #1
     f30:	e7be      	b.n	eb0 <dir_sdi+0x1c>
				return FR_INT_ERR;
     f32:	2002      	movs	r0, #2
     f34:	e7bc      	b.n	eb0 <dir_sdi+0x1c>
     f36:	2002      	movs	r0, #2
     f38:	e7ba      	b.n	eb0 <dir_sdi+0x1c>
     f3a:	46c0      	nop			; (mov r8, r8)
     f3c:	00000d9d 	.word	0x00000d9d
     f40:	00000d85 	.word	0x00000d85

00000f44 <put_fat>:
{
     f44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     f46:	46ce      	mov	lr, r9
     f48:	4647      	mov	r7, r8
     f4a:	b580      	push	{r7, lr}
     f4c:	0007      	movs	r7, r0
     f4e:	000c      	movs	r4, r1
     f50:	0016      	movs	r6, r2
		res = FR_INT_ERR;
     f52:	2502      	movs	r5, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     f54:	2901      	cmp	r1, #1
     f56:	d902      	bls.n	f5e <put_fat+0x1a>
     f58:	6943      	ldr	r3, [r0, #20]
     f5a:	4299      	cmp	r1, r3
     f5c:	d304      	bcc.n	f68 <put_fat+0x24>
}
     f5e:	0028      	movs	r0, r5
     f60:	bc0c      	pop	{r2, r3}
     f62:	4690      	mov	r8, r2
     f64:	4699      	mov	r9, r3
     f66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (fs->fs_type) {
     f68:	7803      	ldrb	r3, [r0, #0]
     f6a:	2b02      	cmp	r3, #2
     f6c:	d055      	beq.n	101a <put_fat+0xd6>
     f6e:	2b03      	cmp	r3, #3
     f70:	d067      	beq.n	1042 <put_fat+0xfe>
			res = FR_INT_ERR;
     f72:	2502      	movs	r5, #2
		switch (fs->fs_type) {
     f74:	2b01      	cmp	r3, #1
     f76:	d1f2      	bne.n	f5e <put_fat+0x1a>
			bc = (UINT)clst; bc += bc / 2;
     f78:	084b      	lsrs	r3, r1, #1
     f7a:	4698      	mov	r8, r3
     f7c:	4488      	add	r8, r1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
     f7e:	4643      	mov	r3, r8
     f80:	0a59      	lsrs	r1, r3, #9
     f82:	6a03      	ldr	r3, [r0, #32]
     f84:	469c      	mov	ip, r3
     f86:	4461      	add	r1, ip
     f88:	4b40      	ldr	r3, [pc, #256]	; (108c <put_fat+0x148>)
     f8a:	4798      	blx	r3
     f8c:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
     f8e:	d1e6      	bne.n	f5e <put_fat+0x1a>
			p = &fs->win[bc++ % SS(fs)];
     f90:	2301      	movs	r3, #1
     f92:	4443      	add	r3, r8
     f94:	4699      	mov	r9, r3
     f96:	4643      	mov	r3, r8
     f98:	05db      	lsls	r3, r3, #23
     f9a:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     f9c:	07e2      	lsls	r2, r4, #31
     f9e:	d521      	bpl.n	fe4 <put_fat+0xa0>
     fa0:	18fb      	adds	r3, r7, r3
     fa2:	3330      	adds	r3, #48	; 0x30
     fa4:	7819      	ldrb	r1, [r3, #0]
     fa6:	220f      	movs	r2, #15
     fa8:	400a      	ands	r2, r1
     faa:	0131      	lsls	r1, r6, #4
     fac:	20ff      	movs	r0, #255	; 0xff
     fae:	0100      	lsls	r0, r0, #4
     fb0:	4001      	ands	r1, r0
     fb2:	430a      	orrs	r2, r1
     fb4:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
     fb6:	2301      	movs	r3, #1
     fb8:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
     fba:	464b      	mov	r3, r9
     fbc:	0a59      	lsrs	r1, r3, #9
     fbe:	6a3b      	ldr	r3, [r7, #32]
     fc0:	469c      	mov	ip, r3
     fc2:	4461      	add	r1, ip
     fc4:	0038      	movs	r0, r7
     fc6:	4b31      	ldr	r3, [pc, #196]	; (108c <put_fat+0x148>)
     fc8:	4798      	blx	r3
			if (res != FR_OK) break;
     fca:	2800      	cmp	r0, #0
     fcc:	d159      	bne.n	1082 <put_fat+0x13e>
			p = &fs->win[bc % SS(fs)];
     fce:	464b      	mov	r3, r9
     fd0:	05db      	lsls	r3, r3, #23
     fd2:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
     fd4:	0936      	lsrs	r6, r6, #4
     fd6:	b2f6      	uxtb	r6, r6
     fd8:	18fb      	adds	r3, r7, r3
     fda:	3330      	adds	r3, #48	; 0x30
     fdc:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
     fde:	2301      	movs	r3, #1
     fe0:	713b      	strb	r3, [r7, #4]
			break;
     fe2:	e7bc      	b.n	f5e <put_fat+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     fe4:	18fb      	adds	r3, r7, r3
     fe6:	3330      	adds	r3, #48	; 0x30
     fe8:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
     fea:	2301      	movs	r3, #1
     fec:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
     fee:	464b      	mov	r3, r9
     ff0:	0a59      	lsrs	r1, r3, #9
     ff2:	6a3b      	ldr	r3, [r7, #32]
     ff4:	469c      	mov	ip, r3
     ff6:	4461      	add	r1, ip
     ff8:	0038      	movs	r0, r7
     ffa:	4b24      	ldr	r3, [pc, #144]	; (108c <put_fat+0x148>)
     ffc:	4798      	blx	r3
			if (res != FR_OK) break;
     ffe:	2800      	cmp	r0, #0
    1000:	d141      	bne.n	1086 <put_fat+0x142>
			p = &fs->win[bc % SS(fs)];
    1002:	464b      	mov	r3, r9
    1004:	05db      	lsls	r3, r3, #23
    1006:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    1008:	18fa      	adds	r2, r7, r3
    100a:	3230      	adds	r2, #48	; 0x30
    100c:	7812      	ldrb	r2, [r2, #0]
    100e:	210f      	movs	r1, #15
    1010:	438a      	bics	r2, r1
    1012:	0536      	lsls	r6, r6, #20
    1014:	0f36      	lsrs	r6, r6, #28
    1016:	4316      	orrs	r6, r2
    1018:	e7de      	b.n	fd8 <put_fat+0x94>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    101a:	0a09      	lsrs	r1, r1, #8
    101c:	6a03      	ldr	r3, [r0, #32]
    101e:	469c      	mov	ip, r3
    1020:	4461      	add	r1, ip
    1022:	4b1a      	ldr	r3, [pc, #104]	; (108c <put_fat+0x148>)
    1024:	4798      	blx	r3
    1026:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    1028:	d199      	bne.n	f5e <put_fat+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
    102a:	0063      	lsls	r3, r4, #1
    102c:	24ff      	movs	r4, #255	; 0xff
    102e:	0064      	lsls	r4, r4, #1
    1030:	4023      	ands	r3, r4
			ST_WORD(p, (WORD)val);
    1032:	18fb      	adds	r3, r7, r3
    1034:	3330      	adds	r3, #48	; 0x30
    1036:	701e      	strb	r6, [r3, #0]
    1038:	0a36      	lsrs	r6, r6, #8
    103a:	705e      	strb	r6, [r3, #1]
			fs->wflag = 1;
    103c:	2301      	movs	r3, #1
    103e:	713b      	strb	r3, [r7, #4]
			break;
    1040:	e78d      	b.n	f5e <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    1042:	09c9      	lsrs	r1, r1, #7
    1044:	6a03      	ldr	r3, [r0, #32]
    1046:	469c      	mov	ip, r3
    1048:	4461      	add	r1, ip
    104a:	4b10      	ldr	r3, [pc, #64]	; (108c <put_fat+0x148>)
    104c:	4798      	blx	r3
    104e:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    1050:	d000      	beq.n	1054 <put_fat+0x110>
    1052:	e784      	b.n	f5e <put_fat+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
    1054:	00a4      	lsls	r4, r4, #2
    1056:	23fe      	movs	r3, #254	; 0xfe
    1058:	005b      	lsls	r3, r3, #1
    105a:	401c      	ands	r4, r3
    105c:	0022      	movs	r2, r4
    105e:	3230      	adds	r2, #48	; 0x30
    1060:	18ba      	adds	r2, r7, r2
			val |= LD_DWORD(p) & 0xF0000000;
    1062:	78d3      	ldrb	r3, [r2, #3]
    1064:	193c      	adds	r4, r7, r4
    1066:	3430      	adds	r4, #48	; 0x30
    1068:	091b      	lsrs	r3, r3, #4
    106a:	071b      	lsls	r3, r3, #28
    106c:	431e      	orrs	r6, r3
			ST_DWORD(p, val);
    106e:	7026      	strb	r6, [r4, #0]
    1070:	0a33      	lsrs	r3, r6, #8
    1072:	7053      	strb	r3, [r2, #1]
    1074:	0c33      	lsrs	r3, r6, #16
    1076:	7093      	strb	r3, [r2, #2]
    1078:	0e36      	lsrs	r6, r6, #24
    107a:	70d6      	strb	r6, [r2, #3]
			fs->wflag = 1;
    107c:	2301      	movs	r3, #1
    107e:	713b      	strb	r3, [r7, #4]
			break;
    1080:	e76d      	b.n	f5e <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    1082:	0005      	movs	r5, r0
    1084:	e76b      	b.n	f5e <put_fat+0x1a>
    1086:	0005      	movs	r5, r0
	return res;
    1088:	e769      	b.n	f5e <put_fat+0x1a>
    108a:	46c0      	nop			; (mov r8, r8)
    108c:	00000799 	.word	0x00000799

00001090 <create_chain>:
{
    1090:	b5f0      	push	{r4, r5, r6, r7, lr}
    1092:	46c6      	mov	lr, r8
    1094:	b500      	push	{lr}
    1096:	0005      	movs	r5, r0
    1098:	4688      	mov	r8, r1
	if (clst == 0) {		/* Create a new chain */
    109a:	2900      	cmp	r1, #0
    109c:	d107      	bne.n	10ae <create_chain+0x1e>
		scl = fs->last_clust;			/* Get suggested start point */
    109e:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
    10a0:	2e00      	cmp	r6, #0
    10a2:	d00f      	beq.n	10c4 <create_chain+0x34>
    10a4:	6943      	ldr	r3, [r0, #20]
    10a6:	429e      	cmp	r6, r3
    10a8:	d30d      	bcc.n	10c6 <create_chain+0x36>
    10aa:	2601      	movs	r6, #1
    10ac:	e00b      	b.n	10c6 <create_chain+0x36>
		cs = get_fat(fs, clst);			/* Check the cluster status */
    10ae:	4b28      	ldr	r3, [pc, #160]	; (1150 <create_chain+0xc0>)
    10b0:	4798      	blx	r3
		if (cs < 2) return 1;			/* Invalid value */
    10b2:	2801      	cmp	r0, #1
    10b4:	d941      	bls.n	113a <create_chain+0xaa>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
    10b6:	1c43      	adds	r3, r0, #1
    10b8:	d044      	beq.n	1144 <create_chain+0xb4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    10ba:	696b      	ldr	r3, [r5, #20]
		scl = clst;
    10bc:	4646      	mov	r6, r8
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    10be:	4298      	cmp	r0, r3
    10c0:	d201      	bcs.n	10c6 <create_chain+0x36>
    10c2:	e03f      	b.n	1144 <create_chain+0xb4>
		if (!scl || scl >= fs->n_fatent) scl = 1;
    10c4:	2601      	movs	r6, #1
	ncl = scl;				/* Start cluster */
    10c6:	0034      	movs	r4, r6
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    10c8:	4f21      	ldr	r7, [pc, #132]	; (1150 <create_chain+0xc0>)
    10ca:	e00a      	b.n	10e2 <create_chain+0x52>
    10cc:	0021      	movs	r1, r4
    10ce:	0028      	movs	r0, r5
    10d0:	47b8      	blx	r7
		if (cs == 0) break;				/* Found a free cluster */
    10d2:	2800      	cmp	r0, #0
    10d4:	d00d      	beq.n	10f2 <create_chain+0x62>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    10d6:	1c43      	adds	r3, r0, #1
    10d8:	d034      	beq.n	1144 <create_chain+0xb4>
    10da:	2801      	cmp	r0, #1
    10dc:	d032      	beq.n	1144 <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    10de:	42b4      	cmp	r4, r6
    10e0:	d02f      	beq.n	1142 <create_chain+0xb2>
		ncl++;							/* Next cluster */
    10e2:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
    10e4:	696b      	ldr	r3, [r5, #20]
    10e6:	429c      	cmp	r4, r3
    10e8:	d3f0      	bcc.n	10cc <create_chain+0x3c>
			if (ncl > scl) return 0;	/* No free cluster */
    10ea:	2e01      	cmp	r6, #1
    10ec:	d927      	bls.n	113e <create_chain+0xae>
			ncl = 2;
    10ee:	2402      	movs	r4, #2
    10f0:	e7ec      	b.n	10cc <create_chain+0x3c>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    10f2:	4a18      	ldr	r2, [pc, #96]	; (1154 <create_chain+0xc4>)
    10f4:	0021      	movs	r1, r4
    10f6:	0028      	movs	r0, r5
    10f8:	4b17      	ldr	r3, [pc, #92]	; (1158 <create_chain+0xc8>)
    10fa:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
    10fc:	2800      	cmp	r0, #0
    10fe:	d115      	bne.n	112c <create_chain+0x9c>
    1100:	4643      	mov	r3, r8
    1102:	2b00      	cmp	r3, #0
    1104:	d10b      	bne.n	111e <create_chain+0x8e>
		fs->last_clust = ncl;			/* Update FSINFO */
    1106:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
    1108:	692b      	ldr	r3, [r5, #16]
    110a:	1c5a      	adds	r2, r3, #1
    110c:	d01d      	beq.n	114a <create_chain+0xba>
			fs->free_clust--;
    110e:	3b01      	subs	r3, #1
    1110:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
    1112:	796b      	ldrb	r3, [r5, #5]
    1114:	2201      	movs	r2, #1
    1116:	4313      	orrs	r3, r2
    1118:	716b      	strb	r3, [r5, #5]
    111a:	0020      	movs	r0, r4
    111c:	e012      	b.n	1144 <create_chain+0xb4>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    111e:	0022      	movs	r2, r4
    1120:	4641      	mov	r1, r8
    1122:	0028      	movs	r0, r5
    1124:	4b0c      	ldr	r3, [pc, #48]	; (1158 <create_chain+0xc8>)
    1126:	4798      	blx	r3
	if (res == FR_OK) {
    1128:	2800      	cmp	r0, #0
    112a:	d0ec      	beq.n	1106 <create_chain+0x76>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    112c:	3801      	subs	r0, #1
    112e:	4242      	negs	r2, r0
    1130:	4142      	adcs	r2, r0
    1132:	4250      	negs	r0, r2
    1134:	2301      	movs	r3, #1
    1136:	4318      	orrs	r0, r3
    1138:	e004      	b.n	1144 <create_chain+0xb4>
		if (cs < 2) return 1;			/* Invalid value */
    113a:	2001      	movs	r0, #1
    113c:	e002      	b.n	1144 <create_chain+0xb4>
			if (ncl > scl) return 0;	/* No free cluster */
    113e:	2000      	movs	r0, #0
    1140:	e000      	b.n	1144 <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    1142:	2000      	movs	r0, #0
}
    1144:	bc04      	pop	{r2}
    1146:	4690      	mov	r8, r2
    1148:	bdf0      	pop	{r4, r5, r6, r7, pc}
    114a:	0020      	movs	r0, r4
    114c:	e7fa      	b.n	1144 <create_chain+0xb4>
    114e:	46c0      	nop			; (mov r8, r8)
    1150:	00000d9d 	.word	0x00000d9d
    1154:	0fffffff 	.word	0x0fffffff
    1158:	00000f45 	.word	0x00000f45

0000115c <dir_next>:
{
    115c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    115e:	46ce      	mov	lr, r9
    1160:	4647      	mov	r7, r8
    1162:	b580      	push	{r7, lr}
    1164:	0006      	movs	r6, r0
    1166:	000d      	movs	r5, r1
	i = dp->index + 1;
    1168:	88c4      	ldrh	r4, [r0, #6]
    116a:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    116c:	0423      	lsls	r3, r4, #16
		return FR_NO_FILE;
    116e:	2004      	movs	r0, #4
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    1170:	2b00      	cmp	r3, #0
    1172:	d103      	bne.n	117c <dir_next+0x20>
}
    1174:	bc0c      	pop	{r2, r3}
    1176:	4690      	mov	r8, r2
    1178:	4699      	mov	r9, r3
    117a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    117c:	6933      	ldr	r3, [r6, #16]
    117e:	2b00      	cmp	r3, #0
    1180:	d0f8      	beq.n	1174 <dir_next+0x18>
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
    1182:	270f      	movs	r7, #15
    1184:	4027      	ands	r7, r4
    1186:	d110      	bne.n	11aa <dir_next+0x4e>
		dp->sect++;					/* Next sector */
    1188:	3301      	adds	r3, #1
    118a:	6133      	str	r3, [r6, #16]
		if (!dp->clust) {		/* Static table */
    118c:	68f1      	ldr	r1, [r6, #12]
    118e:	2900      	cmp	r1, #0
    1190:	d104      	bne.n	119c <dir_next+0x40>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
    1192:	6833      	ldr	r3, [r6, #0]
    1194:	891b      	ldrh	r3, [r3, #8]
    1196:	429c      	cmp	r4, r3
    1198:	d2ec      	bcs.n	1174 <dir_next+0x18>
    119a:	e006      	b.n	11aa <dir_next+0x4e>
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
    119c:	6830      	ldr	r0, [r6, #0]
    119e:	7883      	ldrb	r3, [r0, #2]
    11a0:	3b01      	subs	r3, #1
    11a2:	0922      	lsrs	r2, r4, #4
    11a4:	401a      	ands	r2, r3
    11a6:	4690      	mov	r8, r2
    11a8:	d007      	beq.n	11ba <dir_next+0x5e>
	dp->index = (WORD)i;	/* Current index */
    11aa:	80f4      	strh	r4, [r6, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
    11ac:	6833      	ldr	r3, [r6, #0]
    11ae:	3330      	adds	r3, #48	; 0x30
    11b0:	017f      	lsls	r7, r7, #5
    11b2:	19df      	adds	r7, r3, r7
    11b4:	6177      	str	r7, [r6, #20]
	return FR_OK;
    11b6:	2000      	movs	r0, #0
    11b8:	e7dc      	b.n	1174 <dir_next+0x18>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
    11ba:	4b2d      	ldr	r3, [pc, #180]	; (1270 <dir_next+0x114>)
    11bc:	4798      	blx	r3
    11be:	4681      	mov	r9, r0
				if (clst <= 1) return FR_INT_ERR;
    11c0:	2002      	movs	r0, #2
    11c2:	464b      	mov	r3, r9
    11c4:	2b01      	cmp	r3, #1
    11c6:	d9d5      	bls.n	1174 <dir_next+0x18>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    11c8:	3301      	adds	r3, #1
    11ca:	d04d      	beq.n	1268 <dir_next+0x10c>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
    11cc:	6833      	ldr	r3, [r6, #0]
    11ce:	695a      	ldr	r2, [r3, #20]
    11d0:	4591      	cmp	r9, r2
    11d2:	d341      	bcc.n	1258 <dir_next+0xfc>
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
    11d4:	3002      	adds	r0, #2
    11d6:	2d00      	cmp	r5, #0
    11d8:	d0cc      	beq.n	1174 <dir_next+0x18>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
    11da:	68f1      	ldr	r1, [r6, #12]
    11dc:	0018      	movs	r0, r3
    11de:	4b25      	ldr	r3, [pc, #148]	; (1274 <dir_next+0x118>)
    11e0:	4798      	blx	r3
    11e2:	4681      	mov	r9, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    11e4:	2007      	movs	r0, #7
    11e6:	464b      	mov	r3, r9
    11e8:	2b00      	cmp	r3, #0
    11ea:	d0c3      	beq.n	1174 <dir_next+0x18>
					if (clst == 1) return FR_INT_ERR;
    11ec:	3805      	subs	r0, #5
    11ee:	2b01      	cmp	r3, #1
    11f0:	d0c0      	beq.n	1174 <dir_next+0x18>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    11f2:	3801      	subs	r0, #1
    11f4:	3301      	adds	r3, #1
    11f6:	d0bd      	beq.n	1174 <dir_next+0x18>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
    11f8:	6830      	ldr	r0, [r6, #0]
    11fa:	4b1f      	ldr	r3, [pc, #124]	; (1278 <dir_next+0x11c>)
    11fc:	4798      	blx	r3
    11fe:	0003      	movs	r3, r0
    1200:	2001      	movs	r0, #1
    1202:	2b00      	cmp	r3, #0
    1204:	d1b6      	bne.n	1174 <dir_next+0x18>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
    1206:	6833      	ldr	r3, [r6, #0]
    1208:	001a      	movs	r2, r3
    120a:	3230      	adds	r2, #48	; 0x30
    120c:	218c      	movs	r1, #140	; 0x8c
    120e:	0089      	lsls	r1, r1, #2
    1210:	468c      	mov	ip, r1
    1212:	4463      	add	r3, ip
		*d++ = (BYTE)val;
    1214:	2100      	movs	r1, #0
    1216:	7011      	strb	r1, [r2, #0]
    1218:	3201      	adds	r2, #1
	while (cnt--)
    121a:	429a      	cmp	r2, r3
    121c:	d1fb      	bne.n	1216 <dir_next+0xba>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
    121e:	6835      	ldr	r5, [r6, #0]
    1220:	4649      	mov	r1, r9
    1222:	0028      	movs	r0, r5
    1224:	4b15      	ldr	r3, [pc, #84]	; (127c <dir_next+0x120>)
    1226:	4798      	blx	r3
    1228:	62e8      	str	r0, [r5, #44]	; 0x2c
						dp->fs->wflag = 1;
    122a:	2501      	movs	r5, #1
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    122c:	6833      	ldr	r3, [r6, #0]
    122e:	789a      	ldrb	r2, [r3, #2]
    1230:	4590      	cmp	r8, r2
    1232:	d20d      	bcs.n	1250 <dir_next+0xf4>
						dp->fs->wflag = 1;
    1234:	711d      	strb	r5, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    1236:	6830      	ldr	r0, [r6, #0]
    1238:	4b0f      	ldr	r3, [pc, #60]	; (1278 <dir_next+0x11c>)
    123a:	4798      	blx	r3
    123c:	2800      	cmp	r0, #0
    123e:	d115      	bne.n	126c <dir_next+0x110>
						dp->fs->winsect++;
    1240:	6832      	ldr	r2, [r6, #0]
    1242:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    1244:	3301      	adds	r3, #1
    1246:	62d3      	str	r3, [r2, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    1248:	2301      	movs	r3, #1
    124a:	469c      	mov	ip, r3
    124c:	44e0      	add	r8, ip
    124e:	e7ed      	b.n	122c <dir_next+0xd0>
					dp->fs->winsect -= c;						/* Rewind window offset */
    1250:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1252:	4641      	mov	r1, r8
    1254:	1a52      	subs	r2, r2, r1
    1256:	62da      	str	r2, [r3, #44]	; 0x2c
				dp->clust = clst;				/* Initialize data for new cluster */
    1258:	464b      	mov	r3, r9
    125a:	60f3      	str	r3, [r6, #12]
				dp->sect = clust2sect(dp->fs, clst);
    125c:	4649      	mov	r1, r9
    125e:	6830      	ldr	r0, [r6, #0]
    1260:	4b06      	ldr	r3, [pc, #24]	; (127c <dir_next+0x120>)
    1262:	4798      	blx	r3
    1264:	6130      	str	r0, [r6, #16]
    1266:	e7a0      	b.n	11aa <dir_next+0x4e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    1268:	2001      	movs	r0, #1
    126a:	e783      	b.n	1174 <dir_next+0x18>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    126c:	2001      	movs	r0, #1
    126e:	e781      	b.n	1174 <dir_next+0x18>
    1270:	00000d9d 	.word	0x00000d9d
    1274:	00001091 	.word	0x00001091
    1278:	0000072d 	.word	0x0000072d
    127c:	00000d85 	.word	0x00000d85

00001280 <follow_path>:
{
    1280:	b5f0      	push	{r4, r5, r6, r7, lr}
    1282:	46de      	mov	lr, fp
    1284:	4657      	mov	r7, sl
    1286:	464e      	mov	r6, r9
    1288:	4645      	mov	r5, r8
    128a:	b5e0      	push	{r5, r6, r7, lr}
    128c:	b085      	sub	sp, #20
    128e:	0004      	movs	r4, r0
    1290:	000e      	movs	r6, r1
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
    1292:	780b      	ldrb	r3, [r1, #0]
    1294:	2b2f      	cmp	r3, #47	; 0x2f
    1296:	d009      	beq.n	12ac <follow_path+0x2c>
    1298:	2b5c      	cmp	r3, #92	; 0x5c
    129a:	d007      	beq.n	12ac <follow_path+0x2c>
	dp->sclust = 0;							/* Always start from the root directory */
    129c:	2300      	movs	r3, #0
    129e:	60a3      	str	r3, [r4, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
    12a0:	7833      	ldrb	r3, [r6, #0]
    12a2:	2b1f      	cmp	r3, #31
    12a4:	d904      	bls.n	12b0 <follow_path+0x30>
		res = dir_next(dp, 0);		/* Next entry */
    12a6:	4b95      	ldr	r3, [pc, #596]	; (14fc <follow_path+0x27c>)
    12a8:	469a      	mov	sl, r3
    12aa:	e009      	b.n	12c0 <follow_path+0x40>
		path++;
    12ac:	3601      	adds	r6, #1
    12ae:	e7f5      	b.n	129c <follow_path+0x1c>
		res = dir_sdi(dp, 0);
    12b0:	2100      	movs	r1, #0
    12b2:	0020      	movs	r0, r4
    12b4:	4b92      	ldr	r3, [pc, #584]	; (1500 <follow_path+0x280>)
    12b6:	4798      	blx	r3
		dp->dir = 0;
    12b8:	2300      	movs	r3, #0
    12ba:	6163      	str	r3, [r4, #20]
    12bc:	e10d      	b.n	14da <follow_path+0x25a>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    12be:	3601      	adds	r6, #1
    12c0:	7833      	ldrb	r3, [r6, #0]
    12c2:	2b2f      	cmp	r3, #47	; 0x2f
    12c4:	d0fb      	beq.n	12be <follow_path+0x3e>
    12c6:	2b5c      	cmp	r3, #92	; 0x5c
    12c8:	d0f9      	beq.n	12be <follow_path+0x3e>
	sfn = dp->fn;
    12ca:	69a1      	ldr	r1, [r4, #24]
    12cc:	000b      	movs	r3, r1
    12ce:	0008      	movs	r0, r1
    12d0:	300b      	adds	r0, #11
		*d++ = (BYTE)val;
    12d2:	2220      	movs	r2, #32
    12d4:	701a      	strb	r2, [r3, #0]
    12d6:	3301      	adds	r3, #1
	while (cnt--)
    12d8:	4298      	cmp	r0, r3
    12da:	d1fb      	bne.n	12d4 <follow_path+0x54>
    12dc:	2000      	movs	r0, #0
    12de:	2200      	movs	r2, #0
    12e0:	2508      	movs	r5, #8
    12e2:	2300      	movs	r3, #0
    12e4:	469c      	mov	ip, r3
					b |= 1; c -= 0x20;
    12e6:	2301      	movs	r3, #1
    12e8:	4699      	mov	r9, r3
			b |= 3;						/* Eliminate NT flag */
    12ea:	2303      	movs	r3, #3
    12ec:	4698      	mov	r8, r3
    12ee:	9101      	str	r1, [sp, #4]
    12f0:	9402      	str	r4, [sp, #8]
		c = (BYTE)p[si++];
    12f2:	1c57      	adds	r7, r2, #1
    12f4:	5cb3      	ldrb	r3, [r6, r2]
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    12f6:	2b20      	cmp	r3, #32
    12f8:	d800      	bhi.n	12fc <follow_path+0x7c>
    12fa:	e0e5      	b.n	14c8 <follow_path+0x248>
    12fc:	2b2f      	cmp	r3, #47	; 0x2f
    12fe:	d100      	bne.n	1302 <follow_path+0x82>
    1300:	e0da      	b.n	14b8 <follow_path+0x238>
    1302:	2b5c      	cmp	r3, #92	; 0x5c
    1304:	d100      	bne.n	1308 <follow_path+0x88>
    1306:	e0d7      	b.n	14b8 <follow_path+0x238>
		if (c == '.' || i >= ni) {
    1308:	2b2e      	cmp	r3, #46	; 0x2e
    130a:	d100      	bne.n	130e <follow_path+0x8e>
    130c:	e0ec      	b.n	14e8 <follow_path+0x268>
    130e:	4285      	cmp	r5, r0
    1310:	d800      	bhi.n	1314 <follow_path+0x94>
    1312:	e0c5      	b.n	14a0 <follow_path+0x220>
		if (c >= 0x80) {				/* Extended character? */
    1314:	b25c      	sxtb	r4, r3
    1316:	2c00      	cmp	r4, #0
    1318:	db27      	blt.n	136a <follow_path+0xea>
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    131a:	247f      	movs	r4, #127	; 0x7f
    131c:	46a3      	mov	fp, r4
    131e:	449b      	add	fp, r3
    1320:	465c      	mov	r4, fp
    1322:	4669      	mov	r1, sp
    1324:	730c      	strb	r4, [r1, #12]
    1326:	b2e4      	uxtb	r4, r4
    1328:	2c1e      	cmp	r4, #30
    132a:	d907      	bls.n	133c <follow_path+0xbc>
    132c:	2420      	movs	r4, #32
    132e:	46a3      	mov	fp, r4
    1330:	449b      	add	fp, r3
    1332:	465c      	mov	r4, fp
    1334:	730c      	strb	r4, [r1, #12]
    1336:	b2e4      	uxtb	r4, r4
    1338:	2c1c      	cmp	r4, #28
    133a:	d81f      	bhi.n	137c <follow_path+0xfc>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    133c:	3202      	adds	r2, #2
    133e:	5df4      	ldrb	r4, [r6, r7]
    1340:	46a3      	mov	fp, r4
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    1342:	0027      	movs	r7, r4
    1344:	3f40      	subs	r7, #64	; 0x40
    1346:	2f3e      	cmp	r7, #62	; 0x3e
    1348:	d904      	bls.n	1354 <follow_path+0xd4>
    134a:	3f40      	subs	r7, #64	; 0x40
    134c:	b2ff      	uxtb	r7, r7
    134e:	2f7c      	cmp	r7, #124	; 0x7c
    1350:	d900      	bls.n	1354 <follow_path+0xd4>
    1352:	e0a7      	b.n	14a4 <follow_path+0x224>
    1354:	1e6f      	subs	r7, r5, #1
    1356:	42b8      	cmp	r0, r7
    1358:	d300      	bcc.n	135c <follow_path+0xdc>
    135a:	e0a5      	b.n	14a8 <follow_path+0x228>
			sfn[i++] = c;
    135c:	1c47      	adds	r7, r0, #1
    135e:	9901      	ldr	r1, [sp, #4]
    1360:	540b      	strb	r3, [r1, r0]
			sfn[i++] = d;
    1362:	465b      	mov	r3, fp
    1364:	55cb      	strb	r3, [r1, r7]
    1366:	3002      	adds	r0, #2
    1368:	e7c3      	b.n	12f2 <follow_path+0x72>
			b |= 3;						/* Eliminate NT flag */
    136a:	4664      	mov	r4, ip
    136c:	4641      	mov	r1, r8
    136e:	430c      	orrs	r4, r1
    1370:	1c21      	adds	r1, r4, #0
    1372:	466c      	mov	r4, sp
    1374:	7321      	strb	r1, [r4, #12]
    1376:	7b21      	ldrb	r1, [r4, #12]
    1378:	468c      	mov	ip, r1
    137a:	e7ce      	b.n	131a <follow_path+0x9a>
	while (*str && *str != chr) str++;
    137c:	2b22      	cmp	r3, #34	; 0x22
    137e:	d021      	beq.n	13c4 <follow_path+0x144>
    1380:	222a      	movs	r2, #42	; 0x2a
    1382:	4693      	mov	fp, r2
    1384:	4a5f      	ldr	r2, [pc, #380]	; (1504 <follow_path+0x284>)
    1386:	4659      	mov	r1, fp
    1388:	9103      	str	r1, [sp, #12]
    138a:	9901      	ldr	r1, [sp, #4]
    138c:	468b      	mov	fp, r1
    138e:	0019      	movs	r1, r3
    1390:	9c02      	ldr	r4, [sp, #8]
    1392:	232a      	movs	r3, #42	; 0x2a
    1394:	4299      	cmp	r1, r3
    1396:	d017      	beq.n	13c8 <follow_path+0x148>
    1398:	3201      	adds	r2, #1
    139a:	7813      	ldrb	r3, [r2, #0]
    139c:	2b00      	cmp	r3, #0
    139e:	d1f9      	bne.n	1394 <follow_path+0x114>
    13a0:	000b      	movs	r3, r1
    13a2:	465a      	mov	r2, fp
    13a4:	9201      	str	r2, [sp, #4]
    13a6:	9402      	str	r4, [sp, #8]
			if (IsUpper(c)) {			/* ASCII large capital? */
    13a8:	000a      	movs	r2, r1
    13aa:	3a41      	subs	r2, #65	; 0x41
    13ac:	2a19      	cmp	r2, #25
    13ae:	d810      	bhi.n	13d2 <follow_path+0x152>
				b |= 2;
    13b0:	4662      	mov	r2, ip
    13b2:	2102      	movs	r1, #2
    13b4:	430a      	orrs	r2, r1
    13b6:	b2d2      	uxtb	r2, r2
    13b8:	4694      	mov	ip, r2
			sfn[i++] = c;
    13ba:	9a01      	ldr	r2, [sp, #4]
    13bc:	5413      	strb	r3, [r2, r0]
    13be:	3001      	adds	r0, #1
		c = (BYTE)p[si++];
    13c0:	003a      	movs	r2, r7
    13c2:	e796      	b.n	12f2 <follow_path+0x72>
				return FR_INVALID_NAME;
    13c4:	2006      	movs	r0, #6
    13c6:	e088      	b.n	14da <follow_path+0x25a>
    13c8:	1e0b      	subs	r3, r1, #0
    13ca:	465a      	mov	r2, fp
    13cc:	9201      	str	r2, [sp, #4]
    13ce:	9402      	str	r4, [sp, #8]
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    13d0:	d16c      	bne.n	14ac <follow_path+0x22c>
				if (IsLower(c)) {		/* ASCII small capital? */
    13d2:	001a      	movs	r2, r3
    13d4:	3a61      	subs	r2, #97	; 0x61
    13d6:	2a19      	cmp	r2, #25
    13d8:	d8ef      	bhi.n	13ba <follow_path+0x13a>
					b |= 1; c -= 0x20;
    13da:	4662      	mov	r2, ip
    13dc:	4649      	mov	r1, r9
    13de:	430a      	orrs	r2, r1
    13e0:	b2d2      	uxtb	r2, r2
    13e2:	4694      	mov	ip, r2
    13e4:	3b20      	subs	r3, #32
    13e6:	b2db      	uxtb	r3, r3
    13e8:	e7e7      	b.n	13ba <follow_path+0x13a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    13ea:	780a      	ldrb	r2, [r1, #0]
    13ec:	2ae5      	cmp	r2, #229	; 0xe5
    13ee:	d018      	beq.n	1422 <follow_path+0x1a2>
	if (ni == 8) b <<= 2;
    13f0:	2d08      	cmp	r5, #8
    13f2:	d019      	beq.n	1428 <follow_path+0x1a8>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    13f4:	2203      	movs	r2, #3
    13f6:	4660      	mov	r0, ip
    13f8:	4002      	ands	r2, r0
    13fa:	2a01      	cmp	r2, #1
    13fc:	d019      	beq.n	1432 <follow_path+0x1b2>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    13fe:	220c      	movs	r2, #12
    1400:	4660      	mov	r0, ip
    1402:	4002      	ands	r2, r0
    1404:	2a04      	cmp	r2, #4
    1406:	d017      	beq.n	1438 <follow_path+0x1b8>
	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
    1408:	72cb      	strb	r3, [r1, #11]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
    140a:	2100      	movs	r1, #0
    140c:	0020      	movs	r0, r4
    140e:	4b3c      	ldr	r3, [pc, #240]	; (1500 <follow_path+0x280>)
    1410:	4798      	blx	r3
	if (res != FR_OK) return res;
    1412:	2800      	cmp	r0, #0
    1414:	d15d      	bne.n	14d2 <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    1416:	4b3c      	ldr	r3, [pc, #240]	; (1508 <follow_path+0x288>)
    1418:	469b      	mov	fp, r3
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    141a:	2308      	movs	r3, #8
    141c:	4698      	mov	r8, r3
    141e:	46b1      	mov	r9, r6
    1420:	e012      	b.n	1448 <follow_path+0x1c8>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    1422:	3ae0      	subs	r2, #224	; 0xe0
    1424:	700a      	strb	r2, [r1, #0]
    1426:	e7e3      	b.n	13f0 <follow_path+0x170>
	if (ni == 8) b <<= 2;
    1428:	4662      	mov	r2, ip
    142a:	0092      	lsls	r2, r2, #2
    142c:	b2d2      	uxtb	r2, r2
    142e:	4694      	mov	ip, r2
    1430:	e7e0      	b.n	13f4 <follow_path+0x174>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    1432:	320f      	adds	r2, #15
    1434:	4313      	orrs	r3, r2
    1436:	e7e2      	b.n	13fe <follow_path+0x17e>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    1438:	3204      	adds	r2, #4
    143a:	4313      	orrs	r3, r2
    143c:	e7e4      	b.n	1408 <follow_path+0x188>
		res = dir_next(dp, 0);		/* Next entry */
    143e:	2100      	movs	r1, #0
    1440:	0020      	movs	r0, r4
    1442:	47d0      	blx	sl
	} while (res == FR_OK);
    1444:	2800      	cmp	r0, #0
    1446:	d144      	bne.n	14d2 <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    1448:	6921      	ldr	r1, [r4, #16]
    144a:	6820      	ldr	r0, [r4, #0]
    144c:	47d8      	blx	fp
		if (res != FR_OK) break;
    144e:	2800      	cmp	r0, #0
    1450:	d13f      	bne.n	14d2 <follow_path+0x252>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
    1452:	6961      	ldr	r1, [r4, #20]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    1454:	780b      	ldrb	r3, [r1, #0]
    1456:	2b00      	cmp	r3, #0
    1458:	d01a      	beq.n	1490 <follow_path+0x210>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    145a:	7ace      	ldrb	r6, [r1, #11]
    145c:	4643      	mov	r3, r8
    145e:	4233      	tst	r3, r6
    1460:	d1ed      	bne.n	143e <follow_path+0x1be>
    1462:	69a7      	ldr	r7, [r4, #24]
    1464:	2300      	movs	r3, #0
	while (cnt-- && (r = *d++ - *s++) == 0) ;
    1466:	5ccd      	ldrb	r5, [r1, r3]
    1468:	5cfa      	ldrb	r2, [r7, r3]
    146a:	4295      	cmp	r5, r2
    146c:	d1e7      	bne.n	143e <follow_path+0x1be>
    146e:	3301      	adds	r3, #1
    1470:	2b0b      	cmp	r3, #11
    1472:	d1f8      	bne.n	1466 <follow_path+0x1e6>
    1474:	464b      	mov	r3, r9
    1476:	46b1      	mov	r9, r6
    1478:	001e      	movs	r6, r3
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
    147a:	7afb      	ldrb	r3, [r7, #11]
    147c:	075b      	lsls	r3, r3, #29
    147e:	d42c      	bmi.n	14da <follow_path+0x25a>
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
    1480:	464b      	mov	r3, r9
    1482:	06db      	lsls	r3, r3, #27
    1484:	d514      	bpl.n	14b0 <follow_path+0x230>
			dp->sclust = ld_clust(dp->fs, dir);
    1486:	6820      	ldr	r0, [r4, #0]
    1488:	4b20      	ldr	r3, [pc, #128]	; (150c <follow_path+0x28c>)
    148a:	4798      	blx	r3
    148c:	60a0      	str	r0, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
    148e:	e717      	b.n	12c0 <follow_path+0x40>
			ns = dp->fn[NSFLAG];
    1490:	69a3      	ldr	r3, [r4, #24]
    1492:	7adb      	ldrb	r3, [r3, #11]
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
    1494:	2004      	movs	r0, #4
    1496:	4003      	ands	r3, r0
    1498:	4258      	negs	r0, r3
    149a:	4158      	adcs	r0, r3
    149c:	3004      	adds	r0, #4
    149e:	e01c      	b.n	14da <follow_path+0x25a>
		if (c == '.' || i >= ni) {
    14a0:	2006      	movs	r0, #6
    14a2:	e01a      	b.n	14da <follow_path+0x25a>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    14a4:	2006      	movs	r0, #6
    14a6:	e018      	b.n	14da <follow_path+0x25a>
    14a8:	2006      	movs	r0, #6
    14aa:	e016      	b.n	14da <follow_path+0x25a>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    14ac:	2006      	movs	r0, #6
    14ae:	e014      	b.n	14da <follow_path+0x25a>
				res = FR_NO_PATH; break;
    14b0:	2005      	movs	r0, #5
    14b2:	e012      	b.n	14da <follow_path+0x25a>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    14b4:	2006      	movs	r0, #6
    14b6:	e010      	b.n	14da <follow_path+0x25a>
    14b8:	9901      	ldr	r1, [sp, #4]
    14ba:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    14bc:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    14be:	2300      	movs	r3, #0
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    14c0:	2800      	cmp	r0, #0
    14c2:	d192      	bne.n	13ea <follow_path+0x16a>
    14c4:	2006      	movs	r0, #6
    14c6:	e008      	b.n	14da <follow_path+0x25a>
    14c8:	9901      	ldr	r1, [sp, #4]
    14ca:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    14cc:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    14ce:	2304      	movs	r3, #4
    14d0:	e7f6      	b.n	14c0 <follow_path+0x240>
			ns = dp->fn[NSFLAG];
    14d2:	69a3      	ldr	r3, [r4, #24]
    14d4:	7adb      	ldrb	r3, [r3, #11]
				if (res == FR_NO_FILE) {	/* Object is not found */
    14d6:	2804      	cmp	r0, #4
    14d8:	d0dc      	beq.n	1494 <follow_path+0x214>
}
    14da:	b005      	add	sp, #20
    14dc:	bc3c      	pop	{r2, r3, r4, r5}
    14de:	4690      	mov	r8, r2
    14e0:	4699      	mov	r9, r3
    14e2:	46a2      	mov	sl, r4
    14e4:	46ab      	mov	fp, r5
    14e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    14e8:	2d08      	cmp	r5, #8
    14ea:	d1e3      	bne.n	14b4 <follow_path+0x234>
			b <<= 2; continue;
    14ec:	4663      	mov	r3, ip
    14ee:	009b      	lsls	r3, r3, #2
    14f0:	b2db      	uxtb	r3, r3
    14f2:	469c      	mov	ip, r3
			i = 8; ni = 11;
    14f4:	0028      	movs	r0, r5
		c = (BYTE)p[si++];
    14f6:	003a      	movs	r2, r7
			i = 8; ni = 11;
    14f8:	250b      	movs	r5, #11
    14fa:	e6fa      	b.n	12f2 <follow_path+0x72>
    14fc:	0000115d 	.word	0x0000115d
    1500:	00000e95 	.word	0x00000e95
    1504:	00002b7d 	.word	0x00002b7d
    1508:	00000799 	.word	0x00000799
    150c:	000006b5 	.word	0x000006b5

00001510 <dir_register>:
{
    1510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1512:	0005      	movs	r5, r0
	res = dir_sdi(dp, 0);
    1514:	2100      	movs	r1, #0
    1516:	4b1b      	ldr	r3, [pc, #108]	; (1584 <dir_register+0x74>)
    1518:	4798      	blx	r3
    151a:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
    151c:	d12b      	bne.n	1576 <dir_register+0x66>
			res = move_window(dp->fs, dp->sect);
    151e:	4e1a      	ldr	r6, [pc, #104]	; (1588 <dir_register+0x78>)
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
    1520:	4f1a      	ldr	r7, [pc, #104]	; (158c <dir_register+0x7c>)
    1522:	e004      	b.n	152e <dir_register+0x1e>
    1524:	2101      	movs	r1, #1
    1526:	0028      	movs	r0, r5
    1528:	47b8      	blx	r7
    152a:	1e04      	subs	r4, r0, #0
		} while (res == FR_OK);
    152c:	d127      	bne.n	157e <dir_register+0x6e>
			res = move_window(dp->fs, dp->sect);
    152e:	6929      	ldr	r1, [r5, #16]
    1530:	6828      	ldr	r0, [r5, #0]
    1532:	47b0      	blx	r6
    1534:	1e04      	subs	r4, r0, #0
			if (res != FR_OK) break;
    1536:	d122      	bne.n	157e <dir_register+0x6e>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
    1538:	696b      	ldr	r3, [r5, #20]
    153a:	781b      	ldrb	r3, [r3, #0]
    153c:	2be5      	cmp	r3, #229	; 0xe5
    153e:	d001      	beq.n	1544 <dir_register+0x34>
    1540:	2b00      	cmp	r3, #0
    1542:	d1ef      	bne.n	1524 <dir_register+0x14>
		res = move_window(dp->fs, dp->sect);
    1544:	6929      	ldr	r1, [r5, #16]
    1546:	6828      	ldr	r0, [r5, #0]
    1548:	4b0f      	ldr	r3, [pc, #60]	; (1588 <dir_register+0x78>)
    154a:	4798      	blx	r3
    154c:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
    154e:	d001      	beq.n	1554 <dir_register+0x44>
}
    1550:	0020      	movs	r0, r4
    1552:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
    1554:	696b      	ldr	r3, [r5, #20]
    1556:	0019      	movs	r1, r3
    1558:	3120      	adds	r1, #32
		*d++ = (BYTE)val;
    155a:	2200      	movs	r2, #0
    155c:	701a      	strb	r2, [r3, #0]
    155e:	3301      	adds	r3, #1
	while (cnt--)
    1560:	428b      	cmp	r3, r1
    1562:	d1fb      	bne.n	155c <dir_register+0x4c>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
    1564:	220b      	movs	r2, #11
    1566:	69a9      	ldr	r1, [r5, #24]
    1568:	6968      	ldr	r0, [r5, #20]
    156a:	4b09      	ldr	r3, [pc, #36]	; (1590 <dir_register+0x80>)
    156c:	4798      	blx	r3
			dp->fs->wflag = 1;
    156e:	682b      	ldr	r3, [r5, #0]
    1570:	2201      	movs	r2, #1
    1572:	711a      	strb	r2, [r3, #4]
    1574:	e7ec      	b.n	1550 <dir_register+0x40>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    1576:	2804      	cmp	r0, #4
    1578:	d1ea      	bne.n	1550 <dir_register+0x40>
    157a:	2407      	movs	r4, #7
    157c:	e7e8      	b.n	1550 <dir_register+0x40>
    157e:	2c04      	cmp	r4, #4
    1580:	d0fb      	beq.n	157a <dir_register+0x6a>
    1582:	e7e5      	b.n	1550 <dir_register+0x40>
    1584:	00000e95 	.word	0x00000e95
    1588:	00000799 	.word	0x00000799
    158c:	0000115d 	.word	0x0000115d
    1590:	000006a1 	.word	0x000006a1

00001594 <remove_chain>:
{
    1594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1596:	46ce      	mov	lr, r9
    1598:	4647      	mov	r7, r8
    159a:	b580      	push	{r7, lr}
    159c:	0004      	movs	r4, r0
    159e:	000d      	movs	r5, r1
		res = FR_INT_ERR;
    15a0:	2002      	movs	r0, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    15a2:	2901      	cmp	r1, #1
    15a4:	d902      	bls.n	15ac <remove_chain+0x18>
    15a6:	6963      	ldr	r3, [r4, #20]
    15a8:	4299      	cmp	r1, r3
    15aa:	d303      	bcc.n	15b4 <remove_chain+0x20>
}
    15ac:	bc0c      	pop	{r2, r3}
    15ae:	4690      	mov	r8, r2
    15b0:	4699      	mov	r9, r3
    15b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			nxt = get_fat(fs, clst);			/* Get cluster status */
    15b4:	4f14      	ldr	r7, [pc, #80]	; (1608 <remove_chain+0x74>)
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    15b6:	4b15      	ldr	r3, [pc, #84]	; (160c <remove_chain+0x78>)
    15b8:	4698      	mov	r8, r3
				fs->fsi_flag |= 1;
    15ba:	2301      	movs	r3, #1
    15bc:	4699      	mov	r9, r3
    15be:	e003      	b.n	15c8 <remove_chain+0x34>
    15c0:	0035      	movs	r5, r6
		while (clst < fs->n_fatent) {			/* Not a last link? */
    15c2:	6963      	ldr	r3, [r4, #20]
    15c4:	42b3      	cmp	r3, r6
    15c6:	d9f1      	bls.n	15ac <remove_chain+0x18>
			nxt = get_fat(fs, clst);			/* Get cluster status */
    15c8:	0029      	movs	r1, r5
    15ca:	0020      	movs	r0, r4
    15cc:	47b8      	blx	r7
    15ce:	1e06      	subs	r6, r0, #0
			if (nxt == 0) break;				/* Empty cluster? */
    15d0:	d013      	beq.n	15fa <remove_chain+0x66>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    15d2:	2801      	cmp	r0, #1
    15d4:	d013      	beq.n	15fe <remove_chain+0x6a>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    15d6:	1c43      	adds	r3, r0, #1
    15d8:	d013      	beq.n	1602 <remove_chain+0x6e>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    15da:	2200      	movs	r2, #0
    15dc:	0029      	movs	r1, r5
    15de:	0020      	movs	r0, r4
    15e0:	47c0      	blx	r8
			if (res != FR_OK) break;
    15e2:	2800      	cmp	r0, #0
    15e4:	d1e2      	bne.n	15ac <remove_chain+0x18>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
    15e6:	6923      	ldr	r3, [r4, #16]
    15e8:	1c5a      	adds	r2, r3, #1
    15ea:	d0e9      	beq.n	15c0 <remove_chain+0x2c>
				fs->free_clust++;
    15ec:	3301      	adds	r3, #1
    15ee:	6123      	str	r3, [r4, #16]
				fs->fsi_flag |= 1;
    15f0:	7963      	ldrb	r3, [r4, #5]
    15f2:	464a      	mov	r2, r9
    15f4:	4313      	orrs	r3, r2
    15f6:	7163      	strb	r3, [r4, #5]
    15f8:	e7e2      	b.n	15c0 <remove_chain+0x2c>
    15fa:	2000      	movs	r0, #0
    15fc:	e7d6      	b.n	15ac <remove_chain+0x18>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    15fe:	2002      	movs	r0, #2
    1600:	e7d4      	b.n	15ac <remove_chain+0x18>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    1602:	2001      	movs	r0, #1
    1604:	e7d2      	b.n	15ac <remove_chain+0x18>
    1606:	46c0      	nop			; (mov r8, r8)
    1608:	00000d9d 	.word	0x00000d9d
    160c:	00000f45 	.word	0x00000f45

00001610 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    1610:	b510      	push	{r4, lr}
    1612:	b084      	sub	sp, #16
    1614:	9001      	str	r0, [sp, #4]
    1616:	9100      	str	r1, [sp, #0]
    1618:	0014      	movs	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
    161a:	9103      	str	r1, [sp, #12]


	vol = get_ldnumber(&rp);
    161c:	a803      	add	r0, sp, #12
    161e:	4b15      	ldr	r3, [pc, #84]	; (1674 <f_mount+0x64>)
    1620:	4798      	blx	r3
	if (vol < 0) return FR_INVALID_DRIVE;
    1622:	230b      	movs	r3, #11
    1624:	2800      	cmp	r0, #0
    1626:	db14      	blt.n	1652 <f_mount+0x42>
	cfs = FatFs[vol];					/* Pointer to fs object */
    1628:	0083      	lsls	r3, r0, #2
    162a:	4a13      	ldr	r2, [pc, #76]	; (1678 <f_mount+0x68>)
    162c:	589b      	ldr	r3, [r3, r2]

	if (cfs) {
    162e:	2b00      	cmp	r3, #0
    1630:	d001      	beq.n	1636 <f_mount+0x26>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
    1632:	2200      	movs	r2, #0
    1634:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
    1636:	9b01      	ldr	r3, [sp, #4]
    1638:	2b00      	cmp	r3, #0
    163a:	d014      	beq.n	1666 <f_mount+0x56>
		fs->fs_type = 0;				/* Clear new fs object */
    163c:	2200      	movs	r2, #0
    163e:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
    1640:	9a01      	ldr	r2, [sp, #4]
    1642:	0080      	lsls	r0, r0, #2
    1644:	4b0c      	ldr	r3, [pc, #48]	; (1678 <f_mount+0x68>)
    1646:	50c2      	str	r2, [r0, r3]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    1648:	2300      	movs	r3, #0
    164a:	2a00      	cmp	r2, #0
    164c:	d001      	beq.n	1652 <f_mount+0x42>
    164e:	2c01      	cmp	r4, #1
    1650:	d002      	beq.n	1658 <f_mount+0x48>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
    1652:	0018      	movs	r0, r3
    1654:	b004      	add	sp, #16
    1656:	bd10      	pop	{r4, pc}
	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
    1658:	2200      	movs	r2, #0
    165a:	4669      	mov	r1, sp
    165c:	a801      	add	r0, sp, #4
    165e:	4b07      	ldr	r3, [pc, #28]	; (167c <f_mount+0x6c>)
    1660:	4798      	blx	r3
    1662:	0003      	movs	r3, r0
	LEAVE_FF(fs, res);
    1664:	e7f5      	b.n	1652 <f_mount+0x42>
	FatFs[vol] = fs;					/* Register new fs object */
    1666:	0080      	lsls	r0, r0, #2
    1668:	2200      	movs	r2, #0
    166a:	4b03      	ldr	r3, [pc, #12]	; (1678 <f_mount+0x68>)
    166c:	50c2      	str	r2, [r0, r3]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    166e:	2300      	movs	r3, #0
    1670:	e7ef      	b.n	1652 <f_mount+0x42>
    1672:	46c0      	nop			; (mov r8, r8)
    1674:	000006d7 	.word	0x000006d7
    1678:	20000458 	.word	0x20000458
    167c:	000008b5 	.word	0x000008b5

00001680 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    1680:	b5f0      	push	{r4, r5, r6, r7, lr}
    1682:	46d6      	mov	lr, sl
    1684:	464f      	mov	r7, r9
    1686:	4646      	mov	r6, r8
    1688:	b5c0      	push	{r6, r7, lr}
    168a:	b08c      	sub	sp, #48	; 0x30
    168c:	0005      	movs	r5, r0
    168e:	9101      	str	r1, [sp, #4]
    1690:	0016      	movs	r6, r2
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
    1692:	2409      	movs	r4, #9
    1694:	2800      	cmp	r0, #0
    1696:	d009      	beq.n	16ac <f_open+0x2c>
	fp->fs = 0;			/* Clear file object */
    1698:	2300      	movs	r3, #0
    169a:	6003      	str	r3, [r0, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
    169c:	221e      	movs	r2, #30
    169e:	4032      	ands	r2, r6
    16a0:	a901      	add	r1, sp, #4
    16a2:	a805      	add	r0, sp, #20
    16a4:	4b57      	ldr	r3, [pc, #348]	; (1804 <f_open+0x184>)
    16a6:	4798      	blx	r3
    16a8:	1e04      	subs	r4, r0, #0
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
    16aa:	d006      	beq.n	16ba <f_open+0x3a>
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
    16ac:	0020      	movs	r0, r4
    16ae:	b00c      	add	sp, #48	; 0x30
    16b0:	bc1c      	pop	{r2, r3, r4}
    16b2:	4690      	mov	r8, r2
    16b4:	4699      	mov	r9, r3
    16b6:	46a2      	mov	sl, r4
    16b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    16ba:	231f      	movs	r3, #31
    16bc:	4033      	ands	r3, r6
    16be:	4698      	mov	r8, r3
		INIT_BUF(dj);
    16c0:	ab02      	add	r3, sp, #8
    16c2:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
    16c4:	9901      	ldr	r1, [sp, #4]
    16c6:	a805      	add	r0, sp, #20
    16c8:	4b4f      	ldr	r3, [pc, #316]	; (1808 <f_open+0x188>)
    16ca:	4798      	blx	r3
		dir = dj.dir;
    16cc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    16ce:	2800      	cmp	r0, #0
    16d0:	d135      	bne.n	173e <f_open+0xbe>
			if (!dir)	/* Default directory itself */
    16d2:	2f00      	cmp	r7, #0
    16d4:	d100      	bne.n	16d8 <f_open+0x58>
    16d6:	e088      	b.n	17ea <f_open+0x16a>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    16d8:	231c      	movs	r3, #28
    16da:	4233      	tst	r3, r6
    16dc:	d149      	bne.n	1772 <f_open+0xf2>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
    16de:	7afb      	ldrb	r3, [r7, #11]
    16e0:	06da      	lsls	r2, r3, #27
    16e2:	d500      	bpl.n	16e6 <f_open+0x66>
    16e4:	e08c      	b.n	1800 <f_open+0x180>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    16e6:	07b2      	lsls	r2, r6, #30
    16e8:	d502      	bpl.n	16f0 <f_open+0x70>
    16ea:	07db      	lsls	r3, r3, #31
    16ec:	d500      	bpl.n	16f0 <f_open+0x70>
    16ee:	e085      	b.n	17fc <f_open+0x17c>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
    16f0:	0733      	lsls	r3, r6, #28
    16f2:	d503      	bpl.n	16fc <f_open+0x7c>
				mode |= FA__WRITTEN;
    16f4:	2320      	movs	r3, #32
    16f6:	4642      	mov	r2, r8
    16f8:	431a      	orrs	r2, r3
    16fa:	4690      	mov	r8, r2
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    16fc:	9b05      	ldr	r3, [sp, #20]
    16fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1700:	61eb      	str	r3, [r5, #28]
			fp->dir_ptr = dir;
    1702:	622f      	str	r7, [r5, #32]
			fp->flag = mode;					/* File access mode */
    1704:	4643      	mov	r3, r8
    1706:	71ab      	strb	r3, [r5, #6]
			fp->err = 0;						/* Clear error flag */
    1708:	2300      	movs	r3, #0
    170a:	4698      	mov	r8, r3
    170c:	71eb      	strb	r3, [r5, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    170e:	9e05      	ldr	r6, [sp, #20]
    1710:	0039      	movs	r1, r7
    1712:	0030      	movs	r0, r6
    1714:	4b3d      	ldr	r3, [pc, #244]	; (180c <f_open+0x18c>)
    1716:	4798      	blx	r3
    1718:	6128      	str	r0, [r5, #16]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
    171a:	7ffb      	ldrb	r3, [r7, #31]
    171c:	061b      	lsls	r3, r3, #24
    171e:	7fba      	ldrb	r2, [r7, #30]
    1720:	0412      	lsls	r2, r2, #16
    1722:	4313      	orrs	r3, r2
    1724:	7f3a      	ldrb	r2, [r7, #28]
    1726:	4313      	orrs	r3, r2
    1728:	7f7a      	ldrb	r2, [r7, #29]
    172a:	0212      	lsls	r2, r2, #8
    172c:	4313      	orrs	r3, r2
    172e:	60eb      	str	r3, [r5, #12]
			fp->fptr = 0;						/* File pointer */
    1730:	4643      	mov	r3, r8
    1732:	60ab      	str	r3, [r5, #8]
			fp->dsect = 0;
    1734:	61ab      	str	r3, [r5, #24]
			fp->fs = dj.fs;	 					/* Validate file object */
    1736:	602e      	str	r6, [r5, #0]
			fp->id = fp->fs->id;
    1738:	88f3      	ldrh	r3, [r6, #6]
    173a:	80ab      	strh	r3, [r5, #4]
    173c:	e7b6      	b.n	16ac <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    173e:	231c      	movs	r3, #28
    1740:	4233      	tst	r3, r6
    1742:	d006      	beq.n	1752 <f_open+0xd2>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    1744:	2804      	cmp	r0, #4
    1746:	d008      	beq.n	175a <f_open+0xda>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    1748:	2308      	movs	r3, #8
    174a:	4642      	mov	r2, r8
    174c:	431a      	orrs	r2, r3
    174e:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    1750:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    1752:	2800      	cmp	r0, #0
    1754:	d0d6      	beq.n	1704 <f_open+0x84>
    1756:	0004      	movs	r4, r0
    1758:	e7a8      	b.n	16ac <f_open+0x2c>
					res = dir_register(&dj);
    175a:	a805      	add	r0, sp, #20
    175c:	4b2c      	ldr	r3, [pc, #176]	; (1810 <f_open+0x190>)
    175e:	4798      	blx	r3
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    1760:	2308      	movs	r3, #8
    1762:	4642      	mov	r2, r8
    1764:	431a      	orrs	r2, r3
    1766:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    1768:	9f0a      	ldr	r7, [sp, #40]	; 0x28
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    176a:	2800      	cmp	r0, #0
    176c:	d007      	beq.n	177e <f_open+0xfe>
					res = dir_register(&dj);
    176e:	0004      	movs	r4, r0
    1770:	e79c      	b.n	16ac <f_open+0x2c>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    1772:	7afb      	ldrb	r3, [r7, #11]
    1774:	2211      	movs	r2, #17
    1776:	421a      	tst	r2, r3
    1778:	d13c      	bne.n	17f4 <f_open+0x174>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    177a:	0773      	lsls	r3, r6, #29
    177c:	d43c      	bmi.n	17f8 <f_open+0x178>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    177e:	4643      	mov	r3, r8
    1780:	071b      	lsls	r3, r3, #28
    1782:	d5bb      	bpl.n	16fc <f_open+0x7c>
				dw = GET_FATTIME();				/* Created time */
    1784:	4b23      	ldr	r3, [pc, #140]	; (1814 <f_open+0x194>)
    1786:	4798      	blx	r3
				ST_DWORD(dir + DIR_CrtTime, dw);
    1788:	73b8      	strb	r0, [r7, #14]
    178a:	0a03      	lsrs	r3, r0, #8
    178c:	73fb      	strb	r3, [r7, #15]
    178e:	0c03      	lsrs	r3, r0, #16
    1790:	743b      	strb	r3, [r7, #16]
    1792:	0e00      	lsrs	r0, r0, #24
    1794:	7478      	strb	r0, [r7, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
    1796:	2600      	movs	r6, #0
    1798:	72fe      	strb	r6, [r7, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
    179a:	773e      	strb	r6, [r7, #28]
    179c:	777e      	strb	r6, [r7, #29]
    179e:	77be      	strb	r6, [r7, #30]
    17a0:	77fe      	strb	r6, [r7, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
    17a2:	9b05      	ldr	r3, [sp, #20]
    17a4:	4699      	mov	r9, r3
    17a6:	0039      	movs	r1, r7
    17a8:	0018      	movs	r0, r3
    17aa:	4b18      	ldr	r3, [pc, #96]	; (180c <f_open+0x18c>)
    17ac:	4798      	blx	r3
    17ae:	4682      	mov	sl, r0
	ST_WORD(dir + DIR_FstClusLO, cl);
    17b0:	76be      	strb	r6, [r7, #26]
    17b2:	76fe      	strb	r6, [r7, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    17b4:	753e      	strb	r6, [r7, #20]
    17b6:	757e      	strb	r6, [r7, #21]
				dj.fs->wflag = 1;
    17b8:	2301      	movs	r3, #1
    17ba:	464a      	mov	r2, r9
    17bc:	7113      	strb	r3, [r2, #4]
				if (cl) {						/* Remove the cluster chain if exist */
    17be:	2800      	cmp	r0, #0
    17c0:	d098      	beq.n	16f4 <f_open+0x74>
					dw = dj.fs->winsect;
    17c2:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
					res = remove_chain(dj.fs, cl);
    17c4:	0001      	movs	r1, r0
    17c6:	4648      	mov	r0, r9
    17c8:	4b13      	ldr	r3, [pc, #76]	; (1818 <f_open+0x198>)
    17ca:	4798      	blx	r3
					if (res == FR_OK) {
    17cc:	2800      	cmp	r0, #0
    17ce:	d001      	beq.n	17d4 <f_open+0x154>
					res = remove_chain(dj.fs, cl);
    17d0:	0004      	movs	r4, r0
    17d2:	e76b      	b.n	16ac <f_open+0x2c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    17d4:	9805      	ldr	r0, [sp, #20]
    17d6:	4653      	mov	r3, sl
    17d8:	3b01      	subs	r3, #1
    17da:	60c3      	str	r3, [r0, #12]
						res = move_window(dj.fs, dw);
    17dc:	0031      	movs	r1, r6
    17de:	4b0f      	ldr	r3, [pc, #60]	; (181c <f_open+0x19c>)
    17e0:	4798      	blx	r3
		if (res == FR_OK) {
    17e2:	2800      	cmp	r0, #0
    17e4:	d086      	beq.n	16f4 <f_open+0x74>
						res = move_window(dj.fs, dw);
    17e6:	0004      	movs	r4, r0
    17e8:	e760      	b.n	16ac <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    17ea:	231c      	movs	r3, #28
				res = FR_INVALID_NAME;
    17ec:	2006      	movs	r0, #6
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    17ee:	4233      	tst	r3, r6
    17f0:	d1aa      	bne.n	1748 <f_open+0xc8>
    17f2:	e7ae      	b.n	1752 <f_open+0xd2>
					res = FR_DENIED;
    17f4:	2407      	movs	r4, #7
    17f6:	e759      	b.n	16ac <f_open+0x2c>
						res = FR_EXIST;
    17f8:	2408      	movs	r4, #8
    17fa:	e757      	b.n	16ac <f_open+0x2c>
						res = FR_DENIED;
    17fc:	2407      	movs	r4, #7
    17fe:	e755      	b.n	16ac <f_open+0x2c>
					res = FR_NO_FILE;
    1800:	2404      	movs	r4, #4
    1802:	e753      	b.n	16ac <f_open+0x2c>
    1804:	000008b5 	.word	0x000008b5
    1808:	00001281 	.word	0x00001281
    180c:	000006b5 	.word	0x000006b5
    1810:	00001511 	.word	0x00001511
    1814:	0000069d 	.word	0x0000069d
    1818:	00001595 	.word	0x00001595
    181c:	00000799 	.word	0x00000799

00001820 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
    1820:	b5f0      	push	{r4, r5, r6, r7, lr}
    1822:	46de      	mov	lr, fp
    1824:	4657      	mov	r7, sl
    1826:	464e      	mov	r6, r9
    1828:	4645      	mov	r5, r8
    182a:	b5e0      	push	{r5, r6, r7, lr}
    182c:	b083      	sub	sp, #12
    182e:	0004      	movs	r4, r0
    1830:	000e      	movs	r6, r1
    1832:	0015      	movs	r5, r2
    1834:	4699      	mov	r9, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    1836:	2300      	movs	r3, #0
    1838:	464a      	mov	r2, r9
    183a:	6013      	str	r3, [r2, #0]

	res = validate(fp);							/* Check validity */
    183c:	4b5d      	ldr	r3, [pc, #372]	; (19b4 <f_read+0x194>)
    183e:	4798      	blx	r3
    1840:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    1842:	2800      	cmp	r0, #0
    1844:	d108      	bne.n	1858 <f_read+0x38>
	if (fp->err)								/* Check error */
    1846:	79e3      	ldrb	r3, [r4, #7]
    1848:	2b00      	cmp	r3, #0
    184a:	d000      	beq.n	184e <f_read+0x2e>
    184c:	e0af      	b.n	19ae <f_read+0x18e>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    184e:	79a3      	ldrb	r3, [r4, #6]
    1850:	07db      	lsls	r3, r3, #31
    1852:	d409      	bmi.n	1868 <f_read+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    1854:	2307      	movs	r3, #7
    1856:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    1858:	9801      	ldr	r0, [sp, #4]
    185a:	b003      	add	sp, #12
    185c:	bc3c      	pop	{r2, r3, r4, r5}
    185e:	4690      	mov	r8, r2
    1860:	4699      	mov	r9, r3
    1862:	46a2      	mov	sl, r4
    1864:	46ab      	mov	fp, r5
    1866:	bdf0      	pop	{r4, r5, r6, r7, pc}
	remain = fp->fsize - fp->fptr;
    1868:	68e3      	ldr	r3, [r4, #12]
    186a:	68a2      	ldr	r2, [r4, #8]
    186c:	1a9f      	subs	r7, r3, r2
    186e:	42af      	cmp	r7, r5
    1870:	d900      	bls.n	1874 <f_read+0x54>
    1872:	002f      	movs	r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    1874:	2f00      	cmp	r7, #0
    1876:	d156      	bne.n	1926 <f_read+0x106>
    1878:	e7ee      	b.n	1858 <f_read+0x38>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    187a:	6961      	ldr	r1, [r4, #20]
    187c:	4b4e      	ldr	r3, [pc, #312]	; (19b8 <f_read+0x198>)
    187e:	4798      	blx	r3
    1880:	e05f      	b.n	1942 <f_read+0x122>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    1882:	2302      	movs	r3, #2
    1884:	71e3      	strb	r3, [r4, #7]
    1886:	9301      	str	r3, [sp, #4]
    1888:	e7e6      	b.n	1858 <f_read+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    188a:	2301      	movs	r3, #1
    188c:	71e3      	strb	r3, [r4, #7]
    188e:	9301      	str	r3, [sp, #4]
    1890:	e7e2      	b.n	1858 <f_read+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1892:	2302      	movs	r3, #2
    1894:	71e3      	strb	r3, [r4, #7]
    1896:	9301      	str	r3, [sp, #4]
    1898:	e7de      	b.n	1858 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    189a:	2301      	movs	r3, #1
    189c:	71e3      	strb	r3, [r4, #7]
    189e:	9301      	str	r3, [sp, #4]
    18a0:	e7da      	b.n	1858 <f_read+0x38>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    18a2:	0021      	movs	r1, r4
    18a4:	3124      	adds	r1, #36	; 0x24
    18a6:	0240      	lsls	r0, r0, #9
    18a8:	1830      	adds	r0, r6, r0
    18aa:	2280      	movs	r2, #128	; 0x80
    18ac:	0092      	lsls	r2, r2, #2
    18ae:	4b43      	ldr	r3, [pc, #268]	; (19bc <f_read+0x19c>)
    18b0:	4798      	blx	r3
    18b2:	e071      	b.n	1998 <f_read+0x178>
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    18b4:	69a2      	ldr	r2, [r4, #24]
    18b6:	4593      	cmp	fp, r2
    18b8:	d019      	beq.n	18ee <f_read+0xce>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    18ba:	79a3      	ldrb	r3, [r4, #6]
    18bc:	065b      	lsls	r3, r3, #25
    18be:	d50c      	bpl.n	18da <f_read+0xba>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    18c0:	0021      	movs	r1, r4
    18c2:	3124      	adds	r1, #36	; 0x24
    18c4:	4653      	mov	r3, sl
    18c6:	7858      	ldrb	r0, [r3, #1]
    18c8:	2301      	movs	r3, #1
    18ca:	4d3d      	ldr	r5, [pc, #244]	; (19c0 <f_read+0x1a0>)
    18cc:	47a8      	blx	r5
    18ce:	2800      	cmp	r0, #0
    18d0:	d165      	bne.n	199e <f_read+0x17e>
					fp->flag &= ~FA__DIRTY;
    18d2:	79a3      	ldrb	r3, [r4, #6]
    18d4:	2240      	movs	r2, #64	; 0x40
    18d6:	4393      	bics	r3, r2
    18d8:	71a3      	strb	r3, [r4, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    18da:	0021      	movs	r1, r4
    18dc:	3124      	adds	r1, #36	; 0x24
    18de:	6823      	ldr	r3, [r4, #0]
    18e0:	7858      	ldrb	r0, [r3, #1]
    18e2:	2301      	movs	r3, #1
    18e4:	465a      	mov	r2, fp
    18e6:	4d37      	ldr	r5, [pc, #220]	; (19c4 <f_read+0x1a4>)
    18e8:	47a8      	blx	r5
    18ea:	2800      	cmp	r0, #0
    18ec:	d15b      	bne.n	19a6 <f_read+0x186>
			fp->dsect = sect;
    18ee:	465b      	mov	r3, fp
    18f0:	61a3      	str	r3, [r4, #24]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    18f2:	68a3      	ldr	r3, [r4, #8]
    18f4:	05d9      	lsls	r1, r3, #23
    18f6:	0dc9      	lsrs	r1, r1, #23
    18f8:	2580      	movs	r5, #128	; 0x80
    18fa:	00ad      	lsls	r5, r5, #2
    18fc:	1a6d      	subs	r5, r5, r1
    18fe:	42bd      	cmp	r5, r7
    1900:	d900      	bls.n	1904 <f_read+0xe4>
    1902:	003d      	movs	r5, r7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    1904:	3124      	adds	r1, #36	; 0x24
    1906:	1861      	adds	r1, r4, r1
    1908:	002a      	movs	r2, r5
    190a:	0030      	movs	r0, r6
    190c:	4b2b      	ldr	r3, [pc, #172]	; (19bc <f_read+0x19c>)
    190e:	4798      	blx	r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    1910:	1976      	adds	r6, r6, r5
    1912:	68a3      	ldr	r3, [r4, #8]
    1914:	195b      	adds	r3, r3, r5
    1916:	60a3      	str	r3, [r4, #8]
    1918:	464b      	mov	r3, r9
    191a:	681b      	ldr	r3, [r3, #0]
    191c:	195b      	adds	r3, r3, r5
    191e:	464a      	mov	r2, r9
    1920:	6013      	str	r3, [r2, #0]
    1922:	1b7f      	subs	r7, r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    1924:	d098      	beq.n	1858 <f_read+0x38>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    1926:	68a3      	ldr	r3, [r4, #8]
    1928:	05da      	lsls	r2, r3, #23
    192a:	d1e2      	bne.n	18f2 <f_read+0xd2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    192c:	6820      	ldr	r0, [r4, #0]
    192e:	7882      	ldrb	r2, [r0, #2]
    1930:	3a01      	subs	r2, #1
    1932:	0a5d      	lsrs	r5, r3, #9
    1934:	4015      	ands	r5, r2
    1936:	b2ed      	uxtb	r5, r5
			if (!csect) {						/* On the cluster boundary? */
    1938:	2d00      	cmp	r5, #0
    193a:	d107      	bne.n	194c <f_read+0x12c>
				if (fp->fptr == 0) {			/* On the top of the file? */
    193c:	2b00      	cmp	r3, #0
    193e:	d19c      	bne.n	187a <f_read+0x5a>
					clst = fp->sclust;			/* Follow from the origin */
    1940:	6920      	ldr	r0, [r4, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    1942:	2801      	cmp	r0, #1
    1944:	d99d      	bls.n	1882 <f_read+0x62>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    1946:	1c43      	adds	r3, r0, #1
    1948:	d09f      	beq.n	188a <f_read+0x6a>
				fp->clust = clst;				/* Update current cluster */
    194a:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    194c:	6823      	ldr	r3, [r4, #0]
    194e:	469a      	mov	sl, r3
    1950:	6961      	ldr	r1, [r4, #20]
    1952:	0018      	movs	r0, r3
    1954:	4b1c      	ldr	r3, [pc, #112]	; (19c8 <f_read+0x1a8>)
    1956:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1958:	2800      	cmp	r0, #0
    195a:	d09a      	beq.n	1892 <f_read+0x72>
			sect += csect;
    195c:	4683      	mov	fp, r0
    195e:	44ab      	add	fp, r5
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    1960:	0a7b      	lsrs	r3, r7, #9
    1962:	4698      	mov	r8, r3
			if (cc) {							/* Read maximum contiguous sectors directly */
    1964:	d0a6      	beq.n	18b4 <f_read+0x94>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    1966:	4653      	mov	r3, sl
    1968:	789b      	ldrb	r3, [r3, #2]
    196a:	4642      	mov	r2, r8
    196c:	18aa      	adds	r2, r5, r2
    196e:	429a      	cmp	r2, r3
    1970:	d901      	bls.n	1976 <f_read+0x156>
					cc = fp->fs->csize - csect;
    1972:	1b5b      	subs	r3, r3, r5
    1974:	4698      	mov	r8, r3
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
    1976:	4653      	mov	r3, sl
    1978:	7858      	ldrb	r0, [r3, #1]
    197a:	4643      	mov	r3, r8
    197c:	465a      	mov	r2, fp
    197e:	0031      	movs	r1, r6
    1980:	4d10      	ldr	r5, [pc, #64]	; (19c4 <f_read+0x1a4>)
    1982:	47a8      	blx	r5
    1984:	2800      	cmp	r0, #0
    1986:	d188      	bne.n	189a <f_read+0x7a>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    1988:	79a3      	ldrb	r3, [r4, #6]
    198a:	065b      	lsls	r3, r3, #25
    198c:	d504      	bpl.n	1998 <f_read+0x178>
    198e:	69a3      	ldr	r3, [r4, #24]
    1990:	465a      	mov	r2, fp
    1992:	1a98      	subs	r0, r3, r2
    1994:	4580      	cmp	r8, r0
    1996:	d884      	bhi.n	18a2 <f_read+0x82>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    1998:	4643      	mov	r3, r8
    199a:	025d      	lsls	r5, r3, #9
				continue;
    199c:	e7b8      	b.n	1910 <f_read+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    199e:	2301      	movs	r3, #1
    19a0:	71e3      	strb	r3, [r4, #7]
    19a2:	9301      	str	r3, [sp, #4]
    19a4:	e758      	b.n	1858 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    19a6:	2301      	movs	r3, #1
    19a8:	71e3      	strb	r3, [r4, #7]
    19aa:	9301      	str	r3, [sp, #4]
    19ac:	e754      	b.n	1858 <f_read+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    19ae:	9301      	str	r3, [sp, #4]
    19b0:	e752      	b.n	1858 <f_read+0x38>
    19b2:	46c0      	nop			; (mov r8, r8)
    19b4:	00000879 	.word	0x00000879
    19b8:	00000d9d 	.word	0x00000d9d
    19bc:	000006a1 	.word	0x000006a1
    19c0:	00000545 	.word	0x00000545
    19c4:	000004f9 	.word	0x000004f9
    19c8:	00000d85 	.word	0x00000d85

000019cc <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    19cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    19ce:	46de      	mov	lr, fp
    19d0:	4657      	mov	r7, sl
    19d2:	464e      	mov	r6, r9
    19d4:	4645      	mov	r5, r8
    19d6:	b5e0      	push	{r5, r6, r7, lr}
    19d8:	b083      	sub	sp, #12
    19da:	0004      	movs	r4, r0
    19dc:	000d      	movs	r5, r1
    19de:	0017      	movs	r7, r2
    19e0:	4699      	mov	r9, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    19e2:	2300      	movs	r3, #0
    19e4:	464a      	mov	r2, r9
    19e6:	6013      	str	r3, [r2, #0]

	res = validate(fp);						/* Check validity */
    19e8:	4b6f      	ldr	r3, [pc, #444]	; (1ba8 <f_write+0x1dc>)
    19ea:	4798      	blx	r3
    19ec:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    19ee:	2800      	cmp	r0, #0
    19f0:	d108      	bne.n	1a04 <f_write+0x38>
	if (fp->err)							/* Check error */
    19f2:	79e3      	ldrb	r3, [r4, #7]
    19f4:	2b00      	cmp	r3, #0
    19f6:	d000      	beq.n	19fa <f_write+0x2e>
    19f8:	e0d3      	b.n	1ba2 <f_write+0x1d6>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    19fa:	79a3      	ldrb	r3, [r4, #6]
    19fc:	079b      	lsls	r3, r3, #30
    19fe:	d409      	bmi.n	1a14 <f_write+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    1a00:	2307      	movs	r3, #7
    1a02:	9301      	str	r3, [sp, #4]

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    1a04:	9801      	ldr	r0, [sp, #4]
    1a06:	b003      	add	sp, #12
    1a08:	bc3c      	pop	{r2, r3, r4, r5}
    1a0a:	4690      	mov	r8, r2
    1a0c:	4699      	mov	r9, r3
    1a0e:	46a2      	mov	sl, r4
    1a10:	46ab      	mov	fp, r5
    1a12:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
    1a14:	68a3      	ldr	r3, [r4, #8]
    1a16:	19da      	adds	r2, r3, r7
    1a18:	4293      	cmp	r3, r2
    1a1a:	d80e      	bhi.n	1a3a <f_write+0x6e>
	for ( ;  btw;							/* Repeat until all data written */
    1a1c:	2f00      	cmp	r7, #0
    1a1e:	d00c      	beq.n	1a3a <f_write+0x6e>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    1a20:	002e      	movs	r6, r5
    1a22:	e06b      	b.n	1afc <f_write+0x130>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    1a24:	2100      	movs	r1, #0
    1a26:	4b61      	ldr	r3, [pc, #388]	; (1bac <f_write+0x1e0>)
    1a28:	4798      	blx	r3
    1a2a:	0003      	movs	r3, r0
    1a2c:	e003      	b.n	1a36 <f_write+0x6a>
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    1a2e:	6961      	ldr	r1, [r4, #20]
    1a30:	4b5e      	ldr	r3, [pc, #376]	; (1bac <f_write+0x1e0>)
    1a32:	4798      	blx	r3
    1a34:	0003      	movs	r3, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    1a36:	2b00      	cmp	r3, #0
    1a38:	d171      	bne.n	1b1e <f_write+0x152>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    1a3a:	68a3      	ldr	r3, [r4, #8]
    1a3c:	68e2      	ldr	r2, [r4, #12]
    1a3e:	4293      	cmp	r3, r2
    1a40:	d900      	bls.n	1a44 <f_write+0x78>
    1a42:	60e3      	str	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    1a44:	79a3      	ldrb	r3, [r4, #6]
    1a46:	2220      	movs	r2, #32
    1a48:	4313      	orrs	r3, r2
    1a4a:	71a3      	strb	r3, [r4, #6]
	LEAVE_FF(fp->fs, FR_OK);
    1a4c:	e7da      	b.n	1a04 <f_write+0x38>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    1a4e:	3301      	adds	r3, #1
    1a50:	71e3      	strb	r3, [r4, #7]
    1a52:	9301      	str	r3, [sp, #4]
    1a54:	e7d6      	b.n	1a04 <f_write+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    1a56:	3302      	adds	r3, #2
    1a58:	71e3      	strb	r3, [r4, #7]
    1a5a:	9301      	str	r3, [sp, #4]
    1a5c:	e7d2      	b.n	1a04 <f_write+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1a5e:	0021      	movs	r1, r4
    1a60:	3124      	adds	r1, #36	; 0x24
    1a62:	6823      	ldr	r3, [r4, #0]
    1a64:	7858      	ldrb	r0, [r3, #1]
    1a66:	2301      	movs	r3, #1
    1a68:	69a2      	ldr	r2, [r4, #24]
    1a6a:	4d51      	ldr	r5, [pc, #324]	; (1bb0 <f_write+0x1e4>)
    1a6c:	47a8      	blx	r5
    1a6e:	2800      	cmp	r0, #0
    1a70:	d104      	bne.n	1a7c <f_write+0xb0>
				fp->flag &= ~FA__DIRTY;
    1a72:	79a3      	ldrb	r3, [r4, #6]
    1a74:	2240      	movs	r2, #64	; 0x40
    1a76:	4393      	bics	r3, r2
    1a78:	71a3      	strb	r3, [r4, #6]
    1a7a:	e05c      	b.n	1b36 <f_write+0x16a>
					ABORT(fp->fs, FR_DISK_ERR);
    1a7c:	2301      	movs	r3, #1
    1a7e:	71e3      	strb	r3, [r4, #7]
    1a80:	9301      	str	r3, [sp, #4]
    1a82:	e7bf      	b.n	1a04 <f_write+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1a84:	2302      	movs	r3, #2
    1a86:	71e3      	strb	r3, [r4, #7]
    1a88:	9301      	str	r3, [sp, #4]
    1a8a:	e7bb      	b.n	1a04 <f_write+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    1a8c:	2301      	movs	r3, #1
    1a8e:	71e3      	strb	r3, [r4, #7]
    1a90:	9301      	str	r3, [sp, #4]
    1a92:	e7b7      	b.n	1a04 <f_write+0x38>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    1a94:	0240      	lsls	r0, r0, #9
    1a96:	1831      	adds	r1, r6, r0
    1a98:	0020      	movs	r0, r4
    1a9a:	3024      	adds	r0, #36	; 0x24
    1a9c:	2280      	movs	r2, #128	; 0x80
    1a9e:	0092      	lsls	r2, r2, #2
    1aa0:	4b44      	ldr	r3, [pc, #272]	; (1bb4 <f_write+0x1e8>)
    1aa2:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
    1aa4:	79a3      	ldrb	r3, [r4, #6]
    1aa6:	2240      	movs	r2, #64	; 0x40
    1aa8:	4393      	bics	r3, r2
    1aaa:	71a3      	strb	r3, [r4, #6]
    1aac:	e068      	b.n	1b80 <f_write+0x1b4>
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    1aae:	69a3      	ldr	r3, [r4, #24]
    1ab0:	4598      	cmp	r8, r3
    1ab2:	d003      	beq.n	1abc <f_write+0xf0>
				if (fp->fptr < fp->fsize &&
    1ab4:	68a3      	ldr	r3, [r4, #8]
    1ab6:	68e2      	ldr	r2, [r4, #12]
    1ab8:	4293      	cmp	r3, r2
    1aba:	d364      	bcc.n	1b86 <f_write+0x1ba>
			fp->dsect = sect;
    1abc:	4643      	mov	r3, r8
    1abe:	61a3      	str	r3, [r4, #24]
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    1ac0:	68a3      	ldr	r3, [r4, #8]
    1ac2:	05d8      	lsls	r0, r3, #23
    1ac4:	0dc0      	lsrs	r0, r0, #23
    1ac6:	2580      	movs	r5, #128	; 0x80
    1ac8:	00ad      	lsls	r5, r5, #2
    1aca:	1a2d      	subs	r5, r5, r0
    1acc:	42bd      	cmp	r5, r7
    1ace:	d900      	bls.n	1ad2 <f_write+0x106>
    1ad0:	003d      	movs	r5, r7
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    1ad2:	3024      	adds	r0, #36	; 0x24
    1ad4:	1820      	adds	r0, r4, r0
    1ad6:	002a      	movs	r2, r5
    1ad8:	0031      	movs	r1, r6
    1ada:	4b36      	ldr	r3, [pc, #216]	; (1bb4 <f_write+0x1e8>)
    1adc:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
    1ade:	79a3      	ldrb	r3, [r4, #6]
    1ae0:	2240      	movs	r2, #64	; 0x40
    1ae2:	4313      	orrs	r3, r2
    1ae4:	71a3      	strb	r3, [r4, #6]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    1ae6:	1976      	adds	r6, r6, r5
    1ae8:	68a3      	ldr	r3, [r4, #8]
    1aea:	195b      	adds	r3, r3, r5
    1aec:	60a3      	str	r3, [r4, #8]
    1aee:	464b      	mov	r3, r9
    1af0:	681b      	ldr	r3, [r3, #0]
    1af2:	195b      	adds	r3, r3, r5
    1af4:	464a      	mov	r2, r9
    1af6:	6013      	str	r3, [r2, #0]
    1af8:	1b7f      	subs	r7, r7, r5
	for ( ;  btw;							/* Repeat until all data written */
    1afa:	d09e      	beq.n	1a3a <f_write+0x6e>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    1afc:	68a3      	ldr	r3, [r4, #8]
    1afe:	05da      	lsls	r2, r3, #23
    1b00:	d1de      	bne.n	1ac0 <f_write+0xf4>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    1b02:	6820      	ldr	r0, [r4, #0]
    1b04:	7882      	ldrb	r2, [r0, #2]
    1b06:	3a01      	subs	r2, #1
    1b08:	0a5d      	lsrs	r5, r3, #9
    1b0a:	4015      	ands	r5, r2
    1b0c:	b2ea      	uxtb	r2, r5
    1b0e:	4693      	mov	fp, r2
			if (!csect) {					/* On the cluster boundary? */
    1b10:	2a00      	cmp	r2, #0
    1b12:	d10d      	bne.n	1b30 <f_write+0x164>
				if (fp->fptr == 0) {		/* On the top of the file? */
    1b14:	2b00      	cmp	r3, #0
    1b16:	d18a      	bne.n	1a2e <f_write+0x62>
					clst = fp->sclust;		/* Follow from the origin */
    1b18:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
    1b1a:	2b00      	cmp	r3, #0
    1b1c:	d082      	beq.n	1a24 <f_write+0x58>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    1b1e:	2b01      	cmp	r3, #1
    1b20:	d095      	beq.n	1a4e <f_write+0x82>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    1b22:	1c5a      	adds	r2, r3, #1
    1b24:	d097      	beq.n	1a56 <f_write+0x8a>
				fp->clust = clst;			/* Update current cluster */
    1b26:	6163      	str	r3, [r4, #20]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
    1b28:	6922      	ldr	r2, [r4, #16]
    1b2a:	2a00      	cmp	r2, #0
    1b2c:	d100      	bne.n	1b30 <f_write+0x164>
    1b2e:	6123      	str	r3, [r4, #16]
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    1b30:	79a3      	ldrb	r3, [r4, #6]
    1b32:	065b      	lsls	r3, r3, #25
    1b34:	d493      	bmi.n	1a5e <f_write+0x92>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    1b36:	6823      	ldr	r3, [r4, #0]
    1b38:	469a      	mov	sl, r3
    1b3a:	6961      	ldr	r1, [r4, #20]
    1b3c:	0018      	movs	r0, r3
    1b3e:	4b1e      	ldr	r3, [pc, #120]	; (1bb8 <f_write+0x1ec>)
    1b40:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1b42:	2800      	cmp	r0, #0
    1b44:	d09e      	beq.n	1a84 <f_write+0xb8>
			sect += csect;
    1b46:	4680      	mov	r8, r0
    1b48:	4658      	mov	r0, fp
    1b4a:	4684      	mov	ip, r0
    1b4c:	44d8      	add	r8, fp
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    1b4e:	0a7b      	lsrs	r3, r7, #9
    1b50:	469b      	mov	fp, r3
			if (cc) {						/* Write maximum contiguous sectors directly */
    1b52:	d0ac      	beq.n	1aae <f_write+0xe2>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    1b54:	4653      	mov	r3, sl
    1b56:	789b      	ldrb	r3, [r3, #2]
    1b58:	465a      	mov	r2, fp
    1b5a:	4462      	add	r2, ip
    1b5c:	429a      	cmp	r2, r3
    1b5e:	d901      	bls.n	1b64 <f_write+0x198>
					cc = fp->fs->csize - csect;
    1b60:	1a1b      	subs	r3, r3, r0
    1b62:	469b      	mov	fp, r3
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
    1b64:	4653      	mov	r3, sl
    1b66:	7858      	ldrb	r0, [r3, #1]
    1b68:	465b      	mov	r3, fp
    1b6a:	4642      	mov	r2, r8
    1b6c:	0031      	movs	r1, r6
    1b6e:	4d10      	ldr	r5, [pc, #64]	; (1bb0 <f_write+0x1e4>)
    1b70:	47a8      	blx	r5
    1b72:	2800      	cmp	r0, #0
    1b74:	d18a      	bne.n	1a8c <f_write+0xc0>
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    1b76:	69a3      	ldr	r3, [r4, #24]
    1b78:	4642      	mov	r2, r8
    1b7a:	1a98      	subs	r0, r3, r2
    1b7c:	4583      	cmp	fp, r0
    1b7e:	d889      	bhi.n	1a94 <f_write+0xc8>
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    1b80:	465b      	mov	r3, fp
    1b82:	025d      	lsls	r5, r3, #9
				continue;
    1b84:	e7af      	b.n	1ae6 <f_write+0x11a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    1b86:	0021      	movs	r1, r4
    1b88:	3124      	adds	r1, #36	; 0x24
    1b8a:	4653      	mov	r3, sl
    1b8c:	7858      	ldrb	r0, [r3, #1]
    1b8e:	2301      	movs	r3, #1
    1b90:	4642      	mov	r2, r8
    1b92:	4d0a      	ldr	r5, [pc, #40]	; (1bbc <f_write+0x1f0>)
    1b94:	47a8      	blx	r5
				if (fp->fptr < fp->fsize &&
    1b96:	2800      	cmp	r0, #0
    1b98:	d090      	beq.n	1abc <f_write+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    1b9a:	2001      	movs	r0, #1
    1b9c:	71e0      	strb	r0, [r4, #7]
    1b9e:	9001      	str	r0, [sp, #4]
    1ba0:	e730      	b.n	1a04 <f_write+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    1ba2:	9301      	str	r3, [sp, #4]
    1ba4:	e72e      	b.n	1a04 <f_write+0x38>
    1ba6:	46c0      	nop			; (mov r8, r8)
    1ba8:	00000879 	.word	0x00000879
    1bac:	00001091 	.word	0x00001091
    1bb0:	00000545 	.word	0x00000545
    1bb4:	000006a1 	.word	0x000006a1
    1bb8:	00000d85 	.word	0x00000d85
    1bbc:	000004f9 	.word	0x000004f9

00001bc0 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    1bc0:	b570      	push	{r4, r5, r6, lr}
    1bc2:	0004      	movs	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    1bc4:	4b26      	ldr	r3, [pc, #152]	; (1c60 <f_sync+0xa0>)
    1bc6:	4798      	blx	r3
	if (res == FR_OK) {
    1bc8:	2800      	cmp	r0, #0
    1bca:	d11a      	bne.n	1c02 <f_sync+0x42>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    1bcc:	79a3      	ldrb	r3, [r4, #6]
    1bce:	069a      	lsls	r2, r3, #26
    1bd0:	d517      	bpl.n	1c02 <f_sync+0x42>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
    1bd2:	065b      	lsls	r3, r3, #25
    1bd4:	d50f      	bpl.n	1bf6 <f_sync+0x36>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1bd6:	0021      	movs	r1, r4
    1bd8:	3124      	adds	r1, #36	; 0x24
    1bda:	6823      	ldr	r3, [r4, #0]
    1bdc:	7858      	ldrb	r0, [r3, #1]
    1bde:	2301      	movs	r3, #1
    1be0:	69a2      	ldr	r2, [r4, #24]
    1be2:	4d20      	ldr	r5, [pc, #128]	; (1c64 <f_sync+0xa4>)
    1be4:	47a8      	blx	r5
    1be6:	0003      	movs	r3, r0
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    1be8:	2001      	movs	r0, #1
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1bea:	2b00      	cmp	r3, #0
    1bec:	d109      	bne.n	1c02 <f_sync+0x42>
				fp->flag &= ~FA__DIRTY;
    1bee:	79a3      	ldrb	r3, [r4, #6]
    1bf0:	2240      	movs	r2, #64	; 0x40
    1bf2:	4393      	bics	r3, r2
    1bf4:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    1bf6:	69e1      	ldr	r1, [r4, #28]
    1bf8:	6820      	ldr	r0, [r4, #0]
    1bfa:	4b1b      	ldr	r3, [pc, #108]	; (1c68 <f_sync+0xa8>)
    1bfc:	4798      	blx	r3
			if (res == FR_OK) {
    1bfe:	2800      	cmp	r0, #0
    1c00:	d000      	beq.n	1c04 <f_sync+0x44>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    1c02:	bd70      	pop	{r4, r5, r6, pc}
				dir = fp->dir_ptr;
    1c04:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    1c06:	7aeb      	ldrb	r3, [r5, #11]
    1c08:	2220      	movs	r2, #32
    1c0a:	4313      	orrs	r3, r2
    1c0c:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
    1c0e:	7b23      	ldrb	r3, [r4, #12]
    1c10:	772b      	strb	r3, [r5, #28]
    1c12:	89a3      	ldrh	r3, [r4, #12]
    1c14:	0a1b      	lsrs	r3, r3, #8
    1c16:	776b      	strb	r3, [r5, #29]
    1c18:	89e3      	ldrh	r3, [r4, #14]
    1c1a:	77ab      	strb	r3, [r5, #30]
    1c1c:	7be3      	ldrb	r3, [r4, #15]
    1c1e:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
    1c20:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir + DIR_FstClusLO, cl);
    1c22:	76ab      	strb	r3, [r5, #26]
    1c24:	0a1a      	lsrs	r2, r3, #8
    1c26:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    1c28:	0c1b      	lsrs	r3, r3, #16
    1c2a:	752b      	strb	r3, [r5, #20]
    1c2c:	0a1b      	lsrs	r3, r3, #8
    1c2e:	756b      	strb	r3, [r5, #21]
				tm = GET_FATTIME();							/* Update updated time */
    1c30:	4b0e      	ldr	r3, [pc, #56]	; (1c6c <f_sync+0xac>)
    1c32:	4798      	blx	r3
				ST_DWORD(dir + DIR_WrtTime, tm);
    1c34:	75a8      	strb	r0, [r5, #22]
    1c36:	0a03      	lsrs	r3, r0, #8
    1c38:	75eb      	strb	r3, [r5, #23]
    1c3a:	0c03      	lsrs	r3, r0, #16
    1c3c:	762b      	strb	r3, [r5, #24]
    1c3e:	0e00      	lsrs	r0, r0, #24
    1c40:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
    1c42:	2300      	movs	r3, #0
    1c44:	74ab      	strb	r3, [r5, #18]
    1c46:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
    1c48:	79a3      	ldrb	r3, [r4, #6]
    1c4a:	2220      	movs	r2, #32
    1c4c:	4393      	bics	r3, r2
    1c4e:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    1c50:	2301      	movs	r3, #1
    1c52:	6822      	ldr	r2, [r4, #0]
    1c54:	7113      	strb	r3, [r2, #4]
				res = sync_fs(fp->fs);
    1c56:	6820      	ldr	r0, [r4, #0]
    1c58:	4b05      	ldr	r3, [pc, #20]	; (1c70 <f_sync+0xb0>)
    1c5a:	4798      	blx	r3
    1c5c:	e7d1      	b.n	1c02 <f_sync+0x42>
    1c5e:	46c0      	nop			; (mov r8, r8)
    1c60:	00000879 	.word	0x00000879
    1c64:	00000545 	.word	0x00000545
    1c68:	00000799 	.word	0x00000799
    1c6c:	0000069d 	.word	0x0000069d
    1c70:	00000c91 	.word	0x00000c91

00001c74 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    1c74:	b510      	push	{r4, lr}
    1c76:	0004      	movs	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
    1c78:	4b06      	ldr	r3, [pc, #24]	; (1c94 <f_close+0x20>)
    1c7a:	4798      	blx	r3
	if (res == FR_OK)
    1c7c:	2800      	cmp	r0, #0
    1c7e:	d000      	beq.n	1c82 <f_close+0xe>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
    1c80:	bd10      	pop	{r4, pc}
		res = validate(fp);				/* Lock volume */
    1c82:	0020      	movs	r0, r4
    1c84:	4b04      	ldr	r3, [pc, #16]	; (1c98 <f_close+0x24>)
    1c86:	4798      	blx	r3
		if (res == FR_OK) {
    1c88:	2800      	cmp	r0, #0
    1c8a:	d1f9      	bne.n	1c80 <f_close+0xc>
				fp->fs = 0;				/* Invalidate file object */
    1c8c:	2300      	movs	r3, #0
    1c8e:	6023      	str	r3, [r4, #0]
    1c90:	e7f6      	b.n	1c80 <f_close+0xc>
    1c92:	46c0      	nop			; (mov r8, r8)
    1c94:	00001bc1 	.word	0x00001bc1
    1c98:	00000879 	.word	0x00000879

00001c9c <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
    1c9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c9e:	b085      	sub	sp, #20
    1ca0:	9001      	str	r0, [sp, #4]
    1ca2:	9200      	str	r2, [sp, #0]
	int n = 0;
	TCHAR c, *p = buff;
    1ca4:	0007      	movs	r7, r0
	int n = 0;
    1ca6:	2400      	movs	r4, #0
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
    1ca8:	1e4d      	subs	r5, r1, #1
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
    1caa:	4e10      	ldr	r6, [pc, #64]	; (1cec <f_gets+0x50>)
	while (n < len - 1) {	/* Read characters until buffer gets filled */
    1cac:	42ac      	cmp	r4, r5
    1cae:	da13      	bge.n	1cd8 <f_gets+0x3c>
		f_read(fp, s, 1, &rc);
    1cb0:	ab02      	add	r3, sp, #8
    1cb2:	2201      	movs	r2, #1
    1cb4:	a903      	add	r1, sp, #12
    1cb6:	9800      	ldr	r0, [sp, #0]
    1cb8:	47b0      	blx	r6
		if (rc != 1) break;
    1cba:	9b02      	ldr	r3, [sp, #8]
    1cbc:	2b01      	cmp	r3, #1
    1cbe:	d10b      	bne.n	1cd8 <f_gets+0x3c>
		c = s[0];
    1cc0:	ab03      	add	r3, sp, #12
    1cc2:	781b      	ldrb	r3, [r3, #0]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
    1cc4:	2b0d      	cmp	r3, #13
    1cc6:	d0f1      	beq.n	1cac <f_gets+0x10>
		*p++ = c;
    1cc8:	1c7a      	adds	r2, r7, #1
    1cca:	703b      	strb	r3, [r7, #0]
		n++;
    1ccc:	3401      	adds	r4, #1
		if (c == '\n') break;		/* Break on EOL */
    1cce:	2b0a      	cmp	r3, #10
    1cd0:	d001      	beq.n	1cd6 <f_gets+0x3a>
		*p++ = c;
    1cd2:	0017      	movs	r7, r2
    1cd4:	e7ea      	b.n	1cac <f_gets+0x10>
    1cd6:	0017      	movs	r7, r2
	}
	*p = 0;
    1cd8:	2300      	movs	r3, #0
    1cda:	703b      	strb	r3, [r7, #0]
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
    1cdc:	1e63      	subs	r3, r4, #1
    1cde:	419c      	sbcs	r4, r3
    1ce0:	4264      	negs	r4, r4
    1ce2:	9b01      	ldr	r3, [sp, #4]
    1ce4:	4023      	ands	r3, r4
}
    1ce6:	0018      	movs	r0, r3
    1ce8:	b005      	add	sp, #20
    1cea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1cec:	00001821 	.word	0x00001821

00001cf0 <main>:
 *
 * Note:
 *
 ******************************************************************************/
int main(void)
{
    1cf0:	b510      	push	{r4, lr}
	// CMSIS compliant function not used
	//SystemInit();
	
	// Application hardware and software initialization 
	AppInit();
    1cf2:	4b02      	ldr	r3, [pc, #8]	; (1cfc <main+0xc>)
    1cf4:	4798      	blx	r3

	// Super loop
	while(1)
	{
		// Run your application
		AppRun();
    1cf6:	4c02      	ldr	r4, [pc, #8]	; (1d00 <main+0x10>)
    1cf8:	47a0      	blx	r4
    1cfa:	e7fd      	b.n	1cf8 <main+0x8>
    1cfc:	00000115 	.word	0x00000115
    1d00:	00000135 	.word	0x00000135

00001d04 <SDCard_WaitRead>:

/*-----------------------------------------------------------------------*/
/* Wait for SD Card to Read                                              */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WaitRead( void )
{
    1d04:	b570      	push	{r4, r5, r6, lr}
    1d06:	4c06      	ldr	r4, [pc, #24]	; (1d20 <SDCard_WaitRead+0x1c>)
	uint32_t cnt = 0x00FFFFF;
	uint8_t  res;
	
	do
	{
		res = SPI_SD_Send_Byte( 0xFF );
    1d08:	4d06      	ldr	r5, [pc, #24]	; (1d24 <SDCard_WaitRead+0x20>)
    1d0a:	20ff      	movs	r0, #255	; 0xff
    1d0c:	47a8      	blx	r5
		
		if ( res == 0xff ) //
    1d0e:	28ff      	cmp	r0, #255	; 0xff
    1d10:	d004      	beq.n	1d1c <SDCard_WaitRead+0x18>
    1d12:	3c01      	subs	r4, #1
		{
			return 0;
		}
		cnt--;

	} while ( cnt );
    1d14:	2c00      	cmp	r4, #0
    1d16:	d1f8      	bne.n	1d0a <SDCard_WaitRead+0x6>

	return 1;
    1d18:	2001      	movs	r0, #1
    1d1a:	e000      	b.n	1d1e <SDCard_WaitRead+0x1a>
			return 0;
    1d1c:	2000      	movs	r0, #0
} // SDCard_WaitRead()
    1d1e:	bd70      	pop	{r4, r5, r6, pc}
    1d20:	000fffff 	.word	0x000fffff
    1d24:	00002411 	.word	0x00002411

00001d28 <SDCard_WriteCmd>:

/*-----------------------------------------------------------------------*/
/* Write a command to the card                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteCmd(uint8_t cmd, uint32_t arg, uint8_t crc )
{
    1d28:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d2a:	b083      	sub	sp, #12
    1d2c:	0007      	movs	r7, r0
    1d2e:	000d      	movs	r5, r1
    1d30:	9201      	str	r2, [sp, #4]
		SPI_CS_HIGH();
    1d32:	4c19      	ldr	r4, [pc, #100]	; (1d98 <SDCard_WriteCmd+0x70>)
    1d34:	2680      	movs	r6, #128	; 0x80
    1d36:	0076      	lsls	r6, r6, #1
    1d38:	61a6      	str	r6, [r4, #24]
	uint16_t cnt = 512;
	uint8_t  res;

    // toggle line and transmit data
	SDCard_SS(1); 
    SPI_SD_Send_Byte( 0xFF); 
    1d3a:	20ff      	movs	r0, #255	; 0xff
    1d3c:	4b17      	ldr	r3, [pc, #92]	; (1d9c <SDCard_WriteCmd+0x74>)
    1d3e:	4798      	blx	r3
		SPI_CS_LOW();
    1d40:	6166      	str	r6, [r4, #20]
    1d42:	6166      	str	r6, [r4, #20]
	if ( SDCard_WaitRead() == 0 ) // ??SD/MMC??
    1d44:	4b16      	ldr	r3, [pc, #88]	; (1da0 <SDCard_WriteCmd+0x78>)
    1d46:	4798      	blx	r3
    1d48:	2800      	cmp	r0, #0
    1d4a:	d11c      	bne.n	1d86 <SDCard_WriteCmd+0x5e>
     if (SDCard_EnableSelect())              // Select the card and wait for ready except to stop multiple block read
     {
	  return 0xFF;
     } 
	
     SPI_SD_Send_Byte( cmd | 0x40 );          // start command and index
    1d4c:	2040      	movs	r0, #64	; 0x40
    1d4e:	4338      	orrs	r0, r7
    1d50:	4c12      	ldr	r4, [pc, #72]	; (1d9c <SDCard_WriteCmd+0x74>)
    1d52:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>24) );  // argument [31..24]
    1d54:	0e28      	lsrs	r0, r5, #24
    1d56:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>16) );  // argument [23..16]
    1d58:	0c28      	lsrs	r0, r5, #16
    1d5a:	b2c0      	uxtb	r0, r0
    1d5c:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>8) );   // argument [15..8]
    1d5e:	0a28      	lsrs	r0, r5, #8
    1d60:	b2c0      	uxtb	r0, r0
    1d62:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg) );      // argument [7..0]
    1d64:	b2e8      	uxtb	r0, r5
    1d66:	47a0      	blx	r4
     SPI_SD_Send_Byte( crc );                 // Send valid CRC and stop
    1d68:	9801      	ldr	r0, [sp, #4]
    1d6a:	47a0      	blx	r4
	 
	 do                                       // Wait for a valid response
	 {
		 res = SPI_SD_Send_Byte(0xFF);
    1d6c:	20ff      	movs	r0, #255	; 0xff
    1d6e:	47a0      	blx	r4
    1d70:	4c0c      	ldr	r4, [pc, #48]	; (1da4 <SDCard_WriteCmd+0x7c>)
    1d72:	4d0a      	ldr	r5, [pc, #40]	; (1d9c <SDCard_WriteCmd+0x74>)
		 cnt--;
	 } while ((cnt)&&(res==0xFF));
    1d74:	28ff      	cmp	r0, #255	; 0xff
    1d76:	d10c      	bne.n	1d92 <SDCard_WriteCmd+0x6a>
		 res = SPI_SD_Send_Byte(0xFF);
    1d78:	20ff      	movs	r0, #255	; 0xff
    1d7a:	47a8      	blx	r5
    1d7c:	3c01      	subs	r4, #1
    1d7e:	b2a4      	uxth	r4, r4
	 } while ((cnt)&&(res==0xFF));
    1d80:	2c00      	cmp	r4, #0
    1d82:	d1f7      	bne.n	1d74 <SDCard_WriteCmd+0x4c>
    1d84:	e005      	b.n	1d92 <SDCard_WriteCmd+0x6a>
		SPI_CS_HIGH();
    1d86:	0023      	movs	r3, r4
    1d88:	619e      	str	r6, [r3, #24]
	SPI_SD_Send_Byte(0xFF); 
    1d8a:	20ff      	movs	r0, #255	; 0xff
    1d8c:	4b03      	ldr	r3, [pc, #12]	; (1d9c <SDCard_WriteCmd+0x74>)
    1d8e:	4798      	blx	r3
	  return 0xFF;
    1d90:	20ff      	movs	r0, #255	; 0xff

 	 return res;                              // Return with a response value
} // SDCard_WriteCmd()
    1d92:	b003      	add	sp, #12
    1d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d96:	46c0      	nop			; (mov r8, r8)
    1d98:	41004400 	.word	0x41004400
    1d9c:	00002411 	.word	0x00002411
    1da0:	00001d05 	.word	0x00001d05
    1da4:	000001ff 	.word	0x000001ff

00001da8 <SDCard_Init>:
uint8_t SDCard_Init(void){
    1da8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SPI_Initialize_Slow();
    1daa:	4b4c      	ldr	r3, [pc, #304]	; (1edc <SDCard_Init+0x134>)
    1dac:	4798      	blx	r3
	delay_ms(100);
    1dae:	484c      	ldr	r0, [pc, #304]	; (1ee0 <SDCard_Init+0x138>)
    1db0:	4b4c      	ldr	r3, [pc, #304]	; (1ee4 <SDCard_Init+0x13c>)
    1db2:	4798      	blx	r3
    1db4:	240f      	movs	r4, #15
		SPI_SD_Send_Byte(0xFF);  // send dummy clocks
    1db6:	4d4c      	ldr	r5, [pc, #304]	; (1ee8 <SDCard_Init+0x140>)
    1db8:	20ff      	movs	r0, #255	; 0xff
    1dba:	47a8      	blx	r5
    1dbc:	3c01      	subs	r4, #1
    1dbe:	b2e4      	uxtb	r4, r4
	for (tvar=0; tvar<0x0F; tvar++)
    1dc0:	2c00      	cmp	r4, #0
    1dc2:	d1f9      	bne.n	1db8 <SDCard_Init+0x10>
		tmp_0 = SDCard_WriteCmd(CMD0,0x00,0x95);
    1dc4:	4d49      	ldr	r5, [pc, #292]	; (1eec <SDCard_Init+0x144>)
    1dc6:	4c4a      	ldr	r4, [pc, #296]	; (1ef0 <SDCard_Init+0x148>)
    1dc8:	2295      	movs	r2, #149	; 0x95
    1dca:	2100      	movs	r1, #0
    1dcc:	2040      	movs	r0, #64	; 0x40
    1dce:	47a8      	blx	r5
    1dd0:	7020      	strb	r0, [r4, #0]
		lvar++;
    1dd2:	7863      	ldrb	r3, [r4, #1]
    1dd4:	3301      	adds	r3, #1
    1dd6:	b2db      	uxtb	r3, r3
    1dd8:	7063      	strb	r3, [r4, #1]
    }   while ((tmp_0 != 1) && (lvar < 200)); 
    1dda:	2801      	cmp	r0, #1
    1ddc:	d001      	beq.n	1de2 <SDCard_Init+0x3a>
    1dde:	2bc7      	cmp	r3, #199	; 0xc7
    1de0:	d9f2      	bls.n	1dc8 <SDCard_Init+0x20>
	if(lvar == 0)
    1de2:	2b00      	cmp	r3, #0
    1de4:	d016      	beq.n	1e14 <SDCard_Init+0x6c>
    tmp_8 = SDCard_WriteCmd(CMD8,0x1AA,0x87);
    1de6:	2287      	movs	r2, #135	; 0x87
    1de8:	21d5      	movs	r1, #213	; 0xd5
    1dea:	0049      	lsls	r1, r1, #1
    1dec:	2048      	movs	r0, #72	; 0x48
    1dee:	4b3f      	ldr	r3, [pc, #252]	; (1eec <SDCard_Init+0x144>)
    1df0:	4798      	blx	r3
    1df2:	0006      	movs	r6, r0
    1df4:	4b3e      	ldr	r3, [pc, #248]	; (1ef0 <SDCard_Init+0x148>)
    1df6:	7098      	strb	r0, [r3, #2]
    if(tmp_8 == 1)
    1df8:	2801      	cmp	r0, #1
    1dfa:	d017      	beq.n	1e2c <SDCard_Init+0x84>
			UART3_Write_Text("Initialization Complete \n");
    1dfc:	483d      	ldr	r0, [pc, #244]	; (1ef4 <SDCard_Init+0x14c>)
    1dfe:	4b3e      	ldr	r3, [pc, #248]	; (1ef8 <SDCard_Init+0x150>)
    1e00:	4798      	blx	r3
	SPI_Initialize_Fast();
    1e02:	4b3e      	ldr	r3, [pc, #248]	; (1efc <SDCard_Init+0x154>)
    1e04:	4798      	blx	r3
		SPI_CS_HIGH();
    1e06:	2280      	movs	r2, #128	; 0x80
    1e08:	0052      	lsls	r2, r2, #1
    1e0a:	4b3d      	ldr	r3, [pc, #244]	; (1f00 <SDCard_Init+0x158>)
    1e0c:	619a      	str	r2, [r3, #24]
			return 0;
    1e0e:	2600      	movs	r6, #0
}// SDCard_Init()
    1e10:	0030      	movs	r0, r6
    1e12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		SPI_CS_HIGH();
    1e14:	2280      	movs	r2, #128	; 0x80
    1e16:	0052      	lsls	r2, r2, #1
    1e18:	4b39      	ldr	r3, [pc, #228]	; (1f00 <SDCard_Init+0x158>)
    1e1a:	619a      	str	r2, [r3, #24]
		SPI_SD_Send_Byte(0xFF);
    1e1c:	20ff      	movs	r0, #255	; 0xff
    1e1e:	4b32      	ldr	r3, [pc, #200]	; (1ee8 <SDCard_Init+0x140>)
    1e20:	4798      	blx	r3
		UART3_Write_Text("Faile to reset card");
    1e22:	4838      	ldr	r0, [pc, #224]	; (1f04 <SDCard_Init+0x15c>)
    1e24:	4b34      	ldr	r3, [pc, #208]	; (1ef8 <SDCard_Init+0x150>)
    1e26:	4798      	blx	r3
		return 1;
    1e28:	2601      	movs	r6, #1
    1e2a:	e7f1      	b.n	1e10 <SDCard_Init+0x68>
    1e2c:	4c36      	ldr	r4, [pc, #216]	; (1f08 <SDCard_Init+0x160>)
		 		  tmp_55 = SDCard_WriteCmd( CMD55, 0, 0xff );
    1e2e:	4d2f      	ldr	r5, [pc, #188]	; (1eec <SDCard_Init+0x144>)
    1e30:	001f      	movs	r7, r3
    1e32:	22ff      	movs	r2, #255	; 0xff
    1e34:	2100      	movs	r1, #0
    1e36:	2077      	movs	r0, #119	; 0x77
    1e38:	47a8      	blx	r5
    1e3a:	70f8      	strb	r0, [r7, #3]
		 		  tmp_41 = SDCard_WriteCmd( CMD41,0x40000000, 0xff);//CMD41
    1e3c:	22ff      	movs	r2, #255	; 0xff
    1e3e:	2180      	movs	r1, #128	; 0x80
    1e40:	05c9      	lsls	r1, r1, #23
    1e42:	2069      	movs	r0, #105	; 0x69
    1e44:	47a8      	blx	r5
    1e46:	7138      	strb	r0, [r7, #4]
		 	   } while ((tmp_41) && (cnt));
    1e48:	2800      	cmp	r0, #0
    1e4a:	d003      	beq.n	1e54 <SDCard_Init+0xac>
    1e4c:	3c01      	subs	r4, #1
    1e4e:	b2a4      	uxth	r4, r4
    1e50:	2c00      	cmp	r4, #0
    1e52:	d1ee      	bne.n	1e32 <SDCard_Init+0x8a>
		 	        tmp_1 = SDCard_WriteCmd(CMD1,0, 0xff);
    1e54:	22ff      	movs	r2, #255	; 0xff
    1e56:	2100      	movs	r1, #0
    1e58:	2041      	movs	r0, #65	; 0x41
    1e5a:	4d24      	ldr	r5, [pc, #144]	; (1eec <SDCard_Init+0x144>)
    1e5c:	47a8      	blx	r5
    1e5e:	4c24      	ldr	r4, [pc, #144]	; (1ef0 <SDCard_Init+0x148>)
    1e60:	7160      	strb	r0, [r4, #5]
				   tmp_58 = SDCard_WriteCmd(CMD58, 0, 0);
    1e62:	2200      	movs	r2, #0
    1e64:	2100      	movs	r1, #0
    1e66:	207a      	movs	r0, #122	; 0x7a
    1e68:	47a8      	blx	r5
    1e6a:	71a0      	strb	r0, [r4, #6]
    1e6c:	2400      	movs	r4, #0
				   if ( tmp_58 != 0x00 )
    1e6e:	2800      	cmp	r0, #0
    1e70:	d125      	bne.n	1ebe <SDCard_Init+0x116>
					 dataBuff[tvar] = SPI_SD_Read_Byte();
    1e72:	4e26      	ldr	r6, [pc, #152]	; (1f0c <SDCard_Init+0x164>)
    1e74:	4d26      	ldr	r5, [pc, #152]	; (1f10 <SDCard_Init+0x168>)
    1e76:	47b0      	blx	r6
    1e78:	5528      	strb	r0, [r5, r4]
    1e7a:	3401      	adds	r4, #1
				   for ( tvar = 0; tvar < 4; tvar++ )
    1e7c:	2c04      	cmp	r4, #4
    1e7e:	d1fa      	bne.n	1e76 <SDCard_Init+0xce>
		SPI_CS_HIGH();
    1e80:	2280      	movs	r2, #128	; 0x80
    1e82:	0052      	lsls	r2, r2, #1
    1e84:	4b1e      	ldr	r3, [pc, #120]	; (1f00 <SDCard_Init+0x158>)
    1e86:	619a      	str	r2, [r3, #24]
		 	       if ( dataBuff[0] & 0x40 )
    1e88:	4b21      	ldr	r3, [pc, #132]	; (1f10 <SDCard_Init+0x168>)
    1e8a:	781b      	ldrb	r3, [r3, #0]
    1e8c:	065b      	lsls	r3, r3, #25
    1e8e:	d51e      	bpl.n	1ece <SDCard_Init+0x126>
		 		      SD_Type = SD_TYPE_V2HC;
    1e90:	3afc      	subs	r2, #252	; 0xfc
    1e92:	4b17      	ldr	r3, [pc, #92]	; (1ef0 <SDCard_Init+0x148>)
    1e94:	71da      	strb	r2, [r3, #7]
		 		      UART3_Write_Text( "Card: V2.0 SDHC\n");
    1e96:	481f      	ldr	r0, [pc, #124]	; (1f14 <SDCard_Init+0x16c>)
    1e98:	4b17      	ldr	r3, [pc, #92]	; (1ef8 <SDCard_Init+0x150>)
    1e9a:	4798      	blx	r3
		 	       while(SDCard_WriteCmd(CMD16,512,0xff) != 0)
    1e9c:	2580      	movs	r5, #128	; 0x80
    1e9e:	00ad      	lsls	r5, r5, #2
    1ea0:	4c12      	ldr	r4, [pc, #72]	; (1eec <SDCard_Init+0x144>)
    1ea2:	22ff      	movs	r2, #255	; 0xff
    1ea4:	0029      	movs	r1, r5
    1ea6:	2050      	movs	r0, #80	; 0x50
    1ea8:	47a0      	blx	r4
    1eaa:	2800      	cmp	r0, #0
    1eac:	d1f9      	bne.n	1ea2 <SDCard_Init+0xfa>
			      tmp_9 = SDCard_WriteCmd(CMD9,0,0xff);
    1eae:	22ff      	movs	r2, #255	; 0xff
    1eb0:	2100      	movs	r1, #0
    1eb2:	3049      	adds	r0, #73	; 0x49
    1eb4:	4b0d      	ldr	r3, [pc, #52]	; (1eec <SDCard_Init+0x144>)
    1eb6:	4798      	blx	r3
    1eb8:	4b0d      	ldr	r3, [pc, #52]	; (1ef0 <SDCard_Init+0x148>)
    1eba:	7218      	strb	r0, [r3, #8]
    1ebc:	e79e      	b.n	1dfc <SDCard_Init+0x54>
		SPI_CS_HIGH();
    1ebe:	2280      	movs	r2, #128	; 0x80
    1ec0:	0052      	lsls	r2, r2, #1
    1ec2:	4b0f      	ldr	r3, [pc, #60]	; (1f00 <SDCard_Init+0x158>)
    1ec4:	619a      	str	r2, [r3, #24]
					   UART3_Write_Text( "Problem taking OCR data\n");
    1ec6:	4814      	ldr	r0, [pc, #80]	; (1f18 <SDCard_Init+0x170>)
    1ec8:	4b0b      	ldr	r3, [pc, #44]	; (1ef8 <SDCard_Init+0x150>)
    1eca:	4798      	blx	r3
					   return 1;
    1ecc:	e7a0      	b.n	1e10 <SDCard_Init+0x68>
		 		      SD_Type = SD_TYPE_V2;
    1ece:	2202      	movs	r2, #2
    1ed0:	4b07      	ldr	r3, [pc, #28]	; (1ef0 <SDCard_Init+0x148>)
    1ed2:	71da      	strb	r2, [r3, #7]
		 		      UART3_Write_Text( "Card Type: V2.0\n");
    1ed4:	4811      	ldr	r0, [pc, #68]	; (1f1c <SDCard_Init+0x174>)
    1ed6:	4b08      	ldr	r3, [pc, #32]	; (1ef8 <SDCard_Init+0x150>)
    1ed8:	4798      	blx	r3
    1eda:	e7df      	b.n	1e9c <SDCard_Init+0xf4>
    1edc:	0000234d 	.word	0x0000234d
    1ee0:	000a7693 	.word	0x000a7693
    1ee4:	000003e5 	.word	0x000003e5
    1ee8:	00002411 	.word	0x00002411
    1eec:	00001d29 	.word	0x00001d29
    1ef0:	2000045e 	.word	0x2000045e
    1ef4:	00002be4 	.word	0x00002be4
    1ef8:	000024ed 	.word	0x000024ed
    1efc:	000022a9 	.word	0x000022a9
    1f00:	41004400 	.word	0x41004400
    1f04:	00002b8c 	.word	0x00002b8c
    1f08:	0000ffff 	.word	0x0000ffff
    1f0c:	0000241d 	.word	0x0000241d
    1f10:	200008c8 	.word	0x200008c8
    1f14:	00002bbc 	.word	0x00002bbc
    1f18:	00002ba0 	.word	0x00002ba0
    1f1c:	00002bd0 	.word	0x00002bd0

00001f20 <SDCard_CardID>:

/*-----------------------------------------------------------------------*/
/* Get the SD Card ID                                                    */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_CardID(uint8_t cmd, uint8_t *buf)
{
    1f20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1f22:	000d      	movs	r5, r1
	uint8_t i;

	if (SDCard_WriteCmd(cmd,0x00,0xFF) != 0x00)
    1f24:	22ff      	movs	r2, #255	; 0xff
    1f26:	2100      	movs	r1, #0
    1f28:	4b08      	ldr	r3, [pc, #32]	; (1f4c <SDCard_CardID+0x2c>)
    1f2a:	4798      	blx	r3
    1f2c:	1e06      	subs	r6, r0, #0
    1f2e:	d10a      	bne.n	1f46 <SDCard_CardID+0x26>
    1f30:	002c      	movs	r4, r5
    1f32:	3510      	adds	r5, #16
	    return 1;                                    
	}

	for (i=0; i<16; i++)
	{
	    *buf++ = SPI_SD_Send_Byte(0xFF);
    1f34:	4f06      	ldr	r7, [pc, #24]	; (1f50 <SDCard_CardID+0x30>)
    1f36:	20ff      	movs	r0, #255	; 0xff
    1f38:	47b8      	blx	r7
    1f3a:	7020      	strb	r0, [r4, #0]
    1f3c:	3401      	adds	r4, #1
	for (i=0; i<16; i++)
    1f3e:	42a5      	cmp	r5, r4
    1f40:	d1f9      	bne.n	1f36 <SDCard_CardID+0x16>
	}

	return 0;                                        
}
    1f42:	0030      	movs	r0, r6
    1f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    return 1;                                    
    1f46:	2601      	movs	r6, #1
    1f48:	e7fb      	b.n	1f42 <SDCard_CardID+0x22>
    1f4a:	46c0      	nop			; (mov r8, r8)
    1f4c:	00001d29 	.word	0x00001d29
    1f50:	00002411 	.word	0x00002411

00001f54 <SDCard_ReadSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Read a single block of Data                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadSingleBlock(uint32_t addr, uint8_t *buf)
{
    1f54:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f56:	b083      	sub	sp, #12
    1f58:	0004      	movs	r4, r0
    1f5a:	9101      	str	r1, [sp, #4]
		uint16_t i;
	   
		if(SD_Type!=SD_TYPE_V2HC)
    1f5c:	4b24      	ldr	r3, [pc, #144]	; (1ff0 <SDCard_ReadSingleBlock+0x9c>)
    1f5e:	79db      	ldrb	r3, [r3, #7]
    1f60:	2b04      	cmp	r3, #4
    1f62:	d003      	beq.n	1f6c <SDCard_ReadSingleBlock+0x18>
		{
			UART3_Write_Text("Not SD_TYPE_V2HC\n");
    1f64:	4823      	ldr	r0, [pc, #140]	; (1ff4 <SDCard_ReadSingleBlock+0xa0>)
    1f66:	4b24      	ldr	r3, [pc, #144]	; (1ff8 <SDCard_ReadSingleBlock+0xa4>)
    1f68:	4798      	blx	r3
			  addr= addr<<9;
    1f6a:	0264      	lsls	r4, r4, #9
		}
		
		//////////////////////////
		// read a block address
		//////////////////////////
		tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1f6c:	2201      	movs	r2, #1
    1f6e:	0021      	movs	r1, r4
    1f70:	2051      	movs	r0, #81	; 0x51
    1f72:	4b22      	ldr	r3, [pc, #136]	; (1ffc <SDCard_ReadSingleBlock+0xa8>)
    1f74:	4798      	blx	r3
    1f76:	4b1e      	ldr	r3, [pc, #120]	; (1ff0 <SDCard_ReadSingleBlock+0x9c>)
    1f78:	7258      	strb	r0, [r3, #9]
		
		while(tmp17 !=0)
    1f7a:	2800      	cmp	r0, #0
    1f7c:	d00c      	beq.n	1f98 <SDCard_ReadSingleBlock+0x44>
		{
			UART3_Write_Text("Read block address\n");
    1f7e:	4e20      	ldr	r6, [pc, #128]	; (2000 <STACK_SIZE>)
    1f80:	4d1d      	ldr	r5, [pc, #116]	; (1ff8 <SDCard_ReadSingleBlock+0xa4>)
			
			tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1f82:	4f1e      	ldr	r7, [pc, #120]	; (1ffc <SDCard_ReadSingleBlock+0xa8>)
			UART3_Write_Text("Read block address\n");
    1f84:	0030      	movs	r0, r6
    1f86:	47a8      	blx	r5
			tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1f88:	2201      	movs	r2, #1
    1f8a:	0021      	movs	r1, r4
    1f8c:	2051      	movs	r0, #81	; 0x51
    1f8e:	47b8      	blx	r7
    1f90:	4b17      	ldr	r3, [pc, #92]	; (1ff0 <SDCard_ReadSingleBlock+0x9c>)
    1f92:	7258      	strb	r0, [r3, #9]
		while(tmp17 !=0)
    1f94:	2800      	cmp	r0, #0
    1f96:	d1f5      	bne.n	1f84 <SDCard_ReadSingleBlock+0x30>
		}
		delay_ms(1);
    1f98:	481a      	ldr	r0, [pc, #104]	; (2004 <STACK_SIZE+0x4>)
    1f9a:	4b1b      	ldr	r3, [pc, #108]	; (2008 <STACK_SIZE+0x8>)
    1f9c:	4798      	blx	r3

    
		while (SPI_SD_Read_Byte() != 0xFE)
    1f9e:	4c1b      	ldr	r4, [pc, #108]	; (200c <STACK_SIZE+0xc>)
    1fa0:	47a0      	blx	r4
    1fa2:	28fe      	cmp	r0, #254	; 0xfe
    1fa4:	d1fc      	bne.n	1fa0 <SDCard_ReadSingleBlock+0x4c>
		{
			
		}

		if(tmp17 == 0)
    1fa6:	4b12      	ldr	r3, [pc, #72]	; (1ff0 <SDCard_ReadSingleBlock+0x9c>)
    1fa8:	7a5b      	ldrb	r3, [r3, #9]
    1faa:	2b00      	cmp	r3, #0
    1fac:	d00e      	beq.n	1fcc <SDCard_ReadSingleBlock+0x78>
			  buf[i] = SPI_SD_Send_Byte(0xFF); 
		   }
		}
		
		// Done reading
		UART3_Write_Text("Read complete\n");
    1fae:	4818      	ldr	r0, [pc, #96]	; (2010 <STACK_SIZE+0x10>)
    1fb0:	4b11      	ldr	r3, [pc, #68]	; (1ff8 <SDCard_ReadSingleBlock+0xa4>)
    1fb2:	4798      	blx	r3
		SPI_SD_Send_Byte(0xFF);
    1fb4:	20ff      	movs	r0, #255	; 0xff
    1fb6:	4c17      	ldr	r4, [pc, #92]	; (2014 <STACK_SIZE+0x14>)
    1fb8:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    1fba:	20ff      	movs	r0, #255	; 0xff
    1fbc:	47a0      	blx	r4
		SPI_CS_HIGH();
    1fbe:	2280      	movs	r2, #128	; 0x80
    1fc0:	0052      	lsls	r2, r2, #1
    1fc2:	4b15      	ldr	r3, [pc, #84]	; (2018 <STACK_SIZE+0x18>)
    1fc4:	619a      	str	r2, [r3, #24]
		SDCard_SS(1);
		return 0;
}
    1fc6:	2000      	movs	r0, #0
    1fc8:	b003      	add	sp, #12
    1fca:	bdf0      	pop	{r4, r5, r6, r7, pc}
	       UART3_Write_Text("Reading\n");
    1fcc:	4813      	ldr	r0, [pc, #76]	; (201c <STACK_SIZE+0x1c>)
    1fce:	4b0a      	ldr	r3, [pc, #40]	; (1ff8 <SDCard_ReadSingleBlock+0xa4>)
    1fd0:	4798      	blx	r3
    1fd2:	9b01      	ldr	r3, [sp, #4]
    1fd4:	001c      	movs	r4, r3
    1fd6:	2280      	movs	r2, #128	; 0x80
    1fd8:	0092      	lsls	r2, r2, #2
    1fda:	4694      	mov	ip, r2
    1fdc:	4463      	add	r3, ip
    1fde:	001d      	movs	r5, r3
			  buf[i] = SPI_SD_Send_Byte(0xFF); 
    1fe0:	4e0c      	ldr	r6, [pc, #48]	; (2014 <STACK_SIZE+0x14>)
    1fe2:	20ff      	movs	r0, #255	; 0xff
    1fe4:	47b0      	blx	r6
    1fe6:	7020      	strb	r0, [r4, #0]
    1fe8:	3401      	adds	r4, #1
		   for (i=0; i<512; i++)
    1fea:	42ac      	cmp	r4, r5
    1fec:	d1f9      	bne.n	1fe2 <SDCard_ReadSingleBlock+0x8e>
    1fee:	e7de      	b.n	1fae <SDCard_ReadSingleBlock+0x5a>
    1ff0:	2000045e 	.word	0x2000045e
    1ff4:	00002c00 	.word	0x00002c00
    1ff8:	000024ed 	.word	0x000024ed
    1ffc:	00001d29 	.word	0x00001d29
    2000:	00002c14 	.word	0x00002c14
    2004:	00001aca 	.word	0x00001aca
    2008:	000003e5 	.word	0x000003e5
    200c:	0000241d 	.word	0x0000241d
    2010:	00002c34 	.word	0x00002c34
    2014:	00002411 	.word	0x00002411
    2018:	41004400 	.word	0x41004400
    201c:	00002c28 	.word	0x00002c28

00002020 <SDCard_ReadMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Read multiple blocks of Data                                          */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadMultipleBlock(uint32_t addr,uint8_t *buf,uint8_t count)
{
    2020:	b5f0      	push	{r4, r5, r6, r7, lr}
    2022:	46d6      	mov	lr, sl
    2024:	464f      	mov	r7, r9
    2026:	4646      	mov	r6, r8
    2028:	b5c0      	push	{r6, r7, lr}
    202a:	4689      	mov	r9, r1
    202c:	4690      	mov	r8, r2
	uint16_t i;
	
	//////////////////////////////////
	// Read Multiple Block Addresses
	/////////////////////////////////
	if(SD_Type!=SD_TYPE_V2HC)
    202e:	4b21      	ldr	r3, [pc, #132]	; (20b4 <SDCard_ReadMultipleBlock+0x94>)
    2030:	79db      	ldrb	r3, [r3, #7]
    2032:	2b04      	cmp	r3, #4
    2034:	d000      	beq.n	2038 <SDCard_ReadMultipleBlock+0x18>
	{
		addr = addr<<9;
    2036:	0240      	lsls	r0, r0, #9
	}
 
    // keep transferring data until interrupted
	// by stop transmission command
	if (SDCard_WriteCmd(CMD18,addr,0xFF) != 0x00)
    2038:	22ff      	movs	r2, #255	; 0xff
    203a:	0001      	movs	r1, r0
    203c:	2052      	movs	r0, #82	; 0x52
    203e:	4b1e      	ldr	r3, [pc, #120]	; (20b8 <SDCard_ReadMultipleBlock+0x98>)
    2040:	4798      	blx	r3
	{
		return 1;
    2042:	2301      	movs	r3, #1
	if (SDCard_WriteCmd(CMD18,addr,0xFF) != 0x00)
    2044:	2800      	cmp	r0, #0
    2046:	d005      	beq.n	2054 <SDCard_ReadMultipleBlock+0x34>
	
	// Force stop transmission after multiple block read 
	SDCard_WriteCmd(CMD12,0x00,0xFF);
	SPI_SD_Send_Byte(0xFF);
	return 0;
}
    2048:	0018      	movs	r0, r3
    204a:	bc1c      	pop	{r2, r3, r4}
    204c:	4690      	mov	r8, r2
    204e:	4699      	mov	r9, r3
    2050:	46a2      	mov	sl, r4
    2052:	bdf0      	pop	{r4, r5, r6, r7, pc}
		SPI_CS_LOW();
    2054:	2280      	movs	r2, #128	; 0x80
    2056:	0052      	lsls	r2, r2, #1
    2058:	4b18      	ldr	r3, [pc, #96]	; (20bc <SDCard_ReadMultipleBlock+0x9c>)
    205a:	615a      	str	r2, [r3, #20]
		while(SPI_SD_Send_Byte(0xFF) != 0xFE){;}
    205c:	4f18      	ldr	r7, [pc, #96]	; (20c0 <SDCard_ReadMultipleBlock+0xa0>)
			*buf++ = SPI_SD_Send_Byte(0xFF);
    205e:	003e      	movs	r6, r7
		SPI_SD_Send_Byte(0xFF);
    2060:	46ba      	mov	sl, r7
		while(SPI_SD_Send_Byte(0xFF) != 0xFE){;}
    2062:	20ff      	movs	r0, #255	; 0xff
    2064:	47b8      	blx	r7
    2066:	28fe      	cmp	r0, #254	; 0xfe
    2068:	d1fb      	bne.n	2062 <SDCard_ReadMultipleBlock+0x42>
    206a:	464c      	mov	r4, r9
    206c:	2380      	movs	r3, #128	; 0x80
    206e:	009b      	lsls	r3, r3, #2
    2070:	469c      	mov	ip, r3
    2072:	44e1      	add	r9, ip
    2074:	464d      	mov	r5, r9
			*buf++ = SPI_SD_Send_Byte(0xFF);
    2076:	20ff      	movs	r0, #255	; 0xff
    2078:	47b0      	blx	r6
    207a:	7020      	strb	r0, [r4, #0]
    207c:	3401      	adds	r4, #1
		for (i=0; i<512; i++)
    207e:	42a5      	cmp	r5, r4
    2080:	d1f9      	bne.n	2076 <SDCard_ReadMultipleBlock+0x56>
		SPI_SD_Send_Byte(0xFF);
    2082:	20ff      	movs	r0, #255	; 0xff
    2084:	47d0      	blx	sl
		SPI_SD_Send_Byte(0xFF);
    2086:	20ff      	movs	r0, #255	; 0xff
    2088:	47d0      	blx	sl
	}while (--count);
    208a:	4643      	mov	r3, r8
    208c:	3b01      	subs	r3, #1
    208e:	b2db      	uxtb	r3, r3
    2090:	4698      	mov	r8, r3
    2092:	2b00      	cmp	r3, #0
    2094:	d1e5      	bne.n	2062 <SDCard_ReadMultipleBlock+0x42>
		SPI_CS_HIGH();
    2096:	2280      	movs	r2, #128	; 0x80
    2098:	0052      	lsls	r2, r2, #1
    209a:	4b08      	ldr	r3, [pc, #32]	; (20bc <SDCard_ReadMultipleBlock+0x9c>)
    209c:	619a      	str	r2, [r3, #24]
	SDCard_WriteCmd(CMD12,0x00,0xFF);
    209e:	3a01      	subs	r2, #1
    20a0:	2100      	movs	r1, #0
    20a2:	204c      	movs	r0, #76	; 0x4c
    20a4:	4b04      	ldr	r3, [pc, #16]	; (20b8 <SDCard_ReadMultipleBlock+0x98>)
    20a6:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    20a8:	20ff      	movs	r0, #255	; 0xff
    20aa:	4b05      	ldr	r3, [pc, #20]	; (20c0 <SDCard_ReadMultipleBlock+0xa0>)
    20ac:	4798      	blx	r3
	return 0;
    20ae:	4643      	mov	r3, r8
    20b0:	e7ca      	b.n	2048 <SDCard_ReadMultipleBlock+0x28>
    20b2:	46c0      	nop			; (mov r8, r8)
    20b4:	2000045e 	.word	0x2000045e
    20b8:	00001d29 	.word	0x00001d29
    20bc:	41004400 	.word	0x41004400
    20c0:	00002411 	.word	0x00002411

000020c4 <SDCard_WriteSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Single Block of Data                                            */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteSingleBlock(uint32_t addr,const uint8_t *buf)
{
    20c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20c6:	0004      	movs	r4, r0
    20c8:	000d      	movs	r5, r1
		uint16_t i;

        //////////////////////////////////
        // Write Single Block Address
        /////////////////////////////////
        if(SD_Type!=SD_TYPE_V2HC)
    20ca:	4b2f      	ldr	r3, [pc, #188]	; (2188 <SDCard_WriteSingleBlock+0xc4>)
    20cc:	79db      	ldrb	r3, [r3, #7]
    20ce:	2b04      	cmp	r3, #4
    20d0:	d000      	beq.n	20d4 <SDCard_WriteSingleBlock+0x10>
        {
             addr=addr<<9 ;
    20d2:	0244      	lsls	r4, r0, #9
        }

        tmp_24 = SDCard_WriteCmd(CMD24,addr,0x01);
    20d4:	2201      	movs	r2, #1
    20d6:	0021      	movs	r1, r4
    20d8:	2058      	movs	r0, #88	; 0x58
    20da:	4b2c      	ldr	r3, [pc, #176]	; (218c <SDCard_WriteSingleBlock+0xc8>)
    20dc:	4798      	blx	r3
    20de:	4b2a      	ldr	r3, [pc, #168]	; (2188 <SDCard_WriteSingleBlock+0xc4>)
    20e0:	7298      	strb	r0, [r3, #10]
		
		
        while(tmp_24 != 0)
    20e2:	2800      	cmp	r0, #0
    20e4:	d008      	beq.n	20f8 <SDCard_WriteSingleBlock+0x34>
		{
        	tmp_24 = SDCard_WriteCmd(CMD24,addr,0x01);
    20e6:	4f29      	ldr	r7, [pc, #164]	; (218c <SDCard_WriteSingleBlock+0xc8>)
    20e8:	001e      	movs	r6, r3
    20ea:	2201      	movs	r2, #1
    20ec:	0021      	movs	r1, r4
    20ee:	2058      	movs	r0, #88	; 0x58
    20f0:	47b8      	blx	r7
    20f2:	72b0      	strb	r0, [r6, #10]
        while(tmp_24 != 0)
    20f4:	2800      	cmp	r0, #0
    20f6:	d1f8      	bne.n	20ea <SDCard_WriteSingleBlock+0x26>
		SPI_CS_LOW();
    20f8:	2280      	movs	r2, #128	; 0x80
    20fa:	0052      	lsls	r2, r2, #1
    20fc:	4b24      	ldr	r3, [pc, #144]	; (2190 <SDCard_WriteSingleBlock+0xcc>)
    20fe:	615a      	str	r2, [r3, #20]
        }

        SDCard_SS(0);
		
		//Wait until SD Card is ready
		SPI_SD_Send_Byte(0xFF);
    2100:	20ff      	movs	r0, #255	; 0xff
    2102:	4c24      	ldr	r4, [pc, #144]	; (2194 <SDCard_WriteSingleBlock+0xd0>)
    2104:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    2106:	20ff      	movs	r0, #255	; 0xff
    2108:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    210a:	20ff      	movs	r0, #255	; 0xff
    210c:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFE);
    210e:	20fe      	movs	r0, #254	; 0xfe
    2110:	47a0      	blx	r4
    2112:	002c      	movs	r4, r5
    2114:	2380      	movs	r3, #128	; 0x80
    2116:	009b      	lsls	r3, r3, #2
    2118:	469c      	mov	ip, r3
    211a:	4465      	add	r5, ip

		for (i=0; i<512; i++)
		{
			SPI_SD_Send_Byte(buf[i]);
    211c:	4e1d      	ldr	r6, [pc, #116]	; (2194 <SDCard_WriteSingleBlock+0xd0>)
    211e:	7820      	ldrb	r0, [r4, #0]
    2120:	47b0      	blx	r6
    2122:	3401      	adds	r4, #1
		for (i=0; i<512; i++)
    2124:	42a5      	cmp	r5, r4
    2126:	d1fa      	bne.n	211e <SDCard_WriteSingleBlock+0x5a>
		}
		
	    // Send CRC Info (dummy)
		SPI_SD_Send_Byte(0xFF);
    2128:	20ff      	movs	r0, #255	; 0xff
    212a:	4c1a      	ldr	r4, [pc, #104]	; (2194 <SDCard_WriteSingleBlock+0xd0>)
    212c:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    212e:	20ff      	movs	r0, #255	; 0xff
    2130:	47a0      	blx	r4
		temp = SPI_SD_Send_Byte(0xFF);
    2132:	20ff      	movs	r0, #255	; 0xff
    2134:	47a0      	blx	r4
		temp &= 0x1F;
		
		if (temp != 0x05)
    2136:	231f      	movs	r3, #31
    2138:	4018      	ands	r0, r3
    213a:	2805      	cmp	r0, #5
    213c:	d10f      	bne.n	215e <SDCard_WriteSingleBlock+0x9a>
    213e:	4c16      	ldr	r4, [pc, #88]	; (2198 <SDCard_WriteSingleBlock+0xd4>)
			UART3_Write_Text("CRC Write Fail");
			SDCard_SS(1);
			return 1;
		}

		while (SPI_SD_Send_Byte(0xFF) == 0x00)
    2140:	4d14      	ldr	r5, [pc, #80]	; (2194 <SDCard_WriteSingleBlock+0xd0>)
    2142:	20ff      	movs	r0, #255	; 0xff
    2144:	47a8      	blx	r5
    2146:	2800      	cmp	r0, #0
    2148:	d112      	bne.n	2170 <SDCard_WriteSingleBlock+0xac>
    214a:	3c01      	subs	r4, #1
    214c:	b2a4      	uxth	r4, r4
		{
			 retry++;
			 if(retry>0xfffe)
    214e:	2c00      	cmp	r4, #0
    2150:	d1f7      	bne.n	2142 <SDCard_WriteSingleBlock+0x7e>
		SPI_CS_HIGH();
    2152:	2280      	movs	r2, #128	; 0x80
    2154:	0052      	lsls	r2, r2, #1
    2156:	4b0e      	ldr	r3, [pc, #56]	; (2190 <SDCard_WriteSingleBlock+0xcc>)
    2158:	619a      	str	r2, [r3, #24]
			{

			  SDCard_SS(1);
			   return 1 ;
    215a:	2001      	movs	r0, #1
    215c:	e013      	b.n	2186 <SDCard_WriteSingleBlock+0xc2>
			UART3_Write_Text("CRC Write Fail");
    215e:	480f      	ldr	r0, [pc, #60]	; (219c <SDCard_WriteSingleBlock+0xd8>)
    2160:	4b0f      	ldr	r3, [pc, #60]	; (21a0 <SDCard_WriteSingleBlock+0xdc>)
    2162:	4798      	blx	r3
		SPI_CS_HIGH();
    2164:	2280      	movs	r2, #128	; 0x80
    2166:	0052      	lsls	r2, r2, #1
    2168:	4b09      	ldr	r3, [pc, #36]	; (2190 <SDCard_WriteSingleBlock+0xcc>)
    216a:	619a      	str	r2, [r3, #24]
			return 1;
    216c:	2001      	movs	r0, #1
    216e:	e00a      	b.n	2186 <SDCard_WriteSingleBlock+0xc2>
		SPI_CS_HIGH();
    2170:	2280      	movs	r2, #128	; 0x80
    2172:	0052      	lsls	r2, r2, #1
    2174:	4b06      	ldr	r3, [pc, #24]	; (2190 <SDCard_WriteSingleBlock+0xcc>)
    2176:	619a      	str	r2, [r3, #24]
			 }
		}
		
		SDCard_SS(1);
		SPI_SD_Send_Byte(0xFF);
    2178:	20ff      	movs	r0, #255	; 0xff
    217a:	4b06      	ldr	r3, [pc, #24]	; (2194 <SDCard_WriteSingleBlock+0xd0>)
    217c:	4798      	blx	r3
		UART3_Write_Text("Write Complete\n");
    217e:	4809      	ldr	r0, [pc, #36]	; (21a4 <SDCard_WriteSingleBlock+0xe0>)
    2180:	4b07      	ldr	r3, [pc, #28]	; (21a0 <SDCard_WriteSingleBlock+0xdc>)
    2182:	4798      	blx	r3
		return 0;
    2184:	2000      	movs	r0, #0
}
    2186:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2188:	2000045e 	.word	0x2000045e
    218c:	00001d29 	.word	0x00001d29
    2190:	41004400 	.word	0x41004400
    2194:	00002411 	.word	0x00002411
    2198:	0000ffff 	.word	0x0000ffff
    219c:	00002c44 	.word	0x00002c44
    21a0:	000024ed 	.word	0x000024ed
    21a4:	00002c54 	.word	0x00002c54

000021a8 <SDCard_WriteMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Multiple Blocks of Data                                         */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteMultipleBlock(uint32_t addr, uint8_t *buf, uint8_t count)
{
    21a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    21aa:	46d6      	mov	lr, sl
    21ac:	464f      	mov	r7, r9
    21ae:	4646      	mov	r6, r8
    21b0:	b5c0      	push	{r6, r7, lr}
    21b2:	0004      	movs	r4, r0
    21b4:	4688      	mov	r8, r1
    21b6:	0017      	movs	r7, r2
     uint16_t i;
	 uint8_t tmp;
	 
     if(SD_Type!=SD_TYPE_V2HC) 
    21b8:	4b33      	ldr	r3, [pc, #204]	; (2288 <SDCard_WriteMultipleBlock+0xe0>)
    21ba:	79db      	ldrb	r3, [r3, #7]
    21bc:	2b04      	cmp	r3, #4
    21be:	d04a      	beq.n	2256 <SDCard_WriteMultipleBlock+0xae>
     {
          addr=addr<<9;
    21c0:	0244      	lsls	r4, r0, #9
     }
	 
	 if(SD_Type!=SD_TYPE_MMC)
    21c2:	2b00      	cmp	r3, #0
    21c4:	d147      	bne.n	2256 <SDCard_WriteMultipleBlock+0xae>
     ////////////////////////////////////
     // Write Multiple Block Addresses
     ///////////////////////////////////
	 
	 // try to write blocks of data until stop transmission received
	 if (SDCard_WriteCmd(CMD25,addr,0xFF) != 0x00) 
    21c6:	22ff      	movs	r2, #255	; 0xff
    21c8:	0021      	movs	r1, r4
    21ca:	2059      	movs	r0, #89	; 0x59
    21cc:	4b2f      	ldr	r3, [pc, #188]	; (228c <SDCard_WriteMultipleBlock+0xe4>)
    21ce:	4798      	blx	r3
    21d0:	2800      	cmp	r0, #0
    21d2:	d146      	bne.n	2262 <SDCard_WriteMultipleBlock+0xba>
		SPI_CS_LOW();
    21d4:	2280      	movs	r2, #128	; 0x80
    21d6:	0052      	lsls	r2, r2, #1
    21d8:	4b2d      	ldr	r3, [pc, #180]	; (2290 <SDCard_WriteMultipleBlock+0xe8>)
    21da:	615a      	str	r2, [r3, #20]
	 }
	 
	 SDCard_SS(0); 

	 // Wait until SD Card is ready
	 SPI_SD_Send_Byte(0xFF);
    21dc:	20ff      	movs	r0, #255	; 0xff
    21de:	4c2d      	ldr	r4, [pc, #180]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    21e0:	47a0      	blx	r4
	 SPI_SD_Send_Byte(0xFF);
    21e2:	20ff      	movs	r0, #255	; 0xff
    21e4:	47a0      	blx	r4
	 
	 // Write Data
	 do
	 {
		 // Start block
		 SPI_SD_Send_Byte (0xFC); 
    21e6:	4b2b      	ldr	r3, [pc, #172]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    21e8:	469a      	mov	sl, r3
		 
		 // Write Data
		 for (i=0; i<512; i++) 
		 {
				 SPI_SD_Send_Byte(*buf++);
    21ea:	001e      	movs	r6, r3
		 }
		 
		 // Send CRC info (dummy)
		 SPI_SD_Send_Byte(0xFF); 
    21ec:	4699      	mov	r9, r3
		 SPI_SD_Send_Byte (0xFC); 
    21ee:	20fc      	movs	r0, #252	; 0xfc
    21f0:	47d0      	blx	sl
    21f2:	4644      	mov	r4, r8
    21f4:	2380      	movs	r3, #128	; 0x80
    21f6:	009b      	lsls	r3, r3, #2
    21f8:	469c      	mov	ip, r3
    21fa:	44e0      	add	r8, ip
    21fc:	4645      	mov	r5, r8
				 SPI_SD_Send_Byte(*buf++);
    21fe:	7820      	ldrb	r0, [r4, #0]
    2200:	47b0      	blx	r6
    2202:	3401      	adds	r4, #1
		 for (i=0; i<512; i++) 
    2204:	42ac      	cmp	r4, r5
    2206:	d1fa      	bne.n	21fe <SDCard_WriteMultipleBlock+0x56>
		 SPI_SD_Send_Byte(0xFF); 
    2208:	20ff      	movs	r0, #255	; 0xff
    220a:	47c8      	blx	r9
		 SPI_SD_Send_Byte(0xFF);
    220c:	20ff      	movs	r0, #255	; 0xff
    220e:	47c8      	blx	r9
		 
		 tmp = SPI_SD_Send_Byte(0xFF); 
    2210:	20ff      	movs	r0, #255	; 0xff
    2212:	47c8      	blx	r9
		 tmp &= 0x1F;
		 
		 if(tmp != 0x05)
    2214:	231f      	movs	r3, #31
    2216:	4018      	ands	r0, r3
    2218:	2805      	cmp	r0, #5
    221a:	d12b      	bne.n	2274 <SDCard_WriteMultipleBlock+0xcc>
		 {   
			UART3_Write_Text("CRC Multiple Write Failed\n");
			SDCard_SS(1);
			return 1;
		 }
		 while(SPI_SD_Send_Byte (0xFF) == 0x00){;} // BUSY wait
    221c:	4c1d      	ldr	r4, [pc, #116]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    221e:	20ff      	movs	r0, #255	; 0xff
    2220:	47a0      	blx	r4
    2222:	2800      	cmp	r0, #0
    2224:	d0fb      	beq.n	221e <SDCard_WriteMultipleBlock+0x76>
	 }while (--count);
    2226:	3f01      	subs	r7, #1
    2228:	b2ff      	uxtb	r7, r7
    222a:	2f00      	cmp	r7, #0
    222c:	d1df      	bne.n	21ee <SDCard_WriteMultipleBlock+0x46>
	 
	 // Send 'Stop Tran' Token
	 SPI_SD_Send_Byte (0xFD);
    222e:	20fd      	movs	r0, #253	; 0xfd
    2230:	4b18      	ldr	r3, [pc, #96]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    2232:	4798      	blx	r3
	 while (SPI_SD_Send_Byte (0xFF) == 0x00)
    2234:	4c17      	ldr	r4, [pc, #92]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    2236:	20ff      	movs	r0, #255	; 0xff
    2238:	47a0      	blx	r4
    223a:	2800      	cmp	r0, #0
    223c:	d0fb      	beq.n	2236 <SDCard_WriteMultipleBlock+0x8e>
		SPI_CS_HIGH();
    223e:	2280      	movs	r2, #128	; 0x80
    2240:	0052      	lsls	r2, r2, #1
    2242:	4b13      	ldr	r3, [pc, #76]	; (2290 <SDCard_WriteMultipleBlock+0xe8>)
    2244:	619a      	str	r2, [r3, #24]
		 
	 }
	 
	 // done writing
	 SDCard_SS(1);
	 SPI_SD_Send_Byte(0xFF);
    2246:	20ff      	movs	r0, #255	; 0xff
    2248:	4b12      	ldr	r3, [pc, #72]	; (2294 <SDCard_WriteMultipleBlock+0xec>)
    224a:	4798      	blx	r3
	 UART3_Write_Text("Write Multiple Complete\n");
    224c:	4812      	ldr	r0, [pc, #72]	; (2298 <SDCard_WriteMultipleBlock+0xf0>)
    224e:	4b13      	ldr	r3, [pc, #76]	; (229c <SDCard_WriteMultipleBlock+0xf4>)
    2250:	4798      	blx	r3
	 return 0;
    2252:	0038      	movs	r0, r7
    2254:	e009      	b.n	226a <SDCard_WriteMultipleBlock+0xc2>
        tmp=SDCard_WriteCmd(CMD23,count,0x00);
    2256:	2200      	movs	r2, #0
    2258:	0039      	movs	r1, r7
    225a:	2057      	movs	r0, #87	; 0x57
    225c:	4b0b      	ldr	r3, [pc, #44]	; (228c <SDCard_WriteMultipleBlock+0xe4>)
    225e:	4798      	blx	r3
    2260:	e7b1      	b.n	21c6 <SDCard_WriteMultipleBlock+0x1e>
		 UART3_Write_Text("Write Multiple Block Address Failed\n");
    2262:	480f      	ldr	r0, [pc, #60]	; (22a0 <SDCard_WriteMultipleBlock+0xf8>)
    2264:	4b0d      	ldr	r3, [pc, #52]	; (229c <SDCard_WriteMultipleBlock+0xf4>)
    2266:	4798      	blx	r3
		 return 1;
    2268:	2001      	movs	r0, #1
}
    226a:	bc1c      	pop	{r2, r3, r4}
    226c:	4690      	mov	r8, r2
    226e:	4699      	mov	r9, r3
    2270:	46a2      	mov	sl, r4
    2272:	bdf0      	pop	{r4, r5, r6, r7, pc}
			UART3_Write_Text("CRC Multiple Write Failed\n");
    2274:	480b      	ldr	r0, [pc, #44]	; (22a4 <SDCard_WriteMultipleBlock+0xfc>)
    2276:	4b09      	ldr	r3, [pc, #36]	; (229c <SDCard_WriteMultipleBlock+0xf4>)
    2278:	4798      	blx	r3
		SPI_CS_HIGH();
    227a:	2280      	movs	r2, #128	; 0x80
    227c:	0052      	lsls	r2, r2, #1
    227e:	4b04      	ldr	r3, [pc, #16]	; (2290 <SDCard_WriteMultipleBlock+0xe8>)
    2280:	619a      	str	r2, [r3, #24]
			return 1;
    2282:	2001      	movs	r0, #1
    2284:	e7f1      	b.n	226a <SDCard_WriteMultipleBlock+0xc2>
    2286:	46c0      	nop			; (mov r8, r8)
    2288:	2000045e 	.word	0x2000045e
    228c:	00001d29 	.word	0x00001d29
    2290:	41004400 	.word	0x41004400
    2294:	00002411 	.word	0x00002411
    2298:	00002ca8 	.word	0x00002ca8
    229c:	000024ed 	.word	0x000024ed
    22a0:	00002c64 	.word	0x00002c64
    22a4:	00002c8c 	.word	0x00002c8c

000022a8 <SPI_Initialize_Fast>:
 *
 ******************************************************************************/
void SPI_Initialize_Fast(void)
{
	  // Wait Sync
	  while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    22a8:	4a20      	ldr	r2, [pc, #128]	; (232c <SPI_Initialize_Fast+0x84>)
    22aa:	69d3      	ldr	r3, [r2, #28]
    22ac:	079b      	lsls	r3, r3, #30
    22ae:	d4fc      	bmi.n	22aa <SPI_Initialize_Fast+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM1;								
    22b0:	4a1f      	ldr	r2, [pc, #124]	; (2330 <SPI_Initialize_Fast+0x88>)
    22b2:	6a13      	ldr	r3, [r2, #32]
    22b4:	2108      	movs	r1, #8
    22b6:	430b      	orrs	r3, r1
    22b8:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    22ba:	4a1e      	ldr	r2, [pc, #120]	; (2334 <SPI_Initialize_Fast+0x8c>)
    22bc:	4b1e      	ldr	r3, [pc, #120]	; (2338 <SPI_Initialize_Fast+0x90>)
    22be:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    22c0:	001a      	movs	r2, r3
    22c2:	7853      	ldrb	r3, [r2, #1]
    22c4:	09db      	lsrs	r3, r3, #7
    22c6:	d1fc      	bne.n	22c2 <SPI_Initialize_Fast+0x1a>
	  
      /* -------------------------------------------------
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM1 SPI MASTER MISO
	  PORT->Group[0].WRCONFIG.reg =
    22c8:	4b1c      	ldr	r3, [pc, #112]	; (233c <SPI_Initialize_Fast+0x94>)
    22ca:	4a1d      	ldr	r2, [pc, #116]	; (2340 <SPI_Initialize_Fast+0x98>)
    22cc:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_HWSEL |						 //Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_INEN |									 //Enable input on this pin MISO
	       PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA18) >> 16)); //Selecting which pin is configured  PA17 
	       
	       //Using the WRCONFIG register to bulk configure both PB22 and PB23 for being configured the SERCOM1 SPI MASTER MOSI and SCK pins
	       PORT->Group[0].WRCONFIG.reg =
    22ce:	4a1d      	ldr	r2, [pc, #116]	; (2344 <SPI_Initialize_Fast+0x9c>)
    22d0:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_PMUXEN |							 //Enables the PMUX for the pins
	       PORT_WRCONFIG_HWSEL |												//Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_PINMASK ((uint16_t)((PORT_PA16 | PORT_PA19) >> 16));	//Selecting which pin is configured
	         
	       // Set the drive strength to strong
	       PORT->Group[0].PINCFG[19].bit.DRVSTR = 1;
    22d2:	2153      	movs	r1, #83	; 0x53
    22d4:	5c5a      	ldrb	r2, [r3, r1]
    22d6:	2040      	movs	r0, #64	; 0x40
    22d8:	4302      	orrs	r2, r0
    22da:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM1->SPI.CTRLA.bit.ENABLE = 0;
    22dc:	4a13      	ldr	r2, [pc, #76]	; (232c <SPI_Initialize_Fast+0x84>)
    22de:	6813      	ldr	r3, [r2, #0]
    22e0:	3951      	subs	r1, #81	; 0x51
    22e2:	438b      	bics	r3, r1
    22e4:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM1->SPI.SYNCBUSY.bit.SWRST)
    22e6:	69d3      	ldr	r3, [r2, #28]
    22e8:	07db      	lsls	r3, r3, #31
    22ea:	d4fc      	bmi.n	22e6 <SPI_Initialize_Fast+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM1->SPI.CTRLA.bit.SWRST = 1;
    22ec:	4a0f      	ldr	r2, [pc, #60]	; (232c <SPI_Initialize_Fast+0x84>)
    22ee:	6813      	ldr	r3, [r2, #0]
    22f0:	2101      	movs	r1, #1
    22f2:	430b      	orrs	r3, r1
    22f4:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM1->SPI.CTRLA.bit.SWRST)
    22f6:	6813      	ldr	r3, [r2, #0]
    22f8:	07db      	lsls	r3, r3, #31
    22fa:	d4fc      	bmi.n	22f6 <SPI_Initialize_Fast+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM1->SPI.SYNCBUSY.bit.SWRST || SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    22fc:	4a0b      	ldr	r2, [pc, #44]	; (232c <SPI_Initialize_Fast+0x84>)
    22fe:	69d3      	ldr	r3, [r2, #28]
    2300:	07db      	lsls	r3, r3, #31
    2302:	d4fc      	bmi.n	22fe <SPI_Initialize_Fast+0x56>
    2304:	69d3      	ldr	r3, [r2, #28]
    2306:	079b      	lsls	r3, r3, #30
    2308:	d4f9      	bmi.n	22fe <SPI_Initialize_Fast+0x56>

	   SERCOM1->SPI.CTRLA.reg = 
    230a:	4b08      	ldr	r3, [pc, #32]	; (232c <SPI_Initialize_Fast+0x84>)
    230c:	4a0e      	ldr	r2, [pc, #56]	; (2348 <SPI_Initialize_Fast+0xa0>)
    230e:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM1->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    2310:	2280      	movs	r2, #128	; 0x80
    2312:	0292      	lsls	r2, r2, #10
    2314:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 12000000)) - 1;	//Calculate BAUD value
	   SERCOM1->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    2316:	2201      	movs	r2, #1
    2318:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM1->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    231a:	681a      	ldr	r2, [r3, #0]
    231c:	2102      	movs	r1, #2
    231e:	430a      	orrs	r2, r1
    2320:	601a      	str	r2, [r3, #0]
	    while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    2322:	001a      	movs	r2, r3
    2324:	69d3      	ldr	r3, [r2, #28]
    2326:	079b      	lsls	r3, r3, #30
    2328:	d4fc      	bmi.n	2324 <SPI_Initialize_Fast+0x7c>
}
    232a:	4770      	bx	lr
    232c:	42000c00 	.word	0x42000c00
    2330:	40000400 	.word	0x40000400
    2334:	00004015 	.word	0x00004015
    2338:	40000c00 	.word	0x40000c00
    233c:	41004400 	.word	0x41004400
    2340:	d2030004 	.word	0xd2030004
    2344:	d2010009 	.word	0xd2010009
    2348:	0023000c 	.word	0x0023000c

0000234c <SPI_Initialize_Slow>:
 *
 ******************************************************************************/
void SPI_Initialize_Slow(void)
{
	  // Wait Sync
	  while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    234c:	4a20      	ldr	r2, [pc, #128]	; (23d0 <SPI_Initialize_Slow+0x84>)
    234e:	69d3      	ldr	r3, [r2, #28]
    2350:	079b      	lsls	r3, r3, #30
    2352:	d4fc      	bmi.n	234e <SPI_Initialize_Slow+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM1;								
    2354:	4a1f      	ldr	r2, [pc, #124]	; (23d4 <SPI_Initialize_Slow+0x88>)
    2356:	6a13      	ldr	r3, [r2, #32]
    2358:	2108      	movs	r1, #8
    235a:	430b      	orrs	r3, r1
    235c:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    235e:	4a1e      	ldr	r2, [pc, #120]	; (23d8 <SPI_Initialize_Slow+0x8c>)
    2360:	4b1e      	ldr	r3, [pc, #120]	; (23dc <SPI_Initialize_Slow+0x90>)
    2362:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    2364:	001a      	movs	r2, r3
    2366:	7853      	ldrb	r3, [r2, #1]
    2368:	09db      	lsrs	r3, r3, #7
    236a:	d1fc      	bne.n	2366 <SPI_Initialize_Slow+0x1a>
	  
      /* -------------------------------------------------
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM5 SPI MASTER MISO
	  PORT->Group[0].WRCONFIG.reg =
    236c:	4b1c      	ldr	r3, [pc, #112]	; (23e0 <SPI_Initialize_Slow+0x94>)
    236e:	4a1d      	ldr	r2, [pc, #116]	; (23e4 <SPI_Initialize_Slow+0x98>)
    2370:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_HWSEL |						 //Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_INEN |									 //Enable input on this pin MISO
	       PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA18) >> 16)); //Selecting which pin is configured  PA17 
	       
	       //Using the WRCONFIG register to bulk configure both PB22 and PB23 for being configured the SERCOM5 SPI MASTER MOSI and SCK pins
	       PORT->Group[0].WRCONFIG.reg =
    2372:	4a1d      	ldr	r2, [pc, #116]	; (23e8 <SPI_Initialize_Slow+0x9c>)
    2374:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_PMUXEN |							 //Enables the PMUX for the pins
	       PORT_WRCONFIG_HWSEL |												//Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_PINMASK ((uint16_t)((PORT_PA16 | PORT_PA19) >> 16));	//Selecting which pin is configured
	         
	       // Set the drive strength to strong
	       PORT->Group[0].PINCFG[19].bit.DRVSTR = 1;
    2376:	2153      	movs	r1, #83	; 0x53
    2378:	5c5a      	ldrb	r2, [r3, r1]
    237a:	2040      	movs	r0, #64	; 0x40
    237c:	4302      	orrs	r2, r0
    237e:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM1->SPI.CTRLA.bit.ENABLE = 0;
    2380:	4a13      	ldr	r2, [pc, #76]	; (23d0 <SPI_Initialize_Slow+0x84>)
    2382:	6813      	ldr	r3, [r2, #0]
    2384:	3951      	subs	r1, #81	; 0x51
    2386:	438b      	bics	r3, r1
    2388:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM1->SPI.SYNCBUSY.bit.SWRST)
    238a:	69d3      	ldr	r3, [r2, #28]
    238c:	07db      	lsls	r3, r3, #31
    238e:	d4fc      	bmi.n	238a <SPI_Initialize_Slow+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM1->SPI.CTRLA.bit.SWRST = 1;
    2390:	4a0f      	ldr	r2, [pc, #60]	; (23d0 <SPI_Initialize_Slow+0x84>)
    2392:	6813      	ldr	r3, [r2, #0]
    2394:	2101      	movs	r1, #1
    2396:	430b      	orrs	r3, r1
    2398:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM1->SPI.CTRLA.bit.SWRST)
    239a:	6813      	ldr	r3, [r2, #0]
    239c:	07db      	lsls	r3, r3, #31
    239e:	d4fc      	bmi.n	239a <SPI_Initialize_Slow+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM1->SPI.SYNCBUSY.bit.SWRST || SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    23a0:	4a0b      	ldr	r2, [pc, #44]	; (23d0 <SPI_Initialize_Slow+0x84>)
    23a2:	69d3      	ldr	r3, [r2, #28]
    23a4:	07db      	lsls	r3, r3, #31
    23a6:	d4fc      	bmi.n	23a2 <SPI_Initialize_Slow+0x56>
    23a8:	69d3      	ldr	r3, [r2, #28]
    23aa:	079b      	lsls	r3, r3, #30
    23ac:	d4f9      	bmi.n	23a2 <SPI_Initialize_Slow+0x56>

	   SERCOM1->SPI.CTRLA.reg = 
    23ae:	4b08      	ldr	r3, [pc, #32]	; (23d0 <SPI_Initialize_Slow+0x84>)
    23b0:	4a0e      	ldr	r2, [pc, #56]	; (23ec <SPI_Initialize_Slow+0xa0>)
    23b2:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM1->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    23b4:	2280      	movs	r2, #128	; 0x80
    23b6:	0292      	lsls	r2, r2, #10
    23b8:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 400000)) - 1;	//Calculate BAUD value
	   SERCOM1->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    23ba:	223b      	movs	r2, #59	; 0x3b
    23bc:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM1->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    23be:	681a      	ldr	r2, [r3, #0]
    23c0:	2102      	movs	r1, #2
    23c2:	430a      	orrs	r2, r1
    23c4:	601a      	str	r2, [r3, #0]
	    while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    23c6:	001a      	movs	r2, r3
    23c8:	69d3      	ldr	r3, [r2, #28]
    23ca:	079b      	lsls	r3, r3, #30
    23cc:	d4fc      	bmi.n	23c8 <SPI_Initialize_Slow+0x7c>
}
    23ce:	4770      	bx	lr
    23d0:	42000c00 	.word	0x42000c00
    23d4:	40000400 	.word	0x40000400
    23d8:	00004015 	.word	0x00004015
    23dc:	40000c00 	.word	0x40000c00
    23e0:	41004400 	.word	0x41004400
    23e4:	d2030004 	.word	0xd2030004
    23e8:	d2010009 	.word	0xd2010009
    23ec:	0023000c 	.word	0x0023000c

000023f0 <SPI_Exchange8bit>:
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_Exchange8bit(uint8_t data)
{
	while(SERCOM1->SPI.INTFLAG.bit.DRE == 0);
    23f0:	4a06      	ldr	r2, [pc, #24]	; (240c <SPI_Exchange8bit+0x1c>)
    23f2:	7e13      	ldrb	r3, [r2, #24]
    23f4:	07db      	lsls	r3, r3, #31
    23f6:	d5fc      	bpl.n	23f2 <SPI_Exchange8bit+0x2>
	SERCOM1->SPI.DATA.reg = data;
    23f8:	4b04      	ldr	r3, [pc, #16]	; (240c <SPI_Exchange8bit+0x1c>)
    23fa:	6298      	str	r0, [r3, #40]	; 0x28
	
	while(SERCOM1->SPI.INTFLAG.bit.RXC == 0);
    23fc:	001a      	movs	r2, r3
    23fe:	7e13      	ldrb	r3, [r2, #24]
    2400:	075b      	lsls	r3, r3, #29
    2402:	d5fc      	bpl.n	23fe <SPI_Exchange8bit+0xe>
	return (uint8_t)SERCOM1->SPI.DATA.reg;
    2404:	4b01      	ldr	r3, [pc, #4]	; (240c <SPI_Exchange8bit+0x1c>)
    2406:	6a98      	ldr	r0, [r3, #40]	; 0x28
    2408:	b2c0      	uxtb	r0, r0
}
    240a:	4770      	bx	lr
    240c:	42000c00 	.word	0x42000c00

00002410 <SPI_SD_Send_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Send_Byte(uint8_t byte_val)
{
    2410:	b510      	push	{r4, lr}
	uint8_t data;
	
	data = SPI_Exchange8bit(byte_val);
    2412:	4b01      	ldr	r3, [pc, #4]	; (2418 <SPI_SD_Send_Byte+0x8>)
    2414:	4798      	blx	r3
	return data;
}
    2416:	bd10      	pop	{r4, pc}
    2418:	000023f1 	.word	0x000023f1

0000241c <SPI_SD_Read_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Read_Byte(void)
{
    241c:	b510      	push	{r4, lr}
	uint8_t data;

	data = SPI_Exchange8bit(0xff);
    241e:	20ff      	movs	r0, #255	; 0xff
    2420:	4b01      	ldr	r3, [pc, #4]	; (2428 <SPI_SD_Read_Byte+0xc>)
    2422:	4798      	blx	r3
	return data;
    2424:	bd10      	pop	{r4, pc}
    2426:	46c0      	nop			; (mov r8, r8)
    2428:	000023f1 	.word	0x000023f1

0000242c <UART3_Init>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Init(uint32_t baud)
{
    242c:	b570      	push	{r4, r5, r6, lr}
	
	/* -------------------------------------------------
	* 1) Enable bus clock to APBC mask
	*/
	REG_PM_APBCMASK |=  PM_APBCMASK_SERCOM3;
    242e:	4a21      	ldr	r2, [pc, #132]	; (24b4 <UART3_Init+0x88>)
    2430:	6813      	ldr	r3, [r2, #0]
    2432:	2120      	movs	r1, #32
    2434:	430b      	orrs	r3, r1
    2436:	6013      	str	r3, [r2, #0]
	
    /* -------------------------------------------------
	* 2) select UART clock
	*/
	GCLK->CLKCTRL.reg =  
    2438:	4a1f      	ldr	r2, [pc, #124]	; (24b8 <UART3_Init+0x8c>)
    243a:	4b20      	ldr	r3, [pc, #128]	; (24bc <UART3_Init+0x90>)
    243c:	805a      	strh	r2, [r3, #2]
	
	/* --------------------------------------------------
	* 3) Configure PA22 as TX Pin
	*/
	// Set pin direction to output
	PORT->Group[0].DIRSET.reg = (1 << 22);     
    243e:	4b20      	ldr	r3, [pc, #128]	; (24c0 <UART3_Init+0x94>)
    2440:	2280      	movs	r2, #128	; 0x80
    2442:	03d2      	lsls	r2, r2, #15
    2444:	609a      	str	r2, [r3, #8]
	
    // Enable PMUX
	PORT->Group[0].PINCFG[22].reg |= PORT_PINCFG_PMUXEN;   
    2446:	2256      	movs	r2, #86	; 0x56
    2448:	5c99      	ldrb	r1, [r3, r2]
    244a:	2601      	movs	r6, #1
    244c:	4331      	orrs	r1, r6
    244e:	b2c9      	uxtb	r1, r1
    2450:	5499      	strb	r1, [r3, r2]
	
	// Enable PMUX and set the PMUX bit, since pin is even we use PMUXE
	PORT->Group[0].PMUX[22>>1].bit.PMUXE = PORT_PMUX_PMUXE_C_Val;
    2452:	243b      	movs	r4, #59	; 0x3b
    2454:	5d19      	ldrb	r1, [r3, r4]
    2456:	3a47      	subs	r2, #71	; 0x47
    2458:	4391      	bics	r1, r2
    245a:	2202      	movs	r2, #2
    245c:	4311      	orrs	r1, r2
    245e:	5519      	strb	r1, [r3, r4]
	
	/* ---------------------------------------------------
	* 4) Configure PA23 as RX Pin
	*/
	// Set pin direction to input
	PORT->Group[0].DIRCLR.reg = (1 << 23);       
    2460:	2280      	movs	r2, #128	; 0x80
    2462:	0412      	lsls	r2, r2, #16
    2464:	605a      	str	r2, [r3, #4]

	// Enable pull down resistor
	PORT->Group[0].PINCFG[23].reg &= ~PORT_PINCFG_PULLEN;   
    2466:	2157      	movs	r1, #87	; 0x57
    2468:	5c5d      	ldrb	r5, [r3, r1]
    246a:	2204      	movs	r2, #4
    246c:	4395      	bics	r5, r2
    246e:	545d      	strb	r5, [r3, r1]
	
	// Enable PMUX and set the PMUX bit, since pin is odd we use PMUX0
	PORT->Group[0].PINCFG[23].reg |= PORT_PINCFG_PMUXEN; 
    2470:	5c5a      	ldrb	r2, [r3, r1]
    2472:	4332      	orrs	r2, r6
    2474:	b2d2      	uxtb	r2, r2
    2476:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PMUX[23>>1].bit.PMUXO = PORT_PMUX_PMUXO_C_Val; 
    2478:	5d19      	ldrb	r1, [r3, r4]
    247a:	220f      	movs	r2, #15
    247c:	400a      	ands	r2, r1
    247e:	2120      	movs	r1, #32
    2480:	430a      	orrs	r2, r1
    2482:	551a      	strb	r2, [r3, r4]
	
	
	/* ----------------------------------------------------
	* 5) Configure USART via Control A and Control B 
	*/
	SERCOM3->USART.CTRLA.reg =                  // USART is ASYNCHRONOUS
    2484:	4c0f      	ldr	r4, [pc, #60]	; (24c4 <UART3_Init+0x98>)
    2486:	4b10      	ldr	r3, [pc, #64]	; (24c8 <UART3_Init+0x9c>)
    2488:	6023      	str	r3, [r4, #0]
	   SERCOM_USART_CTRLA_MODE_USART_INT_CLK |  // Set Internal Clock 
	   SERCOM_USART_CTRLA_RXPO(1) |             // Use SERCOM pad 1 for data reception
	   SERCOM_USART_CTRLA_TXPO(0/*PAD0*/);      // Set SERCOM pad 0 for data transmission
	
	
	SERCOM3->USART.CTRLB.reg =        // We don't use PARITY
    248a:	23c0      	movs	r3, #192	; 0xc0
    248c:	029b      	lsls	r3, r3, #10
    248e:	6063      	str	r3, [r4, #4]
	
	/* -----------------------------------------------------
	* 6) Set USART Baud Rate
	*/
	// Baud rate is (65536) * (CPU_CLock - 16 * wanted baud) / CPU_Clock
	uint64_t baudRate = (uint64_t)65536 * (F_CPU - 16 * baud) / F_CPU;
    2490:	0100      	lsls	r0, r0, #4
    2492:	4240      	negs	r0, r0
    2494:	4b0d      	ldr	r3, [pc, #52]	; (24cc <UART3_Init+0xa0>)
    2496:	469c      	mov	ip, r3
    2498:	4460      	add	r0, ip
    249a:	0c01      	lsrs	r1, r0, #16
    249c:	0400      	lsls	r0, r0, #16
    249e:	4a0b      	ldr	r2, [pc, #44]	; (24cc <UART3_Init+0xa0>)
    24a0:	2300      	movs	r3, #0
    24a2:	4d0b      	ldr	r5, [pc, #44]	; (24d0 <UART3_Init+0xa4>)
    24a4:	47a8      	blx	r5
	
	// Set Baud Rate
	SERCOM3->USART.BAUD.reg = (uint32_t)baudRate;
    24a6:	b280      	uxth	r0, r0
    24a8:	81a0      	strh	r0, [r4, #12]

    /* ------------------------------------------------------
	* 7) Enable the USART
	*/
	// SERCOM3 peripheral enabled
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    24aa:	6823      	ldr	r3, [r4, #0]
    24ac:	2202      	movs	r2, #2
    24ae:	4313      	orrs	r3, r2
    24b0:	6023      	str	r3, [r4, #0]
}  // UART3_Init()
    24b2:	bd70      	pop	{r4, r5, r6, pc}
    24b4:	40000420 	.word	0x40000420
    24b8:	00004017 	.word	0x00004017
    24bc:	40000c00 	.word	0x40000c00
    24c0:	41004400 	.word	0x41004400
    24c4:	42001400 	.word	0x42001400
    24c8:	40100004 	.word	0x40100004
    24cc:	02dc6c00 	.word	0x02dc6c00
    24d0:	00002625 	.word	0x00002625

000024d4 <UART3_Write>:
 *
 ******************************************************************************/
void UART3_Write(char data)
{
	// Wait on interrupt flag and Write some data
	while(!(REG_SERCOM3_USART_INTFLAG) & 1)
    24d4:	4a03      	ldr	r2, [pc, #12]	; (24e4 <UART3_Write+0x10>)
    24d6:	7813      	ldrb	r3, [r2, #0]
    24d8:	2b00      	cmp	r3, #0
    24da:	d0fc      	beq.n	24d6 <UART3_Write+0x2>
	{
		
	}
	
	REG_SERCOM3_USART_DATA = data;
    24dc:	b280      	uxth	r0, r0
    24de:	4b02      	ldr	r3, [pc, #8]	; (24e8 <UART3_Write+0x14>)
    24e0:	8018      	strh	r0, [r3, #0]
} //UART3_Write()
    24e2:	4770      	bx	lr
    24e4:	42001418 	.word	0x42001418
    24e8:	42001428 	.word	0x42001428

000024ec <UART3_Write_Text>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Write_Text(char *text)
{
    24ec:	b570      	push	{r4, r5, r6, lr}
    24ee:	0004      	movs	r4, r0
	// we write text until we reach EOL
	for(int i=0;text[i]!='\0';i++)
    24f0:	7800      	ldrb	r0, [r0, #0]
    24f2:	2800      	cmp	r0, #0
    24f4:	d007      	beq.n	2506 <UART3_Write_Text+0x1a>
    24f6:	3401      	adds	r4, #1
	{
		UART3_Write(text[i]);
    24f8:	4d03      	ldr	r5, [pc, #12]	; (2508 <UART3_Write_Text+0x1c>)
    24fa:	47a8      	blx	r5
    24fc:	3401      	adds	r4, #1
	for(int i=0;text[i]!='\0';i++)
    24fe:	1e63      	subs	r3, r4, #1
    2500:	7818      	ldrb	r0, [r3, #0]
    2502:	2800      	cmp	r0, #0
    2504:	d1f9      	bne.n	24fa <UART3_Write_Text+0xe>
	}
	
} // UART3_Write_Text()
    2506:	bd70      	pop	{r4, r5, r6, pc}
    2508:	000024d5 	.word	0x000024d5

0000250c <__udivsi3>:
    250c:	2200      	movs	r2, #0
    250e:	0843      	lsrs	r3, r0, #1
    2510:	428b      	cmp	r3, r1
    2512:	d374      	bcc.n	25fe <__udivsi3+0xf2>
    2514:	0903      	lsrs	r3, r0, #4
    2516:	428b      	cmp	r3, r1
    2518:	d35f      	bcc.n	25da <__udivsi3+0xce>
    251a:	0a03      	lsrs	r3, r0, #8
    251c:	428b      	cmp	r3, r1
    251e:	d344      	bcc.n	25aa <__udivsi3+0x9e>
    2520:	0b03      	lsrs	r3, r0, #12
    2522:	428b      	cmp	r3, r1
    2524:	d328      	bcc.n	2578 <__udivsi3+0x6c>
    2526:	0c03      	lsrs	r3, r0, #16
    2528:	428b      	cmp	r3, r1
    252a:	d30d      	bcc.n	2548 <__udivsi3+0x3c>
    252c:	22ff      	movs	r2, #255	; 0xff
    252e:	0209      	lsls	r1, r1, #8
    2530:	ba12      	rev	r2, r2
    2532:	0c03      	lsrs	r3, r0, #16
    2534:	428b      	cmp	r3, r1
    2536:	d302      	bcc.n	253e <__udivsi3+0x32>
    2538:	1212      	asrs	r2, r2, #8
    253a:	0209      	lsls	r1, r1, #8
    253c:	d065      	beq.n	260a <__udivsi3+0xfe>
    253e:	0b03      	lsrs	r3, r0, #12
    2540:	428b      	cmp	r3, r1
    2542:	d319      	bcc.n	2578 <__udivsi3+0x6c>
    2544:	e000      	b.n	2548 <__udivsi3+0x3c>
    2546:	0a09      	lsrs	r1, r1, #8
    2548:	0bc3      	lsrs	r3, r0, #15
    254a:	428b      	cmp	r3, r1
    254c:	d301      	bcc.n	2552 <__udivsi3+0x46>
    254e:	03cb      	lsls	r3, r1, #15
    2550:	1ac0      	subs	r0, r0, r3
    2552:	4152      	adcs	r2, r2
    2554:	0b83      	lsrs	r3, r0, #14
    2556:	428b      	cmp	r3, r1
    2558:	d301      	bcc.n	255e <__udivsi3+0x52>
    255a:	038b      	lsls	r3, r1, #14
    255c:	1ac0      	subs	r0, r0, r3
    255e:	4152      	adcs	r2, r2
    2560:	0b43      	lsrs	r3, r0, #13
    2562:	428b      	cmp	r3, r1
    2564:	d301      	bcc.n	256a <__udivsi3+0x5e>
    2566:	034b      	lsls	r3, r1, #13
    2568:	1ac0      	subs	r0, r0, r3
    256a:	4152      	adcs	r2, r2
    256c:	0b03      	lsrs	r3, r0, #12
    256e:	428b      	cmp	r3, r1
    2570:	d301      	bcc.n	2576 <__udivsi3+0x6a>
    2572:	030b      	lsls	r3, r1, #12
    2574:	1ac0      	subs	r0, r0, r3
    2576:	4152      	adcs	r2, r2
    2578:	0ac3      	lsrs	r3, r0, #11
    257a:	428b      	cmp	r3, r1
    257c:	d301      	bcc.n	2582 <__udivsi3+0x76>
    257e:	02cb      	lsls	r3, r1, #11
    2580:	1ac0      	subs	r0, r0, r3
    2582:	4152      	adcs	r2, r2
    2584:	0a83      	lsrs	r3, r0, #10
    2586:	428b      	cmp	r3, r1
    2588:	d301      	bcc.n	258e <__udivsi3+0x82>
    258a:	028b      	lsls	r3, r1, #10
    258c:	1ac0      	subs	r0, r0, r3
    258e:	4152      	adcs	r2, r2
    2590:	0a43      	lsrs	r3, r0, #9
    2592:	428b      	cmp	r3, r1
    2594:	d301      	bcc.n	259a <__udivsi3+0x8e>
    2596:	024b      	lsls	r3, r1, #9
    2598:	1ac0      	subs	r0, r0, r3
    259a:	4152      	adcs	r2, r2
    259c:	0a03      	lsrs	r3, r0, #8
    259e:	428b      	cmp	r3, r1
    25a0:	d301      	bcc.n	25a6 <__udivsi3+0x9a>
    25a2:	020b      	lsls	r3, r1, #8
    25a4:	1ac0      	subs	r0, r0, r3
    25a6:	4152      	adcs	r2, r2
    25a8:	d2cd      	bcs.n	2546 <__udivsi3+0x3a>
    25aa:	09c3      	lsrs	r3, r0, #7
    25ac:	428b      	cmp	r3, r1
    25ae:	d301      	bcc.n	25b4 <__udivsi3+0xa8>
    25b0:	01cb      	lsls	r3, r1, #7
    25b2:	1ac0      	subs	r0, r0, r3
    25b4:	4152      	adcs	r2, r2
    25b6:	0983      	lsrs	r3, r0, #6
    25b8:	428b      	cmp	r3, r1
    25ba:	d301      	bcc.n	25c0 <__udivsi3+0xb4>
    25bc:	018b      	lsls	r3, r1, #6
    25be:	1ac0      	subs	r0, r0, r3
    25c0:	4152      	adcs	r2, r2
    25c2:	0943      	lsrs	r3, r0, #5
    25c4:	428b      	cmp	r3, r1
    25c6:	d301      	bcc.n	25cc <__udivsi3+0xc0>
    25c8:	014b      	lsls	r3, r1, #5
    25ca:	1ac0      	subs	r0, r0, r3
    25cc:	4152      	adcs	r2, r2
    25ce:	0903      	lsrs	r3, r0, #4
    25d0:	428b      	cmp	r3, r1
    25d2:	d301      	bcc.n	25d8 <__udivsi3+0xcc>
    25d4:	010b      	lsls	r3, r1, #4
    25d6:	1ac0      	subs	r0, r0, r3
    25d8:	4152      	adcs	r2, r2
    25da:	08c3      	lsrs	r3, r0, #3
    25dc:	428b      	cmp	r3, r1
    25de:	d301      	bcc.n	25e4 <__udivsi3+0xd8>
    25e0:	00cb      	lsls	r3, r1, #3
    25e2:	1ac0      	subs	r0, r0, r3
    25e4:	4152      	adcs	r2, r2
    25e6:	0883      	lsrs	r3, r0, #2
    25e8:	428b      	cmp	r3, r1
    25ea:	d301      	bcc.n	25f0 <__udivsi3+0xe4>
    25ec:	008b      	lsls	r3, r1, #2
    25ee:	1ac0      	subs	r0, r0, r3
    25f0:	4152      	adcs	r2, r2
    25f2:	0843      	lsrs	r3, r0, #1
    25f4:	428b      	cmp	r3, r1
    25f6:	d301      	bcc.n	25fc <__udivsi3+0xf0>
    25f8:	004b      	lsls	r3, r1, #1
    25fa:	1ac0      	subs	r0, r0, r3
    25fc:	4152      	adcs	r2, r2
    25fe:	1a41      	subs	r1, r0, r1
    2600:	d200      	bcs.n	2604 <__udivsi3+0xf8>
    2602:	4601      	mov	r1, r0
    2604:	4152      	adcs	r2, r2
    2606:	4610      	mov	r0, r2
    2608:	4770      	bx	lr
    260a:	e7ff      	b.n	260c <__udivsi3+0x100>
    260c:	b501      	push	{r0, lr}
    260e:	2000      	movs	r0, #0
    2610:	f000 f806 	bl	2620 <__aeabi_idiv0>
    2614:	bd02      	pop	{r1, pc}
    2616:	46c0      	nop			; (mov r8, r8)

00002618 <__aeabi_uidivmod>:
    2618:	2900      	cmp	r1, #0
    261a:	d0f7      	beq.n	260c <__udivsi3+0x100>
    261c:	e776      	b.n	250c <__udivsi3>
    261e:	4770      	bx	lr

00002620 <__aeabi_idiv0>:
    2620:	4770      	bx	lr
    2622:	46c0      	nop			; (mov r8, r8)

00002624 <__aeabi_uldivmod>:
    2624:	2b00      	cmp	r3, #0
    2626:	d111      	bne.n	264c <__aeabi_uldivmod+0x28>
    2628:	2a00      	cmp	r2, #0
    262a:	d10f      	bne.n	264c <__aeabi_uldivmod+0x28>
    262c:	2900      	cmp	r1, #0
    262e:	d100      	bne.n	2632 <__aeabi_uldivmod+0xe>
    2630:	2800      	cmp	r0, #0
    2632:	d002      	beq.n	263a <__aeabi_uldivmod+0x16>
    2634:	2100      	movs	r1, #0
    2636:	43c9      	mvns	r1, r1
    2638:	1c08      	adds	r0, r1, #0
    263a:	b407      	push	{r0, r1, r2}
    263c:	4802      	ldr	r0, [pc, #8]	; (2648 <__aeabi_uldivmod+0x24>)
    263e:	a102      	add	r1, pc, #8	; (adr r1, 2648 <__aeabi_uldivmod+0x24>)
    2640:	1840      	adds	r0, r0, r1
    2642:	9002      	str	r0, [sp, #8]
    2644:	bd03      	pop	{r0, r1, pc}
    2646:	46c0      	nop			; (mov r8, r8)
    2648:	ffffffd9 	.word	0xffffffd9
    264c:	b403      	push	{r0, r1}
    264e:	4668      	mov	r0, sp
    2650:	b501      	push	{r0, lr}
    2652:	9802      	ldr	r0, [sp, #8]
    2654:	f000 f806 	bl	2664 <__udivmoddi4>
    2658:	9b01      	ldr	r3, [sp, #4]
    265a:	469e      	mov	lr, r3
    265c:	b002      	add	sp, #8
    265e:	bc0c      	pop	{r2, r3}
    2660:	4770      	bx	lr
    2662:	46c0      	nop			; (mov r8, r8)

00002664 <__udivmoddi4>:
    2664:	b5f0      	push	{r4, r5, r6, r7, lr}
    2666:	4657      	mov	r7, sl
    2668:	464e      	mov	r6, r9
    266a:	4645      	mov	r5, r8
    266c:	46de      	mov	lr, fp
    266e:	b5e0      	push	{r5, r6, r7, lr}
    2670:	0004      	movs	r4, r0
    2672:	b083      	sub	sp, #12
    2674:	000d      	movs	r5, r1
    2676:	4692      	mov	sl, r2
    2678:	4699      	mov	r9, r3
    267a:	428b      	cmp	r3, r1
    267c:	d82f      	bhi.n	26de <__udivmoddi4+0x7a>
    267e:	d02c      	beq.n	26da <__udivmoddi4+0x76>
    2680:	4649      	mov	r1, r9
    2682:	4650      	mov	r0, sl
    2684:	f000 f8ae 	bl	27e4 <__clzdi2>
    2688:	0029      	movs	r1, r5
    268a:	0006      	movs	r6, r0
    268c:	0020      	movs	r0, r4
    268e:	f000 f8a9 	bl	27e4 <__clzdi2>
    2692:	1a33      	subs	r3, r6, r0
    2694:	4698      	mov	r8, r3
    2696:	3b20      	subs	r3, #32
    2698:	469b      	mov	fp, r3
    269a:	d500      	bpl.n	269e <__udivmoddi4+0x3a>
    269c:	e074      	b.n	2788 <__udivmoddi4+0x124>
    269e:	4653      	mov	r3, sl
    26a0:	465a      	mov	r2, fp
    26a2:	4093      	lsls	r3, r2
    26a4:	001f      	movs	r7, r3
    26a6:	4653      	mov	r3, sl
    26a8:	4642      	mov	r2, r8
    26aa:	4093      	lsls	r3, r2
    26ac:	001e      	movs	r6, r3
    26ae:	42af      	cmp	r7, r5
    26b0:	d829      	bhi.n	2706 <__udivmoddi4+0xa2>
    26b2:	d026      	beq.n	2702 <__udivmoddi4+0x9e>
    26b4:	465b      	mov	r3, fp
    26b6:	1ba4      	subs	r4, r4, r6
    26b8:	41bd      	sbcs	r5, r7
    26ba:	2b00      	cmp	r3, #0
    26bc:	da00      	bge.n	26c0 <__udivmoddi4+0x5c>
    26be:	e079      	b.n	27b4 <__udivmoddi4+0x150>
    26c0:	2200      	movs	r2, #0
    26c2:	2300      	movs	r3, #0
    26c4:	9200      	str	r2, [sp, #0]
    26c6:	9301      	str	r3, [sp, #4]
    26c8:	2301      	movs	r3, #1
    26ca:	465a      	mov	r2, fp
    26cc:	4093      	lsls	r3, r2
    26ce:	9301      	str	r3, [sp, #4]
    26d0:	2301      	movs	r3, #1
    26d2:	4642      	mov	r2, r8
    26d4:	4093      	lsls	r3, r2
    26d6:	9300      	str	r3, [sp, #0]
    26d8:	e019      	b.n	270e <__udivmoddi4+0xaa>
    26da:	4282      	cmp	r2, r0
    26dc:	d9d0      	bls.n	2680 <__udivmoddi4+0x1c>
    26de:	2200      	movs	r2, #0
    26e0:	2300      	movs	r3, #0
    26e2:	9200      	str	r2, [sp, #0]
    26e4:	9301      	str	r3, [sp, #4]
    26e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    26e8:	2b00      	cmp	r3, #0
    26ea:	d001      	beq.n	26f0 <__udivmoddi4+0x8c>
    26ec:	601c      	str	r4, [r3, #0]
    26ee:	605d      	str	r5, [r3, #4]
    26f0:	9800      	ldr	r0, [sp, #0]
    26f2:	9901      	ldr	r1, [sp, #4]
    26f4:	b003      	add	sp, #12
    26f6:	bc3c      	pop	{r2, r3, r4, r5}
    26f8:	4690      	mov	r8, r2
    26fa:	4699      	mov	r9, r3
    26fc:	46a2      	mov	sl, r4
    26fe:	46ab      	mov	fp, r5
    2700:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2702:	42a3      	cmp	r3, r4
    2704:	d9d6      	bls.n	26b4 <__udivmoddi4+0x50>
    2706:	2200      	movs	r2, #0
    2708:	2300      	movs	r3, #0
    270a:	9200      	str	r2, [sp, #0]
    270c:	9301      	str	r3, [sp, #4]
    270e:	4643      	mov	r3, r8
    2710:	2b00      	cmp	r3, #0
    2712:	d0e8      	beq.n	26e6 <__udivmoddi4+0x82>
    2714:	07fb      	lsls	r3, r7, #31
    2716:	0872      	lsrs	r2, r6, #1
    2718:	431a      	orrs	r2, r3
    271a:	4646      	mov	r6, r8
    271c:	087b      	lsrs	r3, r7, #1
    271e:	e00e      	b.n	273e <__udivmoddi4+0xda>
    2720:	42ab      	cmp	r3, r5
    2722:	d101      	bne.n	2728 <__udivmoddi4+0xc4>
    2724:	42a2      	cmp	r2, r4
    2726:	d80c      	bhi.n	2742 <__udivmoddi4+0xde>
    2728:	1aa4      	subs	r4, r4, r2
    272a:	419d      	sbcs	r5, r3
    272c:	2001      	movs	r0, #1
    272e:	1924      	adds	r4, r4, r4
    2730:	416d      	adcs	r5, r5
    2732:	2100      	movs	r1, #0
    2734:	3e01      	subs	r6, #1
    2736:	1824      	adds	r4, r4, r0
    2738:	414d      	adcs	r5, r1
    273a:	2e00      	cmp	r6, #0
    273c:	d006      	beq.n	274c <__udivmoddi4+0xe8>
    273e:	42ab      	cmp	r3, r5
    2740:	d9ee      	bls.n	2720 <__udivmoddi4+0xbc>
    2742:	3e01      	subs	r6, #1
    2744:	1924      	adds	r4, r4, r4
    2746:	416d      	adcs	r5, r5
    2748:	2e00      	cmp	r6, #0
    274a:	d1f8      	bne.n	273e <__udivmoddi4+0xda>
    274c:	465b      	mov	r3, fp
    274e:	9800      	ldr	r0, [sp, #0]
    2750:	9901      	ldr	r1, [sp, #4]
    2752:	1900      	adds	r0, r0, r4
    2754:	4169      	adcs	r1, r5
    2756:	2b00      	cmp	r3, #0
    2758:	db22      	blt.n	27a0 <__udivmoddi4+0x13c>
    275a:	002b      	movs	r3, r5
    275c:	465a      	mov	r2, fp
    275e:	40d3      	lsrs	r3, r2
    2760:	002a      	movs	r2, r5
    2762:	4644      	mov	r4, r8
    2764:	40e2      	lsrs	r2, r4
    2766:	001c      	movs	r4, r3
    2768:	465b      	mov	r3, fp
    276a:	0015      	movs	r5, r2
    276c:	2b00      	cmp	r3, #0
    276e:	db2c      	blt.n	27ca <__udivmoddi4+0x166>
    2770:	0026      	movs	r6, r4
    2772:	409e      	lsls	r6, r3
    2774:	0033      	movs	r3, r6
    2776:	0026      	movs	r6, r4
    2778:	4647      	mov	r7, r8
    277a:	40be      	lsls	r6, r7
    277c:	0032      	movs	r2, r6
    277e:	1a80      	subs	r0, r0, r2
    2780:	4199      	sbcs	r1, r3
    2782:	9000      	str	r0, [sp, #0]
    2784:	9101      	str	r1, [sp, #4]
    2786:	e7ae      	b.n	26e6 <__udivmoddi4+0x82>
    2788:	4642      	mov	r2, r8
    278a:	2320      	movs	r3, #32
    278c:	1a9b      	subs	r3, r3, r2
    278e:	4652      	mov	r2, sl
    2790:	40da      	lsrs	r2, r3
    2792:	4641      	mov	r1, r8
    2794:	0013      	movs	r3, r2
    2796:	464a      	mov	r2, r9
    2798:	408a      	lsls	r2, r1
    279a:	0017      	movs	r7, r2
    279c:	431f      	orrs	r7, r3
    279e:	e782      	b.n	26a6 <__udivmoddi4+0x42>
    27a0:	4642      	mov	r2, r8
    27a2:	2320      	movs	r3, #32
    27a4:	1a9b      	subs	r3, r3, r2
    27a6:	002a      	movs	r2, r5
    27a8:	4646      	mov	r6, r8
    27aa:	409a      	lsls	r2, r3
    27ac:	0023      	movs	r3, r4
    27ae:	40f3      	lsrs	r3, r6
    27b0:	4313      	orrs	r3, r2
    27b2:	e7d5      	b.n	2760 <__udivmoddi4+0xfc>
    27b4:	4642      	mov	r2, r8
    27b6:	2320      	movs	r3, #32
    27b8:	2100      	movs	r1, #0
    27ba:	1a9b      	subs	r3, r3, r2
    27bc:	2200      	movs	r2, #0
    27be:	9100      	str	r1, [sp, #0]
    27c0:	9201      	str	r2, [sp, #4]
    27c2:	2201      	movs	r2, #1
    27c4:	40da      	lsrs	r2, r3
    27c6:	9201      	str	r2, [sp, #4]
    27c8:	e782      	b.n	26d0 <__udivmoddi4+0x6c>
    27ca:	4642      	mov	r2, r8
    27cc:	2320      	movs	r3, #32
    27ce:	0026      	movs	r6, r4
    27d0:	1a9b      	subs	r3, r3, r2
    27d2:	40de      	lsrs	r6, r3
    27d4:	002f      	movs	r7, r5
    27d6:	46b4      	mov	ip, r6
    27d8:	4097      	lsls	r7, r2
    27da:	4666      	mov	r6, ip
    27dc:	003b      	movs	r3, r7
    27de:	4333      	orrs	r3, r6
    27e0:	e7c9      	b.n	2776 <__udivmoddi4+0x112>
    27e2:	46c0      	nop			; (mov r8, r8)

000027e4 <__clzdi2>:
    27e4:	b510      	push	{r4, lr}
    27e6:	2900      	cmp	r1, #0
    27e8:	d103      	bne.n	27f2 <__clzdi2+0xe>
    27ea:	f000 f807 	bl	27fc <__clzsi2>
    27ee:	3020      	adds	r0, #32
    27f0:	e002      	b.n	27f8 <__clzdi2+0x14>
    27f2:	1c08      	adds	r0, r1, #0
    27f4:	f000 f802 	bl	27fc <__clzsi2>
    27f8:	bd10      	pop	{r4, pc}
    27fa:	46c0      	nop			; (mov r8, r8)

000027fc <__clzsi2>:
    27fc:	211c      	movs	r1, #28
    27fe:	2301      	movs	r3, #1
    2800:	041b      	lsls	r3, r3, #16
    2802:	4298      	cmp	r0, r3
    2804:	d301      	bcc.n	280a <__clzsi2+0xe>
    2806:	0c00      	lsrs	r0, r0, #16
    2808:	3910      	subs	r1, #16
    280a:	0a1b      	lsrs	r3, r3, #8
    280c:	4298      	cmp	r0, r3
    280e:	d301      	bcc.n	2814 <__clzsi2+0x18>
    2810:	0a00      	lsrs	r0, r0, #8
    2812:	3908      	subs	r1, #8
    2814:	091b      	lsrs	r3, r3, #4
    2816:	4298      	cmp	r0, r3
    2818:	d301      	bcc.n	281e <__clzsi2+0x22>
    281a:	0900      	lsrs	r0, r0, #4
    281c:	3904      	subs	r1, #4
    281e:	a202      	add	r2, pc, #8	; (adr r2, 2828 <__clzsi2+0x2c>)
    2820:	5c10      	ldrb	r0, [r2, r0]
    2822:	1840      	adds	r0, r0, r1
    2824:	4770      	bx	lr
    2826:	46c0      	nop			; (mov r8, r8)
    2828:	02020304 	.word	0x02020304
    282c:	01010101 	.word	0x01010101
	...

00002838 <__libc_init_array>:
    2838:	b570      	push	{r4, r5, r6, lr}
    283a:	4e0d      	ldr	r6, [pc, #52]	; (2870 <__libc_init_array+0x38>)
    283c:	4d0d      	ldr	r5, [pc, #52]	; (2874 <__libc_init_array+0x3c>)
    283e:	2400      	movs	r4, #0
    2840:	1bad      	subs	r5, r5, r6
    2842:	10ad      	asrs	r5, r5, #2
    2844:	d005      	beq.n	2852 <__libc_init_array+0x1a>
    2846:	00a3      	lsls	r3, r4, #2
    2848:	58f3      	ldr	r3, [r6, r3]
    284a:	3401      	adds	r4, #1
    284c:	4798      	blx	r3
    284e:	42a5      	cmp	r5, r4
    2850:	d1f9      	bne.n	2846 <__libc_init_array+0xe>
    2852:	f000 fa39 	bl	2cc8 <_init>
    2856:	4e08      	ldr	r6, [pc, #32]	; (2878 <__libc_init_array+0x40>)
    2858:	4d08      	ldr	r5, [pc, #32]	; (287c <__libc_init_array+0x44>)
    285a:	2400      	movs	r4, #0
    285c:	1bad      	subs	r5, r5, r6
    285e:	10ad      	asrs	r5, r5, #2
    2860:	d005      	beq.n	286e <__libc_init_array+0x36>
    2862:	00a3      	lsls	r3, r4, #2
    2864:	58f3      	ldr	r3, [r6, r3]
    2866:	3401      	adds	r4, #1
    2868:	4798      	blx	r3
    286a:	42a5      	cmp	r5, r4
    286c:	d1f9      	bne.n	2862 <__libc_init_array+0x2a>
    286e:	bd70      	pop	{r4, r5, r6, pc}
    2870:	00002cd4 	.word	0x00002cd4
    2874:	00002cd4 	.word	0x00002cd4
    2878:	00002cd4 	.word	0x00002cd4
    287c:	00002cdc 	.word	0x00002cdc

00002880 <register_fini>:
    2880:	4b03      	ldr	r3, [pc, #12]	; (2890 <register_fini+0x10>)
    2882:	b510      	push	{r4, lr}
    2884:	2b00      	cmp	r3, #0
    2886:	d002      	beq.n	288e <register_fini+0xe>
    2888:	4802      	ldr	r0, [pc, #8]	; (2894 <register_fini+0x14>)
    288a:	f000 f805 	bl	2898 <atexit>
    288e:	bd10      	pop	{r4, pc}
    2890:	00000000 	.word	0x00000000
    2894:	000028a9 	.word	0x000028a9

00002898 <atexit>:
    2898:	b510      	push	{r4, lr}
    289a:	0001      	movs	r1, r0
    289c:	2300      	movs	r3, #0
    289e:	2200      	movs	r2, #0
    28a0:	2000      	movs	r0, #0
    28a2:	f000 f81f 	bl	28e4 <__register_exitproc>
    28a6:	bd10      	pop	{r4, pc}

000028a8 <__libc_fini_array>:
    28a8:	b570      	push	{r4, r5, r6, lr}
    28aa:	4b09      	ldr	r3, [pc, #36]	; (28d0 <__libc_fini_array+0x28>)
    28ac:	4c09      	ldr	r4, [pc, #36]	; (28d4 <__libc_fini_array+0x2c>)
    28ae:	1ae4      	subs	r4, r4, r3
    28b0:	10a4      	asrs	r4, r4, #2
    28b2:	d009      	beq.n	28c8 <__libc_fini_array+0x20>
    28b4:	4a08      	ldr	r2, [pc, #32]	; (28d8 <__libc_fini_array+0x30>)
    28b6:	18a5      	adds	r5, r4, r2
    28b8:	00ad      	lsls	r5, r5, #2
    28ba:	18ed      	adds	r5, r5, r3
    28bc:	682b      	ldr	r3, [r5, #0]
    28be:	3c01      	subs	r4, #1
    28c0:	4798      	blx	r3
    28c2:	3d04      	subs	r5, #4
    28c4:	2c00      	cmp	r4, #0
    28c6:	d1f9      	bne.n	28bc <__libc_fini_array+0x14>
    28c8:	f000 fa08 	bl	2cdc <_fini>
    28cc:	bd70      	pop	{r4, r5, r6, pc}
    28ce:	46c0      	nop			; (mov r8, r8)
    28d0:	00002ce8 	.word	0x00002ce8
    28d4:	00002cec 	.word	0x00002cec
    28d8:	3fffffff 	.word	0x3fffffff

000028dc <__retarget_lock_acquire_recursive>:
    28dc:	4770      	bx	lr
    28de:	46c0      	nop			; (mov r8, r8)

000028e0 <__retarget_lock_release_recursive>:
    28e0:	4770      	bx	lr
    28e2:	46c0      	nop			; (mov r8, r8)

000028e4 <__register_exitproc>:
    28e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    28e6:	464e      	mov	r6, r9
    28e8:	4645      	mov	r5, r8
    28ea:	46de      	mov	lr, fp
    28ec:	4657      	mov	r7, sl
    28ee:	b5e0      	push	{r5, r6, r7, lr}
    28f0:	4d36      	ldr	r5, [pc, #216]	; (29cc <__register_exitproc+0xe8>)
    28f2:	b083      	sub	sp, #12
    28f4:	0006      	movs	r6, r0
    28f6:	6828      	ldr	r0, [r5, #0]
    28f8:	4698      	mov	r8, r3
    28fa:	000f      	movs	r7, r1
    28fc:	4691      	mov	r9, r2
    28fe:	f7ff ffed 	bl	28dc <__retarget_lock_acquire_recursive>
    2902:	4b33      	ldr	r3, [pc, #204]	; (29d0 <__register_exitproc+0xec>)
    2904:	681c      	ldr	r4, [r3, #0]
    2906:	23a4      	movs	r3, #164	; 0xa4
    2908:	005b      	lsls	r3, r3, #1
    290a:	58e0      	ldr	r0, [r4, r3]
    290c:	2800      	cmp	r0, #0
    290e:	d052      	beq.n	29b6 <__register_exitproc+0xd2>
    2910:	6843      	ldr	r3, [r0, #4]
    2912:	2b1f      	cmp	r3, #31
    2914:	dc13      	bgt.n	293e <__register_exitproc+0x5a>
    2916:	1c5a      	adds	r2, r3, #1
    2918:	9201      	str	r2, [sp, #4]
    291a:	2e00      	cmp	r6, #0
    291c:	d128      	bne.n	2970 <__register_exitproc+0x8c>
    291e:	9a01      	ldr	r2, [sp, #4]
    2920:	3302      	adds	r3, #2
    2922:	009b      	lsls	r3, r3, #2
    2924:	6042      	str	r2, [r0, #4]
    2926:	501f      	str	r7, [r3, r0]
    2928:	6828      	ldr	r0, [r5, #0]
    292a:	f7ff ffd9 	bl	28e0 <__retarget_lock_release_recursive>
    292e:	2000      	movs	r0, #0
    2930:	b003      	add	sp, #12
    2932:	bc3c      	pop	{r2, r3, r4, r5}
    2934:	4690      	mov	r8, r2
    2936:	4699      	mov	r9, r3
    2938:	46a2      	mov	sl, r4
    293a:	46ab      	mov	fp, r5
    293c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    293e:	4b25      	ldr	r3, [pc, #148]	; (29d4 <__register_exitproc+0xf0>)
    2940:	2b00      	cmp	r3, #0
    2942:	d03d      	beq.n	29c0 <__register_exitproc+0xdc>
    2944:	20c8      	movs	r0, #200	; 0xc8
    2946:	0040      	lsls	r0, r0, #1
    2948:	e000      	b.n	294c <__register_exitproc+0x68>
    294a:	bf00      	nop
    294c:	2800      	cmp	r0, #0
    294e:	d037      	beq.n	29c0 <__register_exitproc+0xdc>
    2950:	22a4      	movs	r2, #164	; 0xa4
    2952:	2300      	movs	r3, #0
    2954:	0052      	lsls	r2, r2, #1
    2956:	58a1      	ldr	r1, [r4, r2]
    2958:	6043      	str	r3, [r0, #4]
    295a:	6001      	str	r1, [r0, #0]
    295c:	50a0      	str	r0, [r4, r2]
    295e:	3240      	adds	r2, #64	; 0x40
    2960:	5083      	str	r3, [r0, r2]
    2962:	3204      	adds	r2, #4
    2964:	5083      	str	r3, [r0, r2]
    2966:	3301      	adds	r3, #1
    2968:	9301      	str	r3, [sp, #4]
    296a:	2300      	movs	r3, #0
    296c:	2e00      	cmp	r6, #0
    296e:	d0d6      	beq.n	291e <__register_exitproc+0x3a>
    2970:	009a      	lsls	r2, r3, #2
    2972:	4692      	mov	sl, r2
    2974:	4482      	add	sl, r0
    2976:	464a      	mov	r2, r9
    2978:	2188      	movs	r1, #136	; 0x88
    297a:	4654      	mov	r4, sl
    297c:	5062      	str	r2, [r4, r1]
    297e:	22c4      	movs	r2, #196	; 0xc4
    2980:	0052      	lsls	r2, r2, #1
    2982:	4691      	mov	r9, r2
    2984:	4481      	add	r9, r0
    2986:	464a      	mov	r2, r9
    2988:	3987      	subs	r1, #135	; 0x87
    298a:	4099      	lsls	r1, r3
    298c:	6812      	ldr	r2, [r2, #0]
    298e:	468b      	mov	fp, r1
    2990:	430a      	orrs	r2, r1
    2992:	4694      	mov	ip, r2
    2994:	464a      	mov	r2, r9
    2996:	4661      	mov	r1, ip
    2998:	6011      	str	r1, [r2, #0]
    299a:	2284      	movs	r2, #132	; 0x84
    299c:	4641      	mov	r1, r8
    299e:	0052      	lsls	r2, r2, #1
    29a0:	50a1      	str	r1, [r4, r2]
    29a2:	2e02      	cmp	r6, #2
    29a4:	d1bb      	bne.n	291e <__register_exitproc+0x3a>
    29a6:	0002      	movs	r2, r0
    29a8:	465c      	mov	r4, fp
    29aa:	328d      	adds	r2, #141	; 0x8d
    29ac:	32ff      	adds	r2, #255	; 0xff
    29ae:	6811      	ldr	r1, [r2, #0]
    29b0:	430c      	orrs	r4, r1
    29b2:	6014      	str	r4, [r2, #0]
    29b4:	e7b3      	b.n	291e <__register_exitproc+0x3a>
    29b6:	0020      	movs	r0, r4
    29b8:	304d      	adds	r0, #77	; 0x4d
    29ba:	30ff      	adds	r0, #255	; 0xff
    29bc:	50e0      	str	r0, [r4, r3]
    29be:	e7a7      	b.n	2910 <__register_exitproc+0x2c>
    29c0:	6828      	ldr	r0, [r5, #0]
    29c2:	f7ff ff8d 	bl	28e0 <__retarget_lock_release_recursive>
    29c6:	2001      	movs	r0, #1
    29c8:	4240      	negs	r0, r0
    29ca:	e7b1      	b.n	2930 <__register_exitproc+0x4c>
    29cc:	20000438 	.word	0x20000438
    29d0:	00002cc4 	.word	0x00002cc4
    29d4:	00000000 	.word	0x00000000
    29d8:	72617473 	.word	0x72617473
    29dc:	6e692074 	.word	0x6e692074
    29e0:	000a7469 	.word	0x000a7469
    29e4:	74696e69 	.word	0x74696e69
    29e8:	6e6f6420 	.word	0x6e6f6420
    29ec:	00000a65 	.word	0x00000a65
    29f0:	72617473 	.word	0x72617473
    29f4:	6f6d2074 	.word	0x6f6d2074
    29f8:	0a746e75 	.word	0x0a746e75
    29fc:	00000000 	.word	0x00000000
    2a00:	20646e65 	.word	0x20646e65
    2a04:	6e756f6d 	.word	0x6e756f6d
    2a08:	00000a74 	.word	0x00000a74
    2a0c:	7272450a 	.word	0x7272450a
    2a10:	6d20726f 	.word	0x6d20726f
    2a14:	746e756f 	.word	0x746e756f
    2a18:	20676e69 	.word	0x20676e69
    2a1c:	656c6966 	.word	0x656c6966
    2a20:	73797320 	.word	0x73797320
    2a24:	0d6d6574 	.word	0x0d6d6574
    2a28:	0000000a 	.word	0x0000000a
    2a2c:	72617473 	.word	0x72617473
    2a30:	706f2074 	.word	0x706f2074
    2a34:	000a6e65 	.word	0x000a6e65
    2a38:	20646e65 	.word	0x20646e65
    2a3c:	6e65706f 	.word	0x6e65706f
    2a40:	0000000a 	.word	0x0000000a
    2a44:	6f727245 	.word	0x6f727245
    2a48:	706f2072 	.word	0x706f2072
    2a4c:	6e696e65 	.word	0x6e696e65
    2a50:	69662067 	.word	0x69662067
    2a54:	0a0d656c 	.word	0x0a0d656c
    2a58:	00000000 	.word	0x00000000
    2a5c:	61746144 	.word	0x61746144
    2a60:	442c2031 	.word	0x442c2031
    2a64:	32617461 	.word	0x32617461
    2a68:	61442c20 	.word	0x61442c20
    2a6c:	20336174 	.word	0x20336174
    2a70:	7461442c 	.word	0x7461442c
    2a74:	0d203461 	.word	0x0d203461
    2a78:	0000000a 	.word	0x0000000a
    2a7c:	7272450a 	.word	0x7272450a
    2a80:	7720726f 	.word	0x7720726f
    2a84:	69746972 	.word	0x69746972
    2a88:	7420676e 	.word	0x7420676e
    2a8c:	6966206f 	.word	0x6966206f
    2a90:	0a0d656c 	.word	0x0a0d656c
    2a94:	00000000 	.word	0x00000000
    2a98:	7272450a 	.word	0x7272450a
    2a9c:	6320726f 	.word	0x6320726f
    2aa0:	69736f6c 	.word	0x69736f6c
    2aa4:	6620676e 	.word	0x6620676e
    2aa8:	0d656c69 	.word	0x0d656c69
    2aac:	0000000a 	.word	0x0000000a
    2ab0:	63637553 	.word	0x63637553
    2ab4:	66737365 	.word	0x66737365
    2ab8:	57206c75 	.word	0x57206c75
    2abc:	65746972 	.word	0x65746972
    2ac0:	6c694620 	.word	0x6c694620
    2ac4:	6f442065 	.word	0x6f442065
    2ac8:	0a21656e 	.word	0x0a21656e
    2acc:	00000000 	.word	0x00000000
    2ad0:	72617453 	.word	0x72617453
    2ad4:	65522074 	.word	0x65522074
    2ad8:	000a6461 	.word	0x000a6461
    2adc:	64616552 	.word	0x64616552
    2ae0:	20676e69 	.word	0x20676e69
    2ae4:	646f6f47 	.word	0x646f6f47
    2ae8:	0000000a 	.word	0x0000000a
    2aec:	64616552 	.word	0x64616552
    2af0:	72724520 	.word	0x72724520
    2af4:	000a726f 	.word	0x000a726f
    2af8:	20656854 	.word	0x20656854
    2afc:	656c6966 	.word	0x656c6966
    2b00:	6e6f6320 	.word	0x6e6f6320
    2b04:	6e696174 	.word	0x6e696174
    2b08:	0a203a73 	.word	0x0a203a73
    2b0c:	00000000 	.word	0x00000000
    2b10:	64616552 	.word	0x64616552
    2b14:	20676e69 	.word	0x20676e69
    2b18:	656e6f44 	.word	0x656e6f44
    2b1c:	0000000a 	.word	0x0000000a
    2b20:	736f6c43 	.word	0x736f6c43
    2b24:	20676e69 	.word	0x20676e69
    2b28:	656c6946 	.word	0x656c6946
    2b2c:	0000000a 	.word	0x0000000a
    2b30:	736f6c43 	.word	0x736f6c43
    2b34:	65522065 	.word	0x65522065
    2b38:	45206461 	.word	0x45206461
    2b3c:	726f7272 	.word	0x726f7272
    2b40:	0000000a 	.word	0x0000000a
    2b44:	736f6c43 	.word	0x736f6c43
    2b48:	20676e69 	.word	0x20676e69
    2b4c:	63637553 	.word	0x63637553
    2b50:	0a737365 	.word	0x0a737365
    2b54:	00000000 	.word	0x00000000
    2b58:	64616572 	.word	0x64616572
    2b5c:	0a203220 	.word	0x0a203220
    2b60:	00000000 	.word	0x00000000
    2b64:	74697277 	.word	0x74697277
    2b68:	20312065 	.word	0x20312065
    2b6c:	0000000a 	.word	0x0000000a
    2b70:	74697277 	.word	0x74697277
    2b74:	20322065 	.word	0x20322065
    2b78:	0000000a 	.word	0x0000000a
    2b7c:	2c2b2a22 	.word	0x2c2b2a22
    2b80:	3d3c3b3a 	.word	0x3d3c3b3a
    2b84:	5d5b3f3e 	.word	0x5d5b3f3e
    2b88:	00007f7c 	.word	0x00007f7c
    2b8c:	6c696146 	.word	0x6c696146
    2b90:	6f742065 	.word	0x6f742065
    2b94:	73657220 	.word	0x73657220
    2b98:	63207465 	.word	0x63207465
    2b9c:	00647261 	.word	0x00647261
    2ba0:	626f7250 	.word	0x626f7250
    2ba4:	206d656c 	.word	0x206d656c
    2ba8:	696b6174 	.word	0x696b6174
    2bac:	4f20676e 	.word	0x4f20676e
    2bb0:	64205243 	.word	0x64205243
    2bb4:	0a617461 	.word	0x0a617461
    2bb8:	00000000 	.word	0x00000000
    2bbc:	64726143 	.word	0x64726143
    2bc0:	3256203a 	.word	0x3256203a
    2bc4:	5320302e 	.word	0x5320302e
    2bc8:	0a434844 	.word	0x0a434844
    2bcc:	00000000 	.word	0x00000000
    2bd0:	64726143 	.word	0x64726143
    2bd4:	70795420 	.word	0x70795420
    2bd8:	56203a65 	.word	0x56203a65
    2bdc:	0a302e32 	.word	0x0a302e32
    2be0:	00000000 	.word	0x00000000
    2be4:	74696e49 	.word	0x74696e49
    2be8:	696c6169 	.word	0x696c6169
    2bec:	6974617a 	.word	0x6974617a
    2bf0:	43206e6f 	.word	0x43206e6f
    2bf4:	6c706d6f 	.word	0x6c706d6f
    2bf8:	20657465 	.word	0x20657465
    2bfc:	0000000a 	.word	0x0000000a
    2c00:	20746f4e 	.word	0x20746f4e
    2c04:	545f4453 	.word	0x545f4453
    2c08:	5f455059 	.word	0x5f455059
    2c0c:	43483256 	.word	0x43483256
    2c10:	0000000a 	.word	0x0000000a
    2c14:	64616552 	.word	0x64616552
    2c18:	6f6c6220 	.word	0x6f6c6220
    2c1c:	61206b63 	.word	0x61206b63
    2c20:	65726464 	.word	0x65726464
    2c24:	000a7373 	.word	0x000a7373
    2c28:	64616552 	.word	0x64616552
    2c2c:	0a676e69 	.word	0x0a676e69
    2c30:	00000000 	.word	0x00000000
    2c34:	64616552 	.word	0x64616552
    2c38:	6d6f6320 	.word	0x6d6f6320
    2c3c:	74656c70 	.word	0x74656c70
    2c40:	00000a65 	.word	0x00000a65
    2c44:	20435243 	.word	0x20435243
    2c48:	74697257 	.word	0x74697257
    2c4c:	61462065 	.word	0x61462065
    2c50:	00006c69 	.word	0x00006c69
    2c54:	74697257 	.word	0x74697257
    2c58:	6f432065 	.word	0x6f432065
    2c5c:	656c706d 	.word	0x656c706d
    2c60:	000a6574 	.word	0x000a6574
    2c64:	74697257 	.word	0x74697257
    2c68:	754d2065 	.word	0x754d2065
    2c6c:	7069746c 	.word	0x7069746c
    2c70:	4220656c 	.word	0x4220656c
    2c74:	6b636f6c 	.word	0x6b636f6c
    2c78:	64644120 	.word	0x64644120
    2c7c:	73736572 	.word	0x73736572
    2c80:	69614620 	.word	0x69614620
    2c84:	0a64656c 	.word	0x0a64656c
    2c88:	00000000 	.word	0x00000000
    2c8c:	20435243 	.word	0x20435243
    2c90:	746c754d 	.word	0x746c754d
    2c94:	656c7069 	.word	0x656c7069
    2c98:	69725720 	.word	0x69725720
    2c9c:	46206574 	.word	0x46206574
    2ca0:	656c6961 	.word	0x656c6961
    2ca4:	00000a64 	.word	0x00000a64
    2ca8:	74697257 	.word	0x74697257
    2cac:	754d2065 	.word	0x754d2065
    2cb0:	7069746c 	.word	0x7069746c
    2cb4:	4320656c 	.word	0x4320656c
    2cb8:	6c706d6f 	.word	0x6c706d6f
    2cbc:	0a657465 	.word	0x0a657465
    2cc0:	00000000 	.word	0x00000000

00002cc4 <_global_impure_ptr>:
    2cc4:	20000010                                ... 

00002cc8 <_init>:
    2cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2cca:	46c0      	nop			; (mov r8, r8)
    2ccc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2cce:	bc08      	pop	{r3}
    2cd0:	469e      	mov	lr, r3
    2cd2:	4770      	bx	lr

00002cd4 <__init_array_start>:
    2cd4:	00002881 	.word	0x00002881

00002cd8 <__frame_dummy_init_array_entry>:
    2cd8:	000000dd                                ....

00002cdc <_fini>:
    2cdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2cde:	46c0      	nop			; (mov r8, r8)
    2ce0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2ce2:	bc08      	pop	{r3}
    2ce4:	469e      	mov	lr, r3
    2ce6:	4770      	bx	lr

00002ce8 <__fini_array_start>:
    2ce8:	000000b5 	.word	0x000000b5
