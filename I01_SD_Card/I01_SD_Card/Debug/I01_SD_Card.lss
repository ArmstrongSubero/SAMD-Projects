
I01_SD_Card.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d10  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00002d10  00002d10  00012d10  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  00002d18  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000006b0  2000043c  00003154  0002043c  2**2
                  ALLOC
  4 .stack        00002004  20000aec  00003804  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  7 .debug_info   000115a8  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000012a0  00000000  00000000  00031a65  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005c52  00000000  00000000  00032d05  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000368  00000000  00000000  00038957  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000360  00000000  00000000  00038cbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013984  00000000  00000000  0003901f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00004c06  00000000  00000000  0004c9a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000749ff  00000000  00000000  000515a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000ba8  00000000  00000000  000c5fa8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	f0 2a 00 20 f5 03 00 00 f1 03 00 00 f1 03 00 00     .*. ............
	...
      2c:	f1 03 00 00 00 00 00 00 00 00 00 00 f1 03 00 00     ................
      3c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      4c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      5c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      6c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      7c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      8c:	f1 03 00 00 f1 03 00 00 00 00 00 00 00 00 00 00     ................
      9c:	f1 03 00 00 f1 03 00 00 f1 03 00 00 f1 03 00 00     ................
      ac:	f1 03 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002d18 	.word	0x00002d18

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002d18 	.word	0x00002d18
     10c:	00002d18 	.word	0x00002d18
     110:	00000000 	.word	0x00000000

00000114 <AppInit>:
 * Note:            This was taken from the _00_LED_ON provided by
 *                  Microchip Technology Inc. 
 *
 ******************************************************************************/
void AppInit(void)
{
     114:	b510      	push	{r4, lr}
	/*	Clock initialization (CPU, AHB, APBx, Asynchronous Peripheral Clocks)
		The System RC Oscillator (RCSYS) provides the source for the main clock
		at chip startup. It is set to 1MHz.
	*/
	ClocksInit();
     116:	4b04      	ldr	r3, [pc, #16]	; (128 <AppInit+0x14>)
     118:	4798      	blx	r3
	
	// Assign SS as OUTPUT
	REG_PORT_DIR0 = PORT_PA08;
     11a:	2380      	movs	r3, #128	; 0x80
     11c:	005b      	lsls	r3, r3, #1
     11e:	4a03      	ldr	r2, [pc, #12]	; (12c <AppInit+0x18>)
     120:	6013      	str	r3, [r2, #0]
	
	// Set SS OFF
	REG_PORT_OUTCLR0 = PORT_PA08;
     122:	4a03      	ldr	r2, [pc, #12]	; (130 <AppInit+0x1c>)
     124:	6013      	str	r3, [r2, #0]
} // AppInit()
     126:	bd10      	pop	{r4, pc}
     128:	000002d9 	.word	0x000002d9
     12c:	41004400 	.word	0x41004400
     130:	41004414 	.word	0x41004414

00000134 <AppRun>:
 *
 * Note:
 *
 ******************************************************************************/
void AppRun(void)
{
     134:	b530      	push	{r4, r5, lr}
     136:	b09b      	sub	sp, #108	; 0x6c
	// Initialize the UART at 9600 baud
	UART3_Init(9600);
     138:	2096      	movs	r0, #150	; 0x96
     13a:	0180      	lsls	r0, r0, #6
     13c:	4b42      	ldr	r3, [pc, #264]	; (248 <AppRun+0x114>)
     13e:	4798      	blx	r3
	delay_ms(500);
     140:	4d42      	ldr	r5, [pc, #264]	; (24c <AppRun+0x118>)
     142:	0028      	movs	r0, r5
     144:	4c42      	ldr	r4, [pc, #264]	; (250 <AppRun+0x11c>)
     146:	47a0      	blx	r4
	
	// Initialize SPI
	SPI_Initialize_Slow();
     148:	4b42      	ldr	r3, [pc, #264]	; (254 <AppRun+0x120>)
     14a:	4798      	blx	r3
	delay_ms(500);
     14c:	0028      	movs	r0, r5
     14e:	47a0      	blx	r4
	//////////////////////////////////////////////////////////////////////////
	// Writing to File
	//////////////////////////////////////////////////////////////////////////
	
	// Start to Init the SD Card
	UART3_Write_Text("start init\n");
     150:	4841      	ldr	r0, [pc, #260]	; (258 <AppRun+0x124>)
     152:	4c42      	ldr	r4, [pc, #264]	; (25c <AppRun+0x128>)
     154:	47a0      	blx	r4
	
	// Initialize the SD Card
    SDCard_Init();
     156:	4b42      	ldr	r3, [pc, #264]	; (260 <AppRun+0x12c>)
     158:	4798      	blx	r3
	 
	// Initialize Done
	UART3_Write_Text("init done\n");
     15a:	4842      	ldr	r0, [pc, #264]	; (264 <AppRun+0x130>)
     15c:	47a0      	blx	r4
	
	// Start to mount the SD card
	UART3_Write_Text("start mount\n");
     15e:	4842      	ldr	r0, [pc, #264]	; (268 <AppRun+0x134>)
     160:	47a0      	blx	r4
	
	// Mount the file
	FR= f_mount(&fs,data_file,0);
     162:	2200      	movs	r2, #0
     164:	4941      	ldr	r1, [pc, #260]	; (26c <AppRun+0x138>)
     166:	4842      	ldr	r0, [pc, #264]	; (270 <AppRun+0x13c>)
     168:	4b42      	ldr	r3, [pc, #264]	; (274 <AppRun+0x140>)
     16a:	4798      	blx	r3
     16c:	4d42      	ldr	r5, [pc, #264]	; (278 <AppRun+0x144>)
     16e:	7028      	strb	r0, [r5, #0]
	
	// Finish Mounting
	UART3_Write_Text("end mount\n");
     170:	4842      	ldr	r0, [pc, #264]	; (27c <AppRun+0x148>)
     172:	47a0      	blx	r4
	
	// Error with mount
	if(FR)
     174:	782b      	ldrb	r3, [r5, #0]
     176:	2b00      	cmp	r3, #0
     178:	d003      	beq.n	182 <AppRun+0x4e>
	{
		UART3_Write_Text("\nError mounting file system\r\n");
     17a:	4841      	ldr	r0, [pc, #260]	; (280 <AppRun+0x14c>)
     17c:	4b37      	ldr	r3, [pc, #220]	; (25c <AppRun+0x128>)
     17e:	4798      	blx	r3
     180:	e7fe      	b.n	180 <AppRun+0x4c>
		while(1);
	}
	
	// Start Open
	UART3_Write_Text("start open\n");
     182:	4840      	ldr	r0, [pc, #256]	; (284 <AppRun+0x150>)
     184:	4d35      	ldr	r5, [pc, #212]	; (25c <AppRun+0x128>)
     186:	47a8      	blx	r5
	
	// Open the SD Card for Writing
	FR = f_open(&fil, data_file, FA_WRITE | FA_OPEN_ALWAYS);
     188:	2212      	movs	r2, #18
     18a:	4938      	ldr	r1, [pc, #224]	; (26c <AppRun+0x138>)
     18c:	483e      	ldr	r0, [pc, #248]	; (288 <AppRun+0x154>)
     18e:	4b3f      	ldr	r3, [pc, #252]	; (28c <AppRun+0x158>)
     190:	4798      	blx	r3
     192:	4c39      	ldr	r4, [pc, #228]	; (278 <AppRun+0x144>)
     194:	7020      	strb	r0, [r4, #0]
	
	// Open Successful
	UART3_Write_Text("end open\n");
     196:	483e      	ldr	r0, [pc, #248]	; (290 <AppRun+0x15c>)
     198:	47a8      	blx	r5
	
	
	// Error Opening File
	if(FR)
     19a:	7823      	ldrb	r3, [r4, #0]
     19c:	2b00      	cmp	r3, #0
     19e:	d003      	beq.n	1a8 <AppRun+0x74>
	{
		UART3_Write_Text("Error opening file\r\n");
     1a0:	483c      	ldr	r0, [pc, #240]	; (294 <AppRun+0x160>)
     1a2:	4b2e      	ldr	r3, [pc, #184]	; (25c <AppRun+0x128>)
     1a4:	4798      	blx	r3
     1a6:	e7fe      	b.n	1a6 <AppRun+0x72>
		while(1);
	}
	
	// Open File to write some CSV Data
	FR = f_write(&fil, "Data1 ,Data2 ,Data3 ,Data4 \r\n", 29, &bw); 
     1a8:	4b3b      	ldr	r3, [pc, #236]	; (298 <AppRun+0x164>)
     1aa:	221d      	movs	r2, #29
     1ac:	493b      	ldr	r1, [pc, #236]	; (29c <AppRun+0x168>)
     1ae:	4836      	ldr	r0, [pc, #216]	; (288 <AppRun+0x154>)
     1b0:	4c3b      	ldr	r4, [pc, #236]	; (2a0 <AppRun+0x16c>)
     1b2:	47a0      	blx	r4
     1b4:	4b30      	ldr	r3, [pc, #192]	; (278 <AppRun+0x144>)
     1b6:	7018      	strb	r0, [r3, #0]
	
	
	// There is an Error
	if(FR)
     1b8:	2800      	cmp	r0, #0
     1ba:	d003      	beq.n	1c4 <AppRun+0x90>
	{
		UART3_Write_Text("\nError writing to file\r\n");
     1bc:	4839      	ldr	r0, [pc, #228]	; (2a4 <AppRun+0x170>)
     1be:	4b27      	ldr	r3, [pc, #156]	; (25c <AppRun+0x128>)
     1c0:	4798      	blx	r3
     1c2:	e7fe      	b.n	1c2 <AppRun+0x8e>
		while(1);
	}
	
	// Close the file
	FR = f_close(&fil);
     1c4:	4830      	ldr	r0, [pc, #192]	; (288 <AppRun+0x154>)
     1c6:	4b38      	ldr	r3, [pc, #224]	; (2a8 <AppRun+0x174>)
     1c8:	4798      	blx	r3
     1ca:	4b2b      	ldr	r3, [pc, #172]	; (278 <AppRun+0x144>)
     1cc:	7018      	strb	r0, [r3, #0]
	
	// There is an error
	if(FR)
     1ce:	2800      	cmp	r0, #0
     1d0:	d003      	beq.n	1da <AppRun+0xa6>
	{
		UART3_Write_Text("\nError closing file\r\n");
     1d2:	4836      	ldr	r0, [pc, #216]	; (2ac <AppRun+0x178>)
     1d4:	4b21      	ldr	r3, [pc, #132]	; (25c <AppRun+0x128>)
     1d6:	4798      	blx	r3
     1d8:	e7fe      	b.n	1d8 <AppRun+0xa4>
		while(1);
	}
		
    UART3_Write_Text("Successful Write File Done!\n");
     1da:	4835      	ldr	r0, [pc, #212]	; (2b0 <AppRun+0x17c>)
     1dc:	4c1f      	ldr	r4, [pc, #124]	; (25c <AppRun+0x128>)
     1de:	47a0      	blx	r4

    //////////////////////////////////////////////////////////////////////////
	// Reading Files
	//////////////////////////////////////////////////////////////////////////
	
     UART3_Write_Text("Start Read\n");
     1e0:	4834      	ldr	r0, [pc, #208]	; (2b4 <AppRun+0x180>)
     1e2:	47a0      	blx	r4
   
     // Open the SD Card for Writing
     FR = f_open(&fil, data_file, FA_READ );
     1e4:	2201      	movs	r2, #1
     1e6:	4921      	ldr	r1, [pc, #132]	; (26c <AppRun+0x138>)
     1e8:	4827      	ldr	r0, [pc, #156]	; (288 <AppRun+0x154>)
     1ea:	4b28      	ldr	r3, [pc, #160]	; (28c <AppRun+0x158>)
     1ec:	4798      	blx	r3
     1ee:	4d22      	ldr	r5, [pc, #136]	; (278 <AppRun+0x144>)
     1f0:	7028      	strb	r0, [r5, #0]
   
     UART3_Write_Text("Reading Good\n");
     1f2:	4831      	ldr	r0, [pc, #196]	; (2b8 <AppRun+0x184>)
     1f4:	47a0      	blx	r4
	 
	 // Reading Error
	 if (FR)
     1f6:	782b      	ldrb	r3, [r5, #0]
     1f8:	2b00      	cmp	r3, #0
     1fa:	d002      	beq.n	202 <AppRun+0xce>
	 {
		 UART3_Write_Text("Read Error\n");
     1fc:	482f      	ldr	r0, [pc, #188]	; (2bc <AppRun+0x188>)
     1fe:	4b17      	ldr	r3, [pc, #92]	; (25c <AppRun+0x128>)
     200:	4798      	blx	r3
	 }
	 
	 
	 // Print Read Contents
	 UART3_Write_Text("The file contains: \n");
     202:	482f      	ldr	r0, [pc, #188]	; (2c0 <AppRun+0x18c>)
     204:	4b15      	ldr	r3, [pc, #84]	; (25c <AppRun+0x128>)
     206:	4798      	blx	r3
	  
	 char line[100]; /* Line buffer */
	 
	 /* Read every line and display it */
	 while (f_gets(line, sizeof line, &fil)) {
     208:	4d1f      	ldr	r5, [pc, #124]	; (288 <AppRun+0x154>)
     20a:	4c2e      	ldr	r4, [pc, #184]	; (2c4 <AppRun+0x190>)
     20c:	e002      	b.n	214 <AppRun+0xe0>
		 UART3_Write_Text(line);
     20e:	a801      	add	r0, sp, #4
     210:	4b12      	ldr	r3, [pc, #72]	; (25c <AppRun+0x128>)
     212:	4798      	blx	r3
	 while (f_gets(line, sizeof line, &fil)) {
     214:	002a      	movs	r2, r5
     216:	2164      	movs	r1, #100	; 0x64
     218:	a801      	add	r0, sp, #4
     21a:	47a0      	blx	r4
     21c:	2800      	cmp	r0, #0
     21e:	d1f6      	bne.n	20e <AppRun+0xda>
	 }
	 
	 
	 // Reading Good
	 UART3_Write_Text("Reading Done\n");
     220:	4829      	ldr	r0, [pc, #164]	; (2c8 <AppRun+0x194>)
     222:	4c0e      	ldr	r4, [pc, #56]	; (25c <AppRun+0x128>)
     224:	47a0      	blx	r4
	 
	 // Close the file
	 UART3_Write_Text("Closing File\n");
     226:	4829      	ldr	r0, [pc, #164]	; (2cc <AppRun+0x198>)
     228:	47a0      	blx	r4
	 
	 // Close the file
	 FR = f_close(&fil);
     22a:	4817      	ldr	r0, [pc, #92]	; (288 <AppRun+0x154>)
     22c:	4b1e      	ldr	r3, [pc, #120]	; (2a8 <AppRun+0x174>)
     22e:	4798      	blx	r3
     230:	4b11      	ldr	r3, [pc, #68]	; (278 <AppRun+0x144>)
     232:	7018      	strb	r0, [r3, #0]
	 
	 // Close read Error
	 if(FR)
     234:	2800      	cmp	r0, #0
     236:	d002      	beq.n	23e <AppRun+0x10a>
	 {
		 UART3_Write_Text("Close Read Error\n");
     238:	4825      	ldr	r0, [pc, #148]	; (2d0 <AppRun+0x19c>)
     23a:	4b08      	ldr	r3, [pc, #32]	; (25c <AppRun+0x128>)
     23c:	4798      	blx	r3
	 }
	 
	 UART3_Write_Text("Closing Success\n");
     23e:	4825      	ldr	r0, [pc, #148]	; (2d4 <AppRun+0x1a0>)
     240:	4b06      	ldr	r3, [pc, #24]	; (25c <AppRun+0x128>)
     242:	4798      	blx	r3
     244:	e7fe      	b.n	244 <AppRun+0x110>
     246:	46c0      	nop			; (mov r8, r8)
     248:	00002445 	.word	0x00002445
     24c:	003450dc 	.word	0x003450dc
     250:	000003e5 	.word	0x000003e5
     254:	00002365 	.word	0x00002365
     258:	000029f0 	.word	0x000029f0
     25c:	00002505 	.word	0x00002505
     260:	00001dc1 	.word	0x00001dc1
     264:	000029fc 	.word	0x000029fc
     268:	00002a08 	.word	0x00002a08
     26c:	20000000 	.word	0x20000000
     270:	2000046c 	.word	0x2000046c
     274:	00001629 	.word	0x00001629
     278:	2000069c 	.word	0x2000069c
     27c:	00002a18 	.word	0x00002a18
     280:	00002a24 	.word	0x00002a24
     284:	00002a44 	.word	0x00002a44
     288:	200006a4 	.word	0x200006a4
     28c:	00001699 	.word	0x00001699
     290:	00002a50 	.word	0x00002a50
     294:	00002a5c 	.word	0x00002a5c
     298:	200006a0 	.word	0x200006a0
     29c:	00002a74 	.word	0x00002a74
     2a0:	000019e5 	.word	0x000019e5
     2a4:	00002a94 	.word	0x00002a94
     2a8:	00001c8d 	.word	0x00001c8d
     2ac:	00002ab0 	.word	0x00002ab0
     2b0:	00002ac8 	.word	0x00002ac8
     2b4:	00002ae8 	.word	0x00002ae8
     2b8:	00002af4 	.word	0x00002af4
     2bc:	00002b04 	.word	0x00002b04
     2c0:	00002b10 	.word	0x00002b10
     2c4:	00001cb5 	.word	0x00001cb5
     2c8:	00002b28 	.word	0x00002b28
     2cc:	00002b38 	.word	0x00002b38
     2d0:	00002b48 	.word	0x00002b48
     2d4:	00002b5c 	.word	0x00002b5c

000002d8 <ClocksInit>:

	/* ----------------------------------------------------------------------------------------------
	* 1) Set Flash wait states for 48 MHz (per Table 37-40 in data sheet)
	*/
	
	NVMCTRL->CTRLB.bit.RWS = 1;		/* 1 wait state required @ 3.3V & 48MHz */
     2d8:	4a34      	ldr	r2, [pc, #208]	; (3ac <ClocksInit+0xd4>)
     2da:	6853      	ldr	r3, [r2, #4]
     2dc:	211e      	movs	r1, #30
     2de:	438b      	bics	r3, r1
     2e0:	391c      	subs	r1, #28
     2e2:	430b      	orrs	r3, r1
     2e4:	6053      	str	r3, [r2, #4]
		.bit.AAMPEN = 0,		/* Disable automatic amplitude control */
		.bit.EN32K = 1,			/* 32kHz output is disabled */
		.bit.XTALEN = 1			/* Crystal connected to XIN32/XOUT32 */
	};
	// Write these settings
	SYSCTRL->XOSC32K.reg = sysctrl_xosc32k.reg;
     2e6:	4b32      	ldr	r3, [pc, #200]	; (3b0 <ClocksInit+0xd8>)
     2e8:	2283      	movs	r2, #131	; 0x83
     2ea:	0092      	lsls	r2, r2, #2
     2ec:	829a      	strh	r2, [r3, #20]
	// Enable the Oscillator - Separate step per data sheet recommendation (sec 17.6.3)
	SYSCTRL->XOSC32K.bit.ENABLE = 1;
     2ee:	8a9a      	ldrh	r2, [r3, #20]
     2f0:	430a      	orrs	r2, r1
     2f2:	829a      	strh	r2, [r3, #20]
	
	// Wait for XOSC32K to stabilize
	while(!SYSCTRL->PCLKSR.bit.XOSC32KRDY);
     2f4:	001a      	movs	r2, r3
     2f6:	68d3      	ldr	r3, [r2, #12]
     2f8:	079b      	lsls	r3, r3, #30
     2fa:	d5fc      	bpl.n	2f6 <ClocksInit+0x1e>
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K	/* Apply division factor to Generator 1 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk1_gendiv.reg;
     2fc:	4b2d      	ldr	r3, [pc, #180]	; (3b4 <ClocksInit+0xdc>)
     2fe:	2202      	movs	r2, #2
     300:	32ff      	adds	r2, #255	; 0xff
     302:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 1 with XOSC32K as source
	GCLK_GENCTRL_Type gclk1_genctrl = 
     304:	4a2c      	ldr	r2, [pc, #176]	; (3b8 <ClocksInit+0xe0>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x05,		/* Generator source: XOSC32K output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K			/* Generator ID: 1 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk1_genctrl.reg;
     306:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     308:	001a      	movs	r2, r3
     30a:	7853      	ldrb	r3, [r2, #1]
     30c:	09db      	lsrs	r3, r3, #7
     30e:	d1fc      	bne.n	30a <ClocksInit+0x32>
		.bit.CLKEN = 1,			/* Enable the Generic Clock */
		.bit.GEN = GENERIC_CLOCK_GENERATOR_XOSC32K, 	/* Generic Clock Generator 1 is the source */
		.bit.ID = 0x00			/* Generic Clock Multiplexer 0 (DFLL48M Reference) */
	};
	// Write these settings
	GCLK->CLKCTRL.reg = gclk_clkctrl.reg;
     310:	4b28      	ldr	r3, [pc, #160]	; (3b4 <ClocksInit+0xdc>)
     312:	2282      	movs	r2, #130	; 0x82
     314:	01d2      	lsls	r2, r2, #7
     316:	805a      	strh	r2, [r3, #2]
	// Enable the DFLL48M in open loop mode. Without this step, attempts to go into closed loop mode at 48 MHz will
	// result in Processor Reset (you'll be at the in the Reset_Handler in startup_samd21.c).
	// PCLKSR.DFLLRDY must be one before writing to the DFLL Control register
	// Note that the DFLLRDY bit represents status of register synchronization - NOT clock stability
	// (see Data Sheet 17.6.14 Synchronization for detail)
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     318:	4a25      	ldr	r2, [pc, #148]	; (3b0 <ClocksInit+0xd8>)
     31a:	68d3      	ldr	r3, [r2, #12]
     31c:	06db      	lsls	r3, r3, #27
     31e:	d5fc      	bpl.n	31a <ClocksInit+0x42>
	SYSCTRL->DFLLCTRL.reg = (uint16_t)(SYSCTRL_DFLLCTRL_ENABLE);
     320:	2202      	movs	r2, #2
     322:	4b23      	ldr	r3, [pc, #140]	; (3b0 <ClocksInit+0xd8>)
     324:	849a      	strh	r2, [r3, #36]	; 0x24
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     326:	001a      	movs	r2, r3
     328:	68d3      	ldr	r3, [r2, #12]
     32a:	06db      	lsls	r3, r3, #27
     32c:	d5fc      	bpl.n	328 <ClocksInit+0x50>
		.bit.CSTEP = 31,		/* Coarse step - use half of the max value (63) */
		.bit.FSTEP = 511,		/* Fine step - use half of the max value (1023) */
		.bit.MUL = 1465			/* Multiplier = MAIN_CLK_FREQ (48MHz) / EXT_32K_CLK_FREQ (32768 Hz) */
	};
	// Write these settings
	SYSCTRL->DFLLMUL.reg = sysctrl_dfllmul.reg;
     32e:	4b20      	ldr	r3, [pc, #128]	; (3b0 <ClocksInit+0xd8>)
     330:	4a22      	ldr	r2, [pc, #136]	; (3bc <ClocksInit+0xe4>)
     332:	62da      	str	r2, [r3, #44]	; 0x2c
	// Wait for synchronization
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     334:	001a      	movs	r2, r3
     336:	68d3      	ldr	r3, [r2, #12]
     338:	06db      	lsls	r3, r3, #27
     33a:	d5fc      	bpl.n	336 <ClocksInit+0x5e>
	
	// To reduce lock time, load factory calibrated values into DFLLVAL (cf. Data Sheet 17.6.7.1)
	// Location of value is defined in Data Sheet Table 10-5. NVM Software Calibration Area Mapping
	
	// Get factory calibrated value for "DFLL48M COARSE CAL" from NVM Software Calibration Area
	tempDFLL48CalibrationCoarse = *(uint32_t*)FUSES_DFLL48M_COARSE_CAL_ADDR;
     33c:	4b20      	ldr	r3, [pc, #128]	; (3c0 <ClocksInit+0xe8>)
	tempDFLL48CalibrationCoarse &= FUSES_DFLL48M_COARSE_CAL_Msk;
	tempDFLL48CalibrationCoarse = tempDFLL48CalibrationCoarse>>FUSES_DFLL48M_COARSE_CAL_Pos;
	// Write the coarse calibration value
	SYSCTRL->DFLLVAL.bit.COARSE = tempDFLL48CalibrationCoarse;
     33e:	681a      	ldr	r2, [r3, #0]
     340:	491b      	ldr	r1, [pc, #108]	; (3b0 <ClocksInit+0xd8>)
     342:	6a8b      	ldr	r3, [r1, #40]	; 0x28
     344:	0e92      	lsrs	r2, r2, #26
     346:	0292      	lsls	r2, r2, #10
     348:	481e      	ldr	r0, [pc, #120]	; (3c4 <ClocksInit+0xec>)
     34a:	4003      	ands	r3, r0
     34c:	4313      	orrs	r3, r2
     34e:	628b      	str	r3, [r1, #40]	; 0x28
	// Switch DFLL48M to Closed Loop mode and enable WAITLOCK
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
     350:	000a      	movs	r2, r1
     352:	68d3      	ldr	r3, [r2, #12]
     354:	06db      	lsls	r3, r3, #27
     356:	d5fc      	bpl.n	352 <ClocksInit+0x7a>
	SYSCTRL->DFLLCTRL.reg |= (uint16_t) (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_WAITLOCK);
     358:	4a15      	ldr	r2, [pc, #84]	; (3b0 <ClocksInit+0xd8>)
     35a:	8c93      	ldrh	r3, [r2, #36]	; 0x24
     35c:	491a      	ldr	r1, [pc, #104]	; (3c8 <ClocksInit+0xf0>)
     35e:	430b      	orrs	r3, r1
     360:	8493      	strh	r3, [r2, #36]	; 0x24
		.bit.IDC = 1,			/* Generator duty cycle is 50/50 */
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x07,		/* Generator source: DFLL48M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_MAIN			/* Generator ID: 0 */
	};
	GCLK->GENCTRL.reg = gclk_genctrl0.reg;
     362:	4b14      	ldr	r3, [pc, #80]	; (3b4 <ClocksInit+0xdc>)
     364:	4a19      	ldr	r2, [pc, #100]	; (3cc <ClocksInit+0xf4>)
     366:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     368:	001a      	movs	r2, r3
     36a:	7853      	ldrb	r3, [r2, #1]
     36c:	09db      	lsrs	r3, r3, #7
     36e:	d1fc      	bne.n	36a <ClocksInit+0x92>
		.bit.PMUX = 7,			/* Peripheral Function H selected (GCLK_IO[0]) */
		.bit.PMUXEN = 1,		/* Enable peripheral Multiplexer */
		.bit.PINMASK = (uint16_t)(1 << (28-16)) /* Select the pin(s) to be configured */
	};
	// Write these settings
	PORT->Group[0].WRCONFIG.reg = port0_wrconfig.reg;
     370:	4b17      	ldr	r3, [pc, #92]	; (3d0 <ClocksInit+0xf8>)
     372:	4a18      	ldr	r2, [pc, #96]	; (3d4 <ClocksInit+0xfc>)
     374:	629a      	str	r2, [r3, #40]	; 0x28
	
	/* ----------------------------------------------------------------------------------------------
	* 7) Modify prescaler value of OSC8M to produce 8MHz output
	*/

	SYSCTRL->OSC8M.bit.PRESC = 0;		/* Prescale by 1 */
     376:	4b0e      	ldr	r3, [pc, #56]	; (3b0 <ClocksInit+0xd8>)
     378:	6a1a      	ldr	r2, [r3, #32]
     37a:	4917      	ldr	r1, [pc, #92]	; (3d8 <ClocksInit+0x100>)
     37c:	400a      	ands	r2, r1
     37e:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;	/* Oscillator is always on if enabled */
     380:	6a1a      	ldr	r2, [r3, #32]
     382:	2180      	movs	r1, #128	; 0x80
     384:	438a      	bics	r2, r1
     386:	621a      	str	r2, [r3, #32]
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M		/* Apply division factor to Generator 3 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk3_gendiv.reg;
     388:	4b0a      	ldr	r3, [pc, #40]	; (3b4 <ClocksInit+0xdc>)
     38a:	2204      	movs	r2, #4
     38c:	32ff      	adds	r2, #255	; 0xff
     38e:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 3 with OSC8M as source
	GCLK_GENCTRL_Type gclk3_genctrl = 
     390:	4a12      	ldr	r2, [pc, #72]	; (3dc <ClocksInit+0x104>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x06,		/* Generator source: OSC8M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M			/* Generator ID: 3 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk3_genctrl.reg;
     392:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
     394:	001a      	movs	r2, r3
     396:	7853      	ldrb	r3, [r2, #1]
     398:	09db      	lsrs	r3, r3, #7
     39a:	d1fc      	bne.n	396 <ClocksInit+0xbe>
	
	/* ----------------------------------------------------------------------------------------------
	* 9) Set CPU and APBx BUS Clocks to 48MHz
	*/
	PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
     39c:	4b10      	ldr	r3, [pc, #64]	; (3e0 <ClocksInit+0x108>)
     39e:	2200      	movs	r2, #0
     3a0:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
     3a2:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
     3a4:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
     3a6:	72da      	strb	r2, [r3, #11]
	
     3a8:	4770      	bx	lr
     3aa:	46c0      	nop			; (mov r8, r8)
     3ac:	41004000 	.word	0x41004000
     3b0:	40000800 	.word	0x40000800
     3b4:	40000c00 	.word	0x40000c00
     3b8:	00030501 	.word	0x00030501
     3bc:	7dff05b9 	.word	0x7dff05b9
     3c0:	00806024 	.word	0x00806024
     3c4:	ffff03ff 	.word	0xffff03ff
     3c8:	00000804 	.word	0x00000804
     3cc:	000b0700 	.word	0x000b0700
     3d0:	41004400 	.word	0x41004400
     3d4:	d7011000 	.word	0xd7011000
     3d8:	fffffcff 	.word	0xfffffcff
     3dc:	00030603 	.word	0x00030603
     3e0:	40000400 	.word	0x40000400

000003e4 <delay_n_cycles>:
 *
 ******************************************************************************/

void delay_n_cycles(unsigned long n)
{
	__asm (
     3e4:	f3bf 8f5f 	dmb	sy
     3e8:	3801      	subs	r0, #1
     3ea:	2800      	cmp	r0, #0
     3ec:	d1fa      	bne.n	3e4 <delay_n_cycles>
	"loop: DMB	\n"
	"SUB r0, r0, #1 \n"
	"CMP r0, #0  \n"
	"BNE loop         "
	);
} // delay_n_cycles()
     3ee:	4770      	bx	lr

000003f0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     3f0:	e7fe      	b.n	3f0 <Dummy_Handler>
	...

000003f4 <Reset_Handler>:
{
     3f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     3f6:	4a2a      	ldr	r2, [pc, #168]	; (4a0 <Reset_Handler+0xac>)
     3f8:	4b2a      	ldr	r3, [pc, #168]	; (4a4 <Reset_Handler+0xb0>)
     3fa:	429a      	cmp	r2, r3
     3fc:	d011      	beq.n	422 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     3fe:	001a      	movs	r2, r3
     400:	4b29      	ldr	r3, [pc, #164]	; (4a8 <Reset_Handler+0xb4>)
     402:	429a      	cmp	r2, r3
     404:	d20d      	bcs.n	422 <Reset_Handler+0x2e>
     406:	4a29      	ldr	r2, [pc, #164]	; (4ac <Reset_Handler+0xb8>)
     408:	3303      	adds	r3, #3
     40a:	1a9b      	subs	r3, r3, r2
     40c:	089b      	lsrs	r3, r3, #2
     40e:	3301      	adds	r3, #1
     410:	009b      	lsls	r3, r3, #2
     412:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     414:	4823      	ldr	r0, [pc, #140]	; (4a4 <Reset_Handler+0xb0>)
     416:	4922      	ldr	r1, [pc, #136]	; (4a0 <Reset_Handler+0xac>)
     418:	588c      	ldr	r4, [r1, r2]
     41a:	5084      	str	r4, [r0, r2]
     41c:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     41e:	429a      	cmp	r2, r3
     420:	d1fa      	bne.n	418 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     422:	4a23      	ldr	r2, [pc, #140]	; (4b0 <Reset_Handler+0xbc>)
     424:	4b23      	ldr	r3, [pc, #140]	; (4b4 <Reset_Handler+0xc0>)
     426:	429a      	cmp	r2, r3
     428:	d20a      	bcs.n	440 <Reset_Handler+0x4c>
     42a:	43d3      	mvns	r3, r2
     42c:	4921      	ldr	r1, [pc, #132]	; (4b4 <Reset_Handler+0xc0>)
     42e:	185b      	adds	r3, r3, r1
     430:	2103      	movs	r1, #3
     432:	438b      	bics	r3, r1
     434:	3304      	adds	r3, #4
     436:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     438:	2100      	movs	r1, #0
     43a:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     43c:	4293      	cmp	r3, r2
     43e:	d1fc      	bne.n	43a <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     440:	4a1d      	ldr	r2, [pc, #116]	; (4b8 <Reset_Handler+0xc4>)
     442:	21ff      	movs	r1, #255	; 0xff
     444:	4b1d      	ldr	r3, [pc, #116]	; (4bc <Reset_Handler+0xc8>)
     446:	438b      	bics	r3, r1
     448:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     44a:	39fd      	subs	r1, #253	; 0xfd
     44c:	2390      	movs	r3, #144	; 0x90
     44e:	005b      	lsls	r3, r3, #1
     450:	4a1b      	ldr	r2, [pc, #108]	; (4c0 <Reset_Handler+0xcc>)
     452:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     454:	4a1b      	ldr	r2, [pc, #108]	; (4c4 <Reset_Handler+0xd0>)
     456:	78d3      	ldrb	r3, [r2, #3]
     458:	2503      	movs	r5, #3
     45a:	43ab      	bics	r3, r5
     45c:	2402      	movs	r4, #2
     45e:	4323      	orrs	r3, r4
     460:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     462:	78d3      	ldrb	r3, [r2, #3]
     464:	270c      	movs	r7, #12
     466:	43bb      	bics	r3, r7
     468:	2608      	movs	r6, #8
     46a:	4333      	orrs	r3, r6
     46c:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     46e:	4b16      	ldr	r3, [pc, #88]	; (4c8 <Reset_Handler+0xd4>)
     470:	7b98      	ldrb	r0, [r3, #14]
     472:	2230      	movs	r2, #48	; 0x30
     474:	4390      	bics	r0, r2
     476:	2220      	movs	r2, #32
     478:	4310      	orrs	r0, r2
     47a:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     47c:	7b99      	ldrb	r1, [r3, #14]
     47e:	43b9      	bics	r1, r7
     480:	4331      	orrs	r1, r6
     482:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     484:	7b9a      	ldrb	r2, [r3, #14]
     486:	43aa      	bics	r2, r5
     488:	4322      	orrs	r2, r4
     48a:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     48c:	4a0f      	ldr	r2, [pc, #60]	; (4cc <Reset_Handler+0xd8>)
     48e:	6853      	ldr	r3, [r2, #4]
     490:	2180      	movs	r1, #128	; 0x80
     492:	430b      	orrs	r3, r1
     494:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     496:	4b0e      	ldr	r3, [pc, #56]	; (4d0 <Reset_Handler+0xdc>)
     498:	4798      	blx	r3
        main();
     49a:	4b0e      	ldr	r3, [pc, #56]	; (4d4 <Reset_Handler+0xe0>)
     49c:	4798      	blx	r3
     49e:	e7fe      	b.n	49e <Reset_Handler+0xaa>
     4a0:	00002d18 	.word	0x00002d18
     4a4:	20000000 	.word	0x20000000
     4a8:	2000043c 	.word	0x2000043c
     4ac:	20000004 	.word	0x20000004
     4b0:	2000043c 	.word	0x2000043c
     4b4:	20000aec 	.word	0x20000aec
     4b8:	e000ed00 	.word	0xe000ed00
     4bc:	00000000 	.word	0x00000000
     4c0:	41007000 	.word	0x41007000
     4c4:	41005000 	.word	0x41005000
     4c8:	41004800 	.word	0x41004800
     4cc:	41004000 	.word	0x41004000
     4d0:	00002851 	.word	0x00002851
     4d4:	00001d09 	.word	0x00001d09

000004d8 <disk_status>:
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status ( BYTE pdrv) /* Physical drive number to identify the drive */
{
     if(pdrv)
     4d8:	1e43      	subs	r3, r0, #1
     4da:	4198      	sbcs	r0, r3
     4dc:	b2c0      	uxtb	r0, r0
    {
        return STA_NOINIT;
    }
    return RES_OK;
}
     4de:	4770      	bx	lr

000004e0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (BYTE pdrv)
{
     4e0:	b510      	push	{r4, lr}
	DSTATUS stat;
	stat=SDCard_Init();  //SD card initialization
     4e2:	4b04      	ldr	r3, [pc, #16]	; (4f4 <disk_initialize+0x14>)
     4e4:	4798      	blx	r3
     4e6:	0003      	movs	r3, r0

	if(stat == STA_NODISK)
     4e8:	2802      	cmp	r0, #2
     4ea:	d002      	beq.n	4f2 <disk_initialize+0x12>
	{
		return STA_NODISK;
	}
	else if(stat != 0)
     4ec:	1e58      	subs	r0, r3, #1
     4ee:	4183      	sbcs	r3, r0
		return STA_NODISK;
     4f0:	b2d8      	uxtb	r0, r3
	}
	  else
	  {
		return 0;
	  }
}
     4f2:	bd10      	pop	{r4, pc}
     4f4:	00001dc1 	.word	0x00001dc1

000004f8 <disk_read>:
	BYTE pdrv,                                /* Physical drive number to identify the drive */
	BYTE *buff,                               /* Data buffer to store read data */
	DWORD sector,        /* Sector address in LBA */
	UINT count                               /* Number of sectors to read */
)
{
     4f8:	b570      	push	{r4, r5, r6, lr}
     4fa:	000e      	movs	r6, r1
     4fc:	0015      	movs	r5, r2
     4fe:	001c      	movs	r4, r3
    DRESULT res;
    if (pdrv || !count)
    {
        return RES_PARERR;
     500:	2304      	movs	r3, #4
    if (pdrv || !count)
     502:	2800      	cmp	r0, #0
     504:	d001      	beq.n	50a <disk_read+0x12>
    }
    else
    {
        return RES_ERROR;
    }
}
     506:	0018      	movs	r0, r3
     508:	bd70      	pop	{r4, r5, r6, pc}
    if (pdrv || !count)
     50a:	2c00      	cmp	r4, #0
     50c:	d0fb      	beq.n	506 <disk_read+0xe>
		if (count == 1)
     50e:	2c01      	cmp	r4, #1
     510:	d00b      	beq.n	52a <disk_read+0x32>
			UART3_Write_Text("read 2 \n");
     512:	480c      	ldr	r0, [pc, #48]	; (544 <disk_read+0x4c>)
     514:	4b0c      	ldr	r3, [pc, #48]	; (548 <disk_read+0x50>)
     516:	4798      	blx	r3
			res = SDCard_ReadMultipleBlock(sector,buff,count);
     518:	b2e2      	uxtb	r2, r4
     51a:	0031      	movs	r1, r6
     51c:	0028      	movs	r0, r5
     51e:	4b0b      	ldr	r3, [pc, #44]	; (54c <disk_read+0x54>)
     520:	4798      	blx	r3
    if(res == 0x00)
     522:	1e43      	subs	r3, r0, #1
     524:	4198      	sbcs	r0, r3
        return RES_PARERR;
     526:	b2c3      	uxtb	r3, r0
     528:	e7ed      	b.n	506 <disk_read+0xe>
			UART3_Write_Text("Count is: \n");
     52a:	4809      	ldr	r0, [pc, #36]	; (550 <disk_read+0x58>)
     52c:	4c06      	ldr	r4, [pc, #24]	; (548 <disk_read+0x50>)
     52e:	47a0      	blx	r4
			UART3_Write_Text((char*)count);
     530:	2001      	movs	r0, #1
     532:	47a0      	blx	r4
			UART3_Write_Text("\n");
     534:	4807      	ldr	r0, [pc, #28]	; (554 <disk_read+0x5c>)
     536:	47a0      	blx	r4
			res = SDCard_ReadSingleBlock(sector,buff);
     538:	0031      	movs	r1, r6
     53a:	0028      	movs	r0, r5
     53c:	4b06      	ldr	r3, [pc, #24]	; (558 <disk_read+0x60>)
     53e:	4798      	blx	r3
     540:	e7ef      	b.n	522 <disk_read+0x2a>
     542:	46c0      	nop			; (mov r8, r8)
     544:	00002b7c 	.word	0x00002b7c
     548:	00002505 	.word	0x00002505
     54c:	00002039 	.word	0x00002039
     550:	00002b70 	.word	0x00002b70
     554:	00002a90 	.word	0x00002a90
     558:	00001f6d 	.word	0x00001f6d

0000055c <disk_write>:
	BYTE pdrv,             /* Physical drive number to identify the drive */
	const BYTE *buff,      /* Data to be written */
	DWORD sector,          /* Sector address in LBA */
	UINT count             /* Number of sectors to write */
)
{
     55c:	b570      	push	{r4, r5, r6, lr}
     55e:	000e      	movs	r6, r1
     560:	0015      	movs	r5, r2
     562:	001c      	movs	r4, r3
    DRESULT res;
	if (pdrv || !count)
    {
        return RES_PARERR;
     564:	2304      	movs	r3, #4
	if (pdrv || !count)
     566:	2800      	cmp	r0, #0
     568:	d001      	beq.n	56e <disk_write+0x12>
    }
    else
    {
        return RES_ERROR;
    }
}
     56a:	0018      	movs	r0, r3
     56c:	bd70      	pop	{r4, r5, r6, pc}
	if (pdrv || !count)
     56e:	2c00      	cmp	r4, #0
     570:	d0fb      	beq.n	56a <disk_write+0xe>
    if(count == 1)
     572:	2c01      	cmp	r4, #1
     574:	d00b      	beq.n	58e <disk_write+0x32>
    	UART3_Write_Text("write 2 \n");
     576:	480a      	ldr	r0, [pc, #40]	; (5a0 <disk_write+0x44>)
     578:	4b0a      	ldr	r3, [pc, #40]	; (5a4 <disk_write+0x48>)
     57a:	4798      	blx	r3
        res = SDCard_WriteMultipleBlock(sector, buff, count);
     57c:	b2e2      	uxtb	r2, r4
     57e:	0031      	movs	r1, r6
     580:	0028      	movs	r0, r5
     582:	4b09      	ldr	r3, [pc, #36]	; (5a8 <disk_write+0x4c>)
     584:	4798      	blx	r3
    if(res == 0)
     586:	1e43      	subs	r3, r0, #1
     588:	4198      	sbcs	r0, r3
        return RES_PARERR;
     58a:	b2c3      	uxtb	r3, r0
     58c:	e7ed      	b.n	56a <disk_write+0xe>
    	UART3_Write_Text("write 1 \n");
     58e:	4807      	ldr	r0, [pc, #28]	; (5ac <disk_write+0x50>)
     590:	4b04      	ldr	r3, [pc, #16]	; (5a4 <disk_write+0x48>)
     592:	4798      	blx	r3
        res = SDCard_WriteSingleBlock(sector, buff);
     594:	0031      	movs	r1, r6
     596:	0028      	movs	r0, r5
     598:	4b05      	ldr	r3, [pc, #20]	; (5b0 <disk_write+0x54>)
     59a:	4798      	blx	r3
     59c:	e7f3      	b.n	586 <disk_write+0x2a>
     59e:	46c0      	nop			; (mov r8, r8)
     5a0:	00002b94 	.word	0x00002b94
     5a4:	00002505 	.word	0x00002505
     5a8:	000021c1 	.word	0x000021c1
     5ac:	00002b88 	.word	0x00002b88
     5b0:	000020dd 	.word	0x000020dd

000005b4 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,               /* Physical drive number (0..) */
	BYTE cmd,                /* Control code */
	void *buff               /* Buffer to send/receive control data */
)
{
     5b4:	b510      	push	{r4, lr}
     5b6:	b084      	sub	sp, #16
     5b8:	0014      	movs	r4, r2
	BYTE n, csd[16];
	DWORD csize;

	if (pdrv)
	{
		 return RES_PARERR;
     5ba:	2304      	movs	r3, #4
	if (pdrv)
     5bc:	2800      	cmp	r0, #0
     5be:	d002      	beq.n	5c6 <disk_ioctl+0x12>
		
		default:
		 res = RES_PARERR; break;
	}
	return res;
}
     5c0:	0018      	movs	r0, r3
     5c2:	b004      	add	sp, #16
     5c4:	bd10      	pop	{r4, pc}
	switch (cmd)
     5c6:	2901      	cmp	r1, #1
     5c8:	d026      	beq.n	618 <disk_ioctl+0x64>
     5ca:	2900      	cmp	r1, #0
     5cc:	d06c      	beq.n	6a8 <disk_ioctl+0xf4>
     5ce:	2902      	cmp	r1, #2
     5d0:	d065      	beq.n	69e <disk_ioctl+0xea>
     5d2:	2903      	cmp	r1, #3
     5d4:	d1f4      	bne.n	5c0 <disk_ioctl+0xc>
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5d6:	2295      	movs	r2, #149	; 0x95
     5d8:	2100      	movs	r1, #0
     5da:	2049      	movs	r0, #73	; 0x49
     5dc:	4b33      	ldr	r3, [pc, #204]	; (6ac <disk_ioctl+0xf8>)
     5de:	4798      	blx	r3
	res = RES_ERROR;
     5e0:	2301      	movs	r3, #1
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5e2:	2800      	cmp	r0, #0
     5e4:	d1ec      	bne.n	5c0 <disk_ioctl+0xc>
     5e6:	4669      	mov	r1, sp
     5e8:	3049      	adds	r0, #73	; 0x49
     5ea:	4b31      	ldr	r3, [pc, #196]	; (6b0 <disk_ioctl+0xfc>)
     5ec:	4798      	blx	r3
	res = RES_ERROR;
     5ee:	2301      	movs	r3, #1
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
     5f0:	2800      	cmp	r0, #0
     5f2:	d0e5      	beq.n	5c0 <disk_ioctl+0xc>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     5f4:	466b      	mov	r3, sp
     5f6:	7a9a      	ldrb	r2, [r3, #10]
     5f8:	0052      	lsls	r2, r2, #1
     5fa:	237e      	movs	r3, #126	; 0x7e
     5fc:	4013      	ands	r3, r2
     5fe:	466a      	mov	r2, sp
     600:	7ad2      	ldrb	r2, [r2, #11]
     602:	09d2      	lsrs	r2, r2, #7
     604:	189b      	adds	r3, r3, r2
     606:	3301      	adds	r3, #1
     608:	466a      	mov	r2, sp
     60a:	7b52      	ldrb	r2, [r2, #13]
     60c:	0992      	lsrs	r2, r2, #6
     60e:	3a01      	subs	r2, #1
     610:	4093      	lsls	r3, r2
     612:	6023      	str	r3, [r4, #0]
					res = RES_OK;
     614:	2300      	movs	r3, #0
     616:	e7d3      	b.n	5c0 <disk_ioctl+0xc>
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     618:	2295      	movs	r2, #149	; 0x95
     61a:	2100      	movs	r1, #0
     61c:	2049      	movs	r0, #73	; 0x49
     61e:	4b23      	ldr	r3, [pc, #140]	; (6ac <disk_ioctl+0xf8>)
     620:	4798      	blx	r3
	res = RES_ERROR;
     622:	2301      	movs	r3, #1
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     624:	2800      	cmp	r0, #0
     626:	d1cb      	bne.n	5c0 <disk_ioctl+0xc>
     628:	4669      	mov	r1, sp
     62a:	3049      	adds	r0, #73	; 0x49
     62c:	4b20      	ldr	r3, [pc, #128]	; (6b0 <disk_ioctl+0xfc>)
     62e:	4798      	blx	r3
	res = RES_ERROR;
     630:	2301      	movs	r3, #1
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
     632:	2800      	cmp	r0, #0
     634:	d0c4      	beq.n	5c0 <disk_ioctl+0xc>
					if((csd[0] >> 6) == 1) /* SDC ver 2.00 */
     636:	466b      	mov	r3, sp
     638:	781b      	ldrb	r3, [r3, #0]
     63a:	099b      	lsrs	r3, r3, #6
     63c:	2b01      	cmp	r3, #1
     63e:	d023      	beq.n	688 <disk_ioctl+0xd4>
						csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     640:	466b      	mov	r3, sp
     642:	7a1b      	ldrb	r3, [r3, #8]
     644:	099b      	lsrs	r3, r3, #6
     646:	466a      	mov	r2, sp
     648:	79d2      	ldrb	r2, [r2, #7]
     64a:	0092      	lsls	r2, r2, #2
     64c:	189b      	adds	r3, r3, r2
     64e:	466a      	mov	r2, sp
     650:	7992      	ldrb	r2, [r2, #6]
     652:	0292      	lsls	r2, r2, #10
     654:	21c0      	movs	r1, #192	; 0xc0
     656:	0109      	lsls	r1, r1, #4
     658:	400a      	ands	r2, r1
     65a:	189a      	adds	r2, r3, r2
     65c:	3201      	adds	r2, #1
						n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     65e:	466b      	mov	r3, sp
     660:	7959      	ldrb	r1, [r3, #5]
     662:	230f      	movs	r3, #15
     664:	400b      	ands	r3, r1
     666:	4669      	mov	r1, sp
     668:	7a89      	ldrb	r1, [r1, #10]
     66a:	09c9      	lsrs	r1, r1, #7
     66c:	185b      	adds	r3, r3, r1
     66e:	3302      	adds	r3, #2
     670:	4669      	mov	r1, sp
     672:	7a48      	ldrb	r0, [r1, #9]
     674:	0040      	lsls	r0, r0, #1
     676:	2106      	movs	r1, #6
     678:	4001      	ands	r1, r0
     67a:	185b      	adds	r3, r3, r1
						*(DWORD*)buff = (DWORD)csize << (n - 9);
     67c:	b2db      	uxtb	r3, r3
     67e:	3b09      	subs	r3, #9
     680:	409a      	lsls	r2, r3
     682:	6022      	str	r2, [r4, #0]
					res = RES_OK;
     684:	2300      	movs	r3, #0
     686:	e79b      	b.n	5c0 <disk_ioctl+0xc>
						csize = csd[9] + ((WORD)csd[8] << 8) + 1;
     688:	466b      	mov	r3, sp
     68a:	7a1b      	ldrb	r3, [r3, #8]
     68c:	021b      	lsls	r3, r3, #8
     68e:	466a      	mov	r2, sp
     690:	7a52      	ldrb	r2, [r2, #9]
     692:	189b      	adds	r3, r3, r2
     694:	3301      	adds	r3, #1
						*(DWORD*)buff = (DWORD)csize << 10;
     696:	029b      	lsls	r3, r3, #10
     698:	6023      	str	r3, [r4, #0]
					res = RES_OK;
     69a:	2300      	movs	r3, #0
     69c:	e790      	b.n	5c0 <disk_ioctl+0xc>
				*(WORD*)buff = 512;
     69e:	2380      	movs	r3, #128	; 0x80
     6a0:	009b      	lsls	r3, r3, #2
     6a2:	8013      	strh	r3, [r2, #0]
				res = RES_OK;
     6a4:	2300      	movs	r3, #0
				break;
     6a6:	e78b      	b.n	5c0 <disk_ioctl+0xc>
		case CTRL_SYNC        : res = RES_OK; break;
     6a8:	2300      	movs	r3, #0
     6aa:	e789      	b.n	5c0 <disk_ioctl+0xc>
     6ac:	00001d41 	.word	0x00001d41
     6b0:	00001f39 	.word	0x00001f39

000006b4 <get_fattime>:

// FATTIME Work around
DWORD get_fattime (void)
{
	return 0;
}
     6b4:	2000      	movs	r0, #0
     6b6:	4770      	bx	lr

000006b8 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
     6b8:	b510      	push	{r4, lr}
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
     6ba:	2a00      	cmp	r2, #0
     6bc:	d005      	beq.n	6ca <mem_cpy+0x12>
     6be:	2300      	movs	r3, #0
		*d++ = *s++;
     6c0:	5ccc      	ldrb	r4, [r1, r3]
     6c2:	54c4      	strb	r4, [r0, r3]
     6c4:	3301      	adds	r3, #1
	while (cnt--)
     6c6:	4293      	cmp	r3, r2
     6c8:	d1fa      	bne.n	6c0 <mem_cpy+0x8>
}
     6ca:	bd10      	pop	{r4, pc}

000006cc <ld_clust>:
static
DWORD ld_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir	/* Pointer to the directory entry */
)
{
     6cc:	b510      	push	{r4, lr}
     6ce:	0004      	movs	r4, r0
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
     6d0:	7eca      	ldrb	r2, [r1, #27]
     6d2:	0212      	lsls	r2, r2, #8
     6d4:	7e88      	ldrb	r0, [r1, #26]
     6d6:	4310      	orrs	r0, r2
	if (fs->fs_type == FS_FAT32)
     6d8:	7823      	ldrb	r3, [r4, #0]
     6da:	2b03      	cmp	r3, #3
     6dc:	d000      	beq.n	6e0 <ld_clust+0x14>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
     6de:	bd10      	pop	{r4, pc}
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
     6e0:	7d4a      	ldrb	r2, [r1, #21]
     6e2:	0212      	lsls	r2, r2, #8
     6e4:	7d0b      	ldrb	r3, [r1, #20]
     6e6:	4313      	orrs	r3, r2
     6e8:	041b      	lsls	r3, r3, #16
     6ea:	4318      	orrs	r0, r3
	return cl;
     6ec:	e7f7      	b.n	6de <ld_clust+0x12>

000006ee <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
     6ee:	b530      	push	{r4, r5, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
     6f0:	6801      	ldr	r1, [r0, #0]
     6f2:	2900      	cmp	r1, #0
     6f4:	d01b      	beq.n	72e <get_ldnumber+0x40>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     6f6:	780c      	ldrb	r4, [r1, #0]
     6f8:	2c20      	cmp	r4, #32
     6fa:	d911      	bls.n	720 <get_ldnumber+0x32>
     6fc:	2c3a      	cmp	r4, #58	; 0x3a
     6fe:	d01f      	beq.n	740 <get_ldnumber+0x52>
     700:	000b      	movs	r3, r1
     702:	3301      	adds	r3, #1
     704:	781a      	ldrb	r2, [r3, #0]
     706:	2a20      	cmp	r2, #32
     708:	d90c      	bls.n	724 <get_ldnumber+0x36>
     70a:	2a3a      	cmp	r2, #58	; 0x3a
     70c:	d1f9      	bne.n	702 <get_ldnumber+0x14>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
     70e:	1c4a      	adds	r2, r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
     710:	4293      	cmp	r3, r2
     712:	d10f      	bne.n	734 <get_ldnumber+0x46>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
     714:	2c30      	cmp	r4, #48	; 0x30
     716:	d110      	bne.n	73a <get_ldnumber+0x4c>
					vol = (int)i;
					*path = ++tt;
     718:	3102      	adds	r1, #2
     71a:	6001      	str	r1, [r0, #0]
					vol = (int)i;
     71c:	2500      	movs	r5, #0
     71e:	e004      	b.n	72a <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     720:	0022      	movs	r2, r4
     722:	000b      	movs	r3, r1
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
     724:	2500      	movs	r5, #0
		if (*tt == ':') {	/* If a ':' is exist in the path name */
     726:	2a3a      	cmp	r2, #58	; 0x3a
     728:	d0f1      	beq.n	70e <get_ldnumber+0x20>
#endif
	}
	return vol;
}
     72a:	0028      	movs	r0, r5
     72c:	bd30      	pop	{r4, r5, pc}
	int vol = -1;
     72e:	2501      	movs	r5, #1
     730:	426d      	negs	r5, r5
     732:	e7fa      	b.n	72a <get_ldnumber+0x3c>
     734:	2501      	movs	r5, #1
     736:	426d      	negs	r5, r5
     738:	e7f7      	b.n	72a <get_ldnumber+0x3c>
     73a:	2501      	movs	r5, #1
     73c:	426d      	negs	r5, r5
     73e:	e7f4      	b.n	72a <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
     740:	000b      	movs	r3, r1
     742:	e7e4      	b.n	70e <get_ldnumber+0x20>

00000744 <sync_window>:
{
     744:	b5f0      	push	{r4, r5, r6, r7, lr}
     746:	b083      	sub	sp, #12
     748:	0004      	movs	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
     74a:	7903      	ldrb	r3, [r0, #4]
	FRESULT res = FR_OK;
     74c:	2000      	movs	r0, #0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
     74e:	2b00      	cmp	r3, #0
     750:	d101      	bne.n	756 <sync_window+0x12>
}
     752:	b003      	add	sp, #12
     754:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
     756:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
     758:	2330      	movs	r3, #48	; 0x30
     75a:	469c      	mov	ip, r3
     75c:	44a4      	add	ip, r4
     75e:	4663      	mov	r3, ip
     760:	4661      	mov	r1, ip
     762:	9301      	str	r3, [sp, #4]
     764:	7860      	ldrb	r0, [r4, #1]
     766:	2301      	movs	r3, #1
     768:	002a      	movs	r2, r5
     76a:	4e10      	ldr	r6, [pc, #64]	; (7ac <sync_window+0x68>)
     76c:	47b0      	blx	r6
     76e:	0003      	movs	r3, r0
			res = FR_DISK_ERR;
     770:	2001      	movs	r0, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
     772:	2b00      	cmp	r3, #0
     774:	d1ed      	bne.n	752 <sync_window+0xe>
			fs->wflag = 0;
     776:	7123      	strb	r3, [r4, #4]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
     778:	6a23      	ldr	r3, [r4, #32]
     77a:	1aeb      	subs	r3, r5, r3
	FRESULT res = FR_OK;
     77c:	2000      	movs	r0, #0
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
     77e:	69a2      	ldr	r2, [r4, #24]
     780:	4293      	cmp	r3, r2
     782:	d2e6      	bcs.n	752 <sync_window+0xe>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
     784:	78e6      	ldrb	r6, [r4, #3]
     786:	2e01      	cmp	r6, #1
     788:	d90d      	bls.n	7a6 <sync_window+0x62>
					disk_write(fs->drv, fs->win, wsect, 1);
     78a:	4f08      	ldr	r7, [pc, #32]	; (7ac <sync_window+0x68>)
					wsect += fs->fsize;
     78c:	69a3      	ldr	r3, [r4, #24]
     78e:	469c      	mov	ip, r3
     790:	4465      	add	r5, ip
					disk_write(fs->drv, fs->win, wsect, 1);
     792:	7860      	ldrb	r0, [r4, #1]
     794:	2301      	movs	r3, #1
     796:	002a      	movs	r2, r5
     798:	9901      	ldr	r1, [sp, #4]
     79a:	47b8      	blx	r7
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
     79c:	3e01      	subs	r6, #1
     79e:	2e01      	cmp	r6, #1
     7a0:	d1f4      	bne.n	78c <sync_window+0x48>
	FRESULT res = FR_OK;
     7a2:	2000      	movs	r0, #0
     7a4:	e7d5      	b.n	752 <sync_window+0xe>
     7a6:	2000      	movs	r0, #0
     7a8:	e7d3      	b.n	752 <sync_window+0xe>
     7aa:	46c0      	nop			; (mov r8, r8)
     7ac:	0000055d 	.word	0x0000055d

000007b0 <move_window>:
{
     7b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     7b2:	0005      	movs	r5, r0
     7b4:	000e      	movs	r6, r1
	FRESULT res = FR_OK;
     7b6:	2400      	movs	r4, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
     7b8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
     7ba:	428b      	cmp	r3, r1
     7bc:	d003      	beq.n	7c6 <move_window+0x16>
		res = sync_window(fs);		/* Write-back changes */
     7be:	4b0a      	ldr	r3, [pc, #40]	; (7e8 <move_window+0x38>)
     7c0:	4798      	blx	r3
     7c2:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {			/* Fill sector window with new data */
     7c4:	d001      	beq.n	7ca <move_window+0x1a>
}
     7c6:	0020      	movs	r0, r4
     7c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
     7ca:	0029      	movs	r1, r5
     7cc:	3130      	adds	r1, #48	; 0x30
     7ce:	7868      	ldrb	r0, [r5, #1]
     7d0:	2301      	movs	r3, #1
     7d2:	0032      	movs	r2, r6
     7d4:	4f05      	ldr	r7, [pc, #20]	; (7ec <move_window+0x3c>)
     7d6:	47b8      	blx	r7
     7d8:	2800      	cmp	r0, #0
     7da:	d002      	beq.n	7e2 <move_window+0x32>
				res = FR_DISK_ERR;
     7dc:	3401      	adds	r4, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
     7de:	2601      	movs	r6, #1
     7e0:	4276      	negs	r6, r6
			fs->winsect = sector;
     7e2:	62ee      	str	r6, [r5, #44]	; 0x2c
     7e4:	e7ef      	b.n	7c6 <move_window+0x16>
     7e6:	46c0      	nop			; (mov r8, r8)
     7e8:	00000745 	.word	0x00000745
     7ec:	000004f9 	.word	0x000004f9

000007f0 <check_fs>:
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     7f0:	b510      	push	{r4, lr}
     7f2:	0004      	movs	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
     7f4:	2300      	movs	r3, #0
     7f6:	7103      	strb	r3, [r0, #4]
     7f8:	3b01      	subs	r3, #1
     7fa:	62c3      	str	r3, [r0, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
     7fc:	4b1e      	ldr	r3, [pc, #120]	; (878 <check_fs+0x88>)
     7fe:	4798      	blx	r3
		return 3;
     800:	2303      	movs	r3, #3
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
     802:	2800      	cmp	r0, #0
     804:	d001      	beq.n	80a <check_fs+0x1a>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
     806:	0018      	movs	r0, r3
     808:	bd10      	pop	{r4, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
     80a:	4b1c      	ldr	r3, [pc, #112]	; (87c <check_fs+0x8c>)
     80c:	5ce3      	ldrb	r3, [r4, r3]
     80e:	021b      	lsls	r3, r3, #8
     810:	4a1b      	ldr	r2, [pc, #108]	; (880 <check_fs+0x90>)
     812:	5ca2      	ldrb	r2, [r4, r2]
     814:	431a      	orrs	r2, r3
     816:	491b      	ldr	r1, [pc, #108]	; (884 <check_fs+0x94>)
     818:	b212      	sxth	r2, r2
		return 2;
     81a:	2302      	movs	r3, #2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
     81c:	428a      	cmp	r2, r1
     81e:	d1f2      	bne.n	806 <check_fs+0x16>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
     820:	3367      	adds	r3, #103	; 0x67
     822:	5ce3      	ldrb	r3, [r4, r3]
     824:	061b      	lsls	r3, r3, #24
     826:	2268      	movs	r2, #104	; 0x68
     828:	5ca2      	ldrb	r2, [r4, r2]
     82a:	0412      	lsls	r2, r2, #16
     82c:	4313      	orrs	r3, r2
     82e:	2266      	movs	r2, #102	; 0x66
     830:	5ca2      	ldrb	r2, [r4, r2]
     832:	4313      	orrs	r3, r2
     834:	2267      	movs	r2, #103	; 0x67
     836:	5ca2      	ldrb	r2, [r4, r2]
     838:	0212      	lsls	r2, r2, #8
     83a:	4313      	orrs	r3, r2
     83c:	021b      	lsls	r3, r3, #8
     83e:	0a1b      	lsrs	r3, r3, #8
     840:	4a11      	ldr	r2, [pc, #68]	; (888 <check_fs+0x98>)
     842:	4293      	cmp	r3, r2
     844:	d016      	beq.n	874 <check_fs+0x84>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
     846:	2385      	movs	r3, #133	; 0x85
     848:	5ce3      	ldrb	r3, [r4, r3]
     84a:	061b      	lsls	r3, r3, #24
     84c:	2284      	movs	r2, #132	; 0x84
     84e:	5ca2      	ldrb	r2, [r4, r2]
     850:	0412      	lsls	r2, r2, #16
     852:	4313      	orrs	r3, r2
     854:	2282      	movs	r2, #130	; 0x82
     856:	5ca2      	ldrb	r2, [r4, r2]
     858:	4313      	orrs	r3, r2
     85a:	2283      	movs	r2, #131	; 0x83
     85c:	5ca2      	ldrb	r2, [r4, r2]
     85e:	0212      	lsls	r2, r2, #8
     860:	4313      	orrs	r3, r2
     862:	021b      	lsls	r3, r3, #8
     864:	0a1b      	lsrs	r3, r3, #8
     866:	4a09      	ldr	r2, [pc, #36]	; (88c <check_fs+0x9c>)
     868:	4694      	mov	ip, r2
     86a:	4463      	add	r3, ip
     86c:	1e58      	subs	r0, r3, #1
     86e:	4183      	sbcs	r3, r0
		return 3;
     870:	b2db      	uxtb	r3, r3
     872:	e7c8      	b.n	806 <check_fs+0x16>
		return 0;
     874:	2300      	movs	r3, #0
     876:	e7c6      	b.n	806 <check_fs+0x16>
     878:	000007b1 	.word	0x000007b1
     87c:	0000022f 	.word	0x0000022f
     880:	0000022e 	.word	0x0000022e
     884:	ffffaa55 	.word	0xffffaa55
     888:	00544146 	.word	0x00544146
     88c:	ffabbeba 	.word	0xffabbeba

00000890 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
     890:	b510      	push	{r4, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     892:	2800      	cmp	r0, #0
     894:	d014      	beq.n	8c0 <validate+0x30>
     896:	6802      	ldr	r2, [r0, #0]
     898:	2a00      	cmp	r2, #0
     89a:	d013      	beq.n	8c4 <validate+0x34>
     89c:	7811      	ldrb	r1, [r2, #0]
		return FR_INVALID_OBJECT;
     89e:	2309      	movs	r3, #9
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     8a0:	2900      	cmp	r1, #0
     8a2:	d101      	bne.n	8a8 <validate+0x18>

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
     8a4:	0018      	movs	r0, r3
     8a6:	bd10      	pop	{r4, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     8a8:	88d4      	ldrh	r4, [r2, #6]
     8aa:	8881      	ldrh	r1, [r0, #4]
     8ac:	428c      	cmp	r4, r1
     8ae:	d1f9      	bne.n	8a4 <validate+0x14>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
     8b0:	7850      	ldrb	r0, [r2, #1]
     8b2:	4b05      	ldr	r3, [pc, #20]	; (8c8 <validate+0x38>)
     8b4:	4798      	blx	r3
		return FR_NOT_READY;
     8b6:	2303      	movs	r3, #3
	return FR_OK;
     8b8:	07c0      	lsls	r0, r0, #31
     8ba:	17c0      	asrs	r0, r0, #31
     8bc:	4003      	ands	r3, r0
     8be:	e7f1      	b.n	8a4 <validate+0x14>
		return FR_INVALID_OBJECT;
     8c0:	2309      	movs	r3, #9
     8c2:	e7ef      	b.n	8a4 <validate+0x14>
     8c4:	2309      	movs	r3, #9
     8c6:	e7ed      	b.n	8a4 <validate+0x14>
     8c8:	000004d9 	.word	0x000004d9

000008cc <find_volume>:
{
     8cc:	b5f0      	push	{r4, r5, r6, r7, lr}
     8ce:	46d6      	mov	lr, sl
     8d0:	464f      	mov	r7, r9
     8d2:	4646      	mov	r6, r8
     8d4:	b5c0      	push	{r6, r7, lr}
     8d6:	b084      	sub	sp, #16
     8d8:	0007      	movs	r7, r0
     8da:	0016      	movs	r6, r2
	*rfs = 0;
     8dc:	2300      	movs	r3, #0
     8de:	6003      	str	r3, [r0, #0]
	vol = get_ldnumber(path);
     8e0:	0008      	movs	r0, r1
     8e2:	4b9f      	ldr	r3, [pc, #636]	; (b60 <find_volume+0x294>)
     8e4:	4798      	blx	r3
     8e6:	0004      	movs	r4, r0
	if (vol < 0) return FR_INVALID_DRIVE;
     8e8:	230b      	movs	r3, #11
     8ea:	2800      	cmp	r0, #0
     8ec:	db1f      	blt.n	92e <find_volume+0x62>
	fs = FatFs[vol];					/* Get pointer to the file system object */
     8ee:	0083      	lsls	r3, r0, #2
     8f0:	4a9c      	ldr	r2, [pc, #624]	; (b64 <find_volume+0x298>)
     8f2:	589d      	ldr	r5, [r3, r2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
     8f4:	2d00      	cmp	r5, #0
     8f6:	d100      	bne.n	8fa <find_volume+0x2e>
     8f8:	e1a7      	b.n	c4a <find_volume+0x37e>
	*rfs = fs;							/* Return pointer to the file system object */
     8fa:	603d      	str	r5, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
     8fc:	782b      	ldrb	r3, [r5, #0]
     8fe:	2b00      	cmp	r3, #0
     900:	d00c      	beq.n	91c <find_volume+0x50>
		stat = disk_status(fs->drv);
     902:	7868      	ldrb	r0, [r5, #1]
     904:	4b98      	ldr	r3, [pc, #608]	; (b68 <find_volume+0x29c>)
     906:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
     908:	07c3      	lsls	r3, r0, #31
     90a:	d407      	bmi.n	91c <find_volume+0x50>
			return FR_OK;				/* The file system object is valid */
     90c:	2300      	movs	r3, #0
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
     90e:	2e00      	cmp	r6, #0
     910:	d00d      	beq.n	92e <find_volume+0x62>
     912:	0743      	lsls	r3, r0, #29
     914:	d400      	bmi.n	918 <find_volume+0x4c>
     916:	e19a      	b.n	c4e <find_volume+0x382>
				return FR_WRITE_PROTECTED;
     918:	230a      	movs	r3, #10
     91a:	e008      	b.n	92e <find_volume+0x62>
	fs->fs_type = 0;					/* Clear the file system object */
     91c:	2300      	movs	r3, #0
     91e:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
     920:	b2e0      	uxtb	r0, r4
     922:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
     924:	4b91      	ldr	r3, [pc, #580]	; (b6c <find_volume+0x2a0>)
     926:	4798      	blx	r3
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
     928:	2303      	movs	r3, #3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
     92a:	07c2      	lsls	r2, r0, #31
     92c:	d506      	bpl.n	93c <find_volume+0x70>
}
     92e:	0018      	movs	r0, r3
     930:	b004      	add	sp, #16
     932:	bc1c      	pop	{r2, r3, r4}
     934:	4690      	mov	r8, r2
     936:	4699      	mov	r9, r3
     938:	46a2      	mov	sl, r4
     93a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
     93c:	2e00      	cmp	r6, #0
     93e:	d002      	beq.n	946 <find_volume+0x7a>
		return FR_WRITE_PROTECTED;
     940:	3307      	adds	r3, #7
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
     942:	0742      	lsls	r2, r0, #29
     944:	d4f3      	bmi.n	92e <find_volume+0x62>
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
     946:	2100      	movs	r1, #0
     948:	0028      	movs	r0, r5
     94a:	4b89      	ldr	r3, [pc, #548]	; (b70 <find_volume+0x2a4>)
     94c:	4798      	blx	r3
	bsect = 0;
     94e:	2700      	movs	r7, #0
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
     950:	2801      	cmp	r0, #1
     952:	d100      	bne.n	956 <find_volume+0x8a>
     954:	e0b4      	b.n	ac0 <find_volume+0x1f4>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
     956:	2803      	cmp	r0, #3
     958:	d100      	bne.n	95c <find_volume+0x90>
     95a:	e17a      	b.n	c52 <find_volume+0x386>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
     95c:	230d      	movs	r3, #13
     95e:	2800      	cmp	r0, #0
     960:	d1e5      	bne.n	92e <find_volume+0x62>
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
     962:	233c      	movs	r3, #60	; 0x3c
     964:	5ceb      	ldrb	r3, [r5, r3]
     966:	021b      	lsls	r3, r3, #8
     968:	223b      	movs	r2, #59	; 0x3b
     96a:	5caa      	ldrb	r2, [r5, r2]
     96c:	431a      	orrs	r2, r3
     96e:	2180      	movs	r1, #128	; 0x80
     970:	0089      	lsls	r1, r1, #2
     972:	b212      	sxth	r2, r2
		return FR_NO_FILESYSTEM;
     974:	230d      	movs	r3, #13
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
     976:	428a      	cmp	r2, r1
     978:	d1d9      	bne.n	92e <find_volume+0x62>
	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
     97a:	333a      	adds	r3, #58	; 0x3a
     97c:	5ceb      	ldrb	r3, [r5, r3]
     97e:	021b      	lsls	r3, r3, #8
     980:	2246      	movs	r2, #70	; 0x46
     982:	5cac      	ldrb	r4, [r5, r2]
     984:	431c      	orrs	r4, r3
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
     986:	d10d      	bne.n	9a4 <find_volume+0xd8>
     988:	2357      	movs	r3, #87	; 0x57
     98a:	5cec      	ldrb	r4, [r5, r3]
     98c:	0624      	lsls	r4, r4, #24
     98e:	3b01      	subs	r3, #1
     990:	5ceb      	ldrb	r3, [r5, r3]
     992:	041b      	lsls	r3, r3, #16
     994:	431c      	orrs	r4, r3
     996:	2354      	movs	r3, #84	; 0x54
     998:	5ceb      	ldrb	r3, [r5, r3]
     99a:	431c      	orrs	r4, r3
     99c:	2355      	movs	r3, #85	; 0x55
     99e:	5ceb      	ldrb	r3, [r5, r3]
     9a0:	021b      	lsls	r3, r3, #8
     9a2:	431c      	orrs	r4, r3
	fs->fsize = fasize;
     9a4:	61ac      	str	r4, [r5, #24]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
     9a6:	2340      	movs	r3, #64	; 0x40
     9a8:	5cea      	ldrb	r2, [r5, r3]
     9aa:	70ea      	strb	r2, [r5, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
     9ac:	1e51      	subs	r1, r2, #1
		return FR_NO_FILESYSTEM;
     9ae:	3b33      	subs	r3, #51	; 0x33
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
     9b0:	2901      	cmp	r1, #1
     9b2:	d8bc      	bhi.n	92e <find_volume+0x62>
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
     9b4:	3330      	adds	r3, #48	; 0x30
     9b6:	5ce9      	ldrb	r1, [r5, r3]
     9b8:	70a9      	strb	r1, [r5, #2]
		return FR_NO_FILESYSTEM;
     9ba:	3b30      	subs	r3, #48	; 0x30
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
     9bc:	2900      	cmp	r1, #0
     9be:	d0b6      	beq.n	92e <find_volume+0x62>
     9c0:	1e48      	subs	r0, r1, #1
     9c2:	4201      	tst	r1, r0
     9c4:	d1b3      	bne.n	92e <find_volume+0x62>
	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
     9c6:	3335      	adds	r3, #53	; 0x35
     9c8:	5ceb      	ldrb	r3, [r5, r3]
     9ca:	021b      	lsls	r3, r3, #8
     9cc:	2041      	movs	r0, #65	; 0x41
     9ce:	5c28      	ldrb	r0, [r5, r0]
     9d0:	4318      	orrs	r0, r3
     9d2:	4682      	mov	sl, r0
     9d4:	8128      	strh	r0, [r5, #8]
		return FR_NO_FILESYSTEM;
     9d6:	230d      	movs	r3, #13
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
     9d8:	0700      	lsls	r0, r0, #28
     9da:	d1a8      	bne.n	92e <find_volume+0x62>
	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
     9dc:	3337      	adds	r3, #55	; 0x37
     9de:	5ceb      	ldrb	r3, [r5, r3]
     9e0:	021b      	lsls	r3, r3, #8
     9e2:	2043      	movs	r0, #67	; 0x43
     9e4:	5c28      	ldrb	r0, [r5, r0]
     9e6:	4318      	orrs	r0, r3
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
     9e8:	d10d      	bne.n	a06 <find_volume+0x13a>
     9ea:	2353      	movs	r3, #83	; 0x53
     9ec:	5ce8      	ldrb	r0, [r5, r3]
     9ee:	0600      	lsls	r0, r0, #24
     9f0:	3b01      	subs	r3, #1
     9f2:	5ceb      	ldrb	r3, [r5, r3]
     9f4:	041b      	lsls	r3, r3, #16
     9f6:	4318      	orrs	r0, r3
     9f8:	2350      	movs	r3, #80	; 0x50
     9fa:	5ceb      	ldrb	r3, [r5, r3]
     9fc:	4318      	orrs	r0, r3
     9fe:	2351      	movs	r3, #81	; 0x51
     a00:	5ceb      	ldrb	r3, [r5, r3]
     a02:	021b      	lsls	r3, r3, #8
     a04:	4318      	orrs	r0, r3
	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
     a06:	233f      	movs	r3, #63	; 0x3f
     a08:	5ceb      	ldrb	r3, [r5, r3]
     a0a:	021b      	lsls	r3, r3, #8
     a0c:	263e      	movs	r6, #62	; 0x3e
     a0e:	5dae      	ldrb	r6, [r5, r6]
     a10:	431e      	orrs	r6, r3
     a12:	46b0      	mov	r8, r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
     a14:	230d      	movs	r3, #13
     a16:	2e00      	cmp	r6, #0
     a18:	d100      	bne.n	a1c <find_volume+0x150>
     a1a:	e788      	b.n	92e <find_volume+0x62>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
     a1c:	4362      	muls	r2, r4
     a1e:	4691      	mov	r9, r2
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
     a20:	4653      	mov	r3, sl
     a22:	091e      	lsrs	r6, r3, #4
     a24:	4446      	add	r6, r8
     a26:	444e      	add	r6, r9
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
     a28:	230d      	movs	r3, #13
     a2a:	42b0      	cmp	r0, r6
     a2c:	d200      	bcs.n	a30 <find_volume+0x164>
     a2e:	e77e      	b.n	92e <find_volume+0x62>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
     a30:	1b80      	subs	r0, r0, r6
     a32:	4b50      	ldr	r3, [pc, #320]	; (b74 <find_volume+0x2a8>)
     a34:	4798      	blx	r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
     a36:	230d      	movs	r3, #13
     a38:	2800      	cmp	r0, #0
     a3a:	d100      	bne.n	a3e <find_volume+0x172>
     a3c:	e777      	b.n	92e <find_volume+0x62>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
     a3e:	4a4e      	ldr	r2, [pc, #312]	; (b78 <find_volume+0x2ac>)
     a40:	4282      	cmp	r2, r0
     a42:	4192      	sbcs	r2, r2
     a44:	4252      	negs	r2, r2
     a46:	3201      	adds	r2, #1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
     a48:	4b4c      	ldr	r3, [pc, #304]	; (b7c <find_volume+0x2b0>)
     a4a:	4298      	cmp	r0, r3
     a4c:	d900      	bls.n	a50 <find_volume+0x184>
     a4e:	e102      	b.n	c56 <find_volume+0x38a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
     a50:	3002      	adds	r0, #2
     a52:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
     a54:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
     a56:	4643      	mov	r3, r8
     a58:	19d9      	adds	r1, r3, r7
     a5a:	6229      	str	r1, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
     a5c:	19f6      	adds	r6, r6, r7
     a5e:	62ae      	str	r6, [r5, #40]	; 0x28
	if (fmt == FS_FAT32) {
     a60:	2a03      	cmp	r2, #3
     a62:	d15b      	bne.n	b1c <find_volume+0x250>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
     a64:	230d      	movs	r3, #13
     a66:	4652      	mov	r2, sl
     a68:	2a00      	cmp	r2, #0
     a6a:	d000      	beq.n	a6e <find_volume+0x1a2>
     a6c:	e75f      	b.n	92e <find_volume+0x62>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
     a6e:	3352      	adds	r3, #82	; 0x52
     a70:	5ceb      	ldrb	r3, [r5, r3]
     a72:	061b      	lsls	r3, r3, #24
     a74:	325e      	adds	r2, #94	; 0x5e
     a76:	5caa      	ldrb	r2, [r5, r2]
     a78:	0412      	lsls	r2, r2, #16
     a7a:	4313      	orrs	r3, r2
     a7c:	225c      	movs	r2, #92	; 0x5c
     a7e:	5caa      	ldrb	r2, [r5, r2]
     a80:	4313      	orrs	r3, r2
     a82:	225d      	movs	r2, #93	; 0x5d
     a84:	5caa      	ldrb	r2, [r5, r2]
     a86:	0212      	lsls	r2, r2, #8
     a88:	4313      	orrs	r3, r2
     a8a:	626b      	str	r3, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
     a8c:	0082      	lsls	r2, r0, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     a8e:	4b3c      	ldr	r3, [pc, #240]	; (b80 <find_volume+0x2b4>)
     a90:	469c      	mov	ip, r3
     a92:	4462      	add	r2, ip
     a94:	0a52      	lsrs	r2, r2, #9
		return FR_NO_FILESYSTEM;
     a96:	3bf3      	subs	r3, #243	; 0xf3
     a98:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     a9a:	4294      	cmp	r4, r2
     a9c:	d200      	bcs.n	aa0 <find_volume+0x1d4>
     a9e:	e746      	b.n	92e <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
     aa0:	2301      	movs	r3, #1
     aa2:	425b      	negs	r3, r3
     aa4:	612b      	str	r3, [r5, #16]
     aa6:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
     aa8:	3381      	adds	r3, #129	; 0x81
     aaa:	716b      	strb	r3, [r5, #5]
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
     aac:	3b1f      	subs	r3, #31
     aae:	5cea      	ldrb	r2, [r5, r3]
     ab0:	0212      	lsls	r2, r2, #8
     ab2:	3b01      	subs	r3, #1
     ab4:	5ceb      	ldrb	r3, [r5, r3]
     ab6:	4313      	orrs	r3, r2
     ab8:	2b01      	cmp	r3, #1
     aba:	d063      	beq.n	b84 <find_volume+0x2b8>
     abc:	2203      	movs	r2, #3
     abe:	e0bb      	b.n	c38 <find_volume+0x36c>
     ac0:	002a      	movs	r2, r5
     ac2:	32f3      	adds	r2, #243	; 0xf3
     ac4:	32ff      	adds	r2, #255	; 0xff
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
     ac6:	2000      	movs	r0, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     ac8:	2100      	movs	r1, #0
     aca:	e005      	b.n	ad8 <find_volume+0x20c>
     acc:	466c      	mov	r4, sp
     ace:	5103      	str	r3, [r0, r4]
     ad0:	3210      	adds	r2, #16
     ad2:	3004      	adds	r0, #4
		for (i = 0; i < 4; i++) {			/* Get partition offset */
     ad4:	2810      	cmp	r0, #16
     ad6:	d00e      	beq.n	af6 <find_volume+0x22a>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     ad8:	7814      	ldrb	r4, [r2, #0]
     ada:	000b      	movs	r3, r1
     adc:	2c00      	cmp	r4, #0
     ade:	d0f5      	beq.n	acc <find_volume+0x200>
     ae0:	79d3      	ldrb	r3, [r2, #7]
     ae2:	061b      	lsls	r3, r3, #24
     ae4:	7994      	ldrb	r4, [r2, #6]
     ae6:	0424      	lsls	r4, r4, #16
     ae8:	4323      	orrs	r3, r4
     aea:	7914      	ldrb	r4, [r2, #4]
     aec:	4323      	orrs	r3, r4
     aee:	7954      	ldrb	r4, [r2, #5]
     af0:	0224      	lsls	r4, r4, #8
     af2:	4323      	orrs	r3, r4
     af4:	e7ea      	b.n	acc <find_volume+0x200>
     af6:	2600      	movs	r6, #0
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
     af8:	2402      	movs	r4, #2
     afa:	e003      	b.n	b04 <find_volume+0x238>
     afc:	3604      	adds	r6, #4
		} while (!LD2PT(vol) && fmt && ++i < 4);
     afe:	2e10      	cmp	r6, #16
     b00:	d100      	bne.n	b04 <find_volume+0x238>
     b02:	e728      	b.n	956 <find_volume+0x8a>
			bsect = br[i];
     b04:	466b      	mov	r3, sp
     b06:	58f7      	ldr	r7, [r6, r3]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
     b08:	0020      	movs	r0, r4
     b0a:	2f00      	cmp	r7, #0
     b0c:	d0f6      	beq.n	afc <find_volume+0x230>
     b0e:	0039      	movs	r1, r7
     b10:	0028      	movs	r0, r5
     b12:	4b17      	ldr	r3, [pc, #92]	; (b70 <find_volume+0x2a4>)
     b14:	4798      	blx	r3
		} while (!LD2PT(vol) && fmt && ++i < 4);
     b16:	2800      	cmp	r0, #0
     b18:	d1f0      	bne.n	afc <find_volume+0x230>
     b1a:	e722      	b.n	962 <find_volume+0x96>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
     b1c:	230d      	movs	r3, #13
     b1e:	4656      	mov	r6, sl
     b20:	2e00      	cmp	r6, #0
     b22:	d100      	bne.n	b26 <find_volume+0x25a>
     b24:	e703      	b.n	92e <find_volume+0x62>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
     b26:	4449      	add	r1, r9
     b28:	6269      	str	r1, [r5, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
     b2a:	2a02      	cmp	r2, #2
     b2c:	d110      	bne.n	b50 <find_volume+0x284>
     b2e:	0040      	lsls	r0, r0, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     b30:	4b13      	ldr	r3, [pc, #76]	; (b80 <find_volume+0x2b4>)
     b32:	469c      	mov	ip, r3
     b34:	4460      	add	r0, ip
     b36:	0a40      	lsrs	r0, r0, #9
		return FR_NO_FILESYSTEM;
     b38:	3bf3      	subs	r3, #243	; 0xf3
     b3a:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
     b3c:	4284      	cmp	r4, r0
     b3e:	d200      	bcs.n	b42 <find_volume+0x276>
     b40:	e6f5      	b.n	92e <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
     b42:	2301      	movs	r3, #1
     b44:	425b      	negs	r3, r3
     b46:	612b      	str	r3, [r5, #16]
     b48:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
     b4a:	3381      	adds	r3, #129	; 0x81
     b4c:	716b      	strb	r3, [r5, #5]
     b4e:	e073      	b.n	c38 <find_volume+0x36c>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
     b50:	2303      	movs	r3, #3
     b52:	4343      	muls	r3, r0
     b54:	085b      	lsrs	r3, r3, #1
     b56:	2101      	movs	r1, #1
     b58:	4008      	ands	r0, r1
     b5a:	1818      	adds	r0, r3, r0
     b5c:	e7e8      	b.n	b30 <find_volume+0x264>
     b5e:	46c0      	nop			; (mov r8, r8)
     b60:	000006ef 	.word	0x000006ef
     b64:	20000458 	.word	0x20000458
     b68:	000004d9 	.word	0x000004d9
     b6c:	000004e1 	.word	0x000004e1
     b70:	000007f1 	.word	0x000007f1
     b74:	00002525 	.word	0x00002525
     b78:	00000ff5 	.word	0x00000ff5
     b7c:	0000fff5 	.word	0x0000fff5
     b80:	000001ff 	.word	0x000001ff
		&& move_window(fs, bsect + 1) == FR_OK)
     b84:	1c79      	adds	r1, r7, #1
     b86:	0028      	movs	r0, r5
     b88:	4b37      	ldr	r3, [pc, #220]	; (c68 <find_volume+0x39c>)
     b8a:	4798      	blx	r3
     b8c:	2203      	movs	r2, #3
     b8e:	2800      	cmp	r0, #0
     b90:	d152      	bne.n	c38 <find_volume+0x36c>
		fs->fsi_flag = 0;
     b92:	2300      	movs	r3, #0
     b94:	716b      	strb	r3, [r5, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
     b96:	4b35      	ldr	r3, [pc, #212]	; (c6c <find_volume+0x3a0>)
     b98:	5cea      	ldrb	r2, [r5, r3]
     b9a:	0212      	lsls	r2, r2, #8
     b9c:	4b34      	ldr	r3, [pc, #208]	; (c70 <find_volume+0x3a4>)
     b9e:	5ceb      	ldrb	r3, [r5, r3]
     ba0:	4313      	orrs	r3, r2
     ba2:	4934      	ldr	r1, [pc, #208]	; (c74 <find_volume+0x3a8>)
     ba4:	b21b      	sxth	r3, r3
     ba6:	2203      	movs	r2, #3
     ba8:	428b      	cmp	r3, r1
     baa:	d145      	bne.n	c38 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
     bac:	2333      	movs	r3, #51	; 0x33
     bae:	5ceb      	ldrb	r3, [r5, r3]
     bb0:	061b      	lsls	r3, r3, #24
     bb2:	322f      	adds	r2, #47	; 0x2f
     bb4:	5caa      	ldrb	r2, [r5, r2]
     bb6:	0412      	lsls	r2, r2, #16
     bb8:	4313      	orrs	r3, r2
     bba:	2230      	movs	r2, #48	; 0x30
     bbc:	5caa      	ldrb	r2, [r5, r2]
     bbe:	4313      	orrs	r3, r2
     bc0:	2231      	movs	r2, #49	; 0x31
     bc2:	5caa      	ldrb	r2, [r5, r2]
     bc4:	0212      	lsls	r2, r2, #8
     bc6:	4313      	orrs	r3, r2
     bc8:	492b      	ldr	r1, [pc, #172]	; (c78 <find_volume+0x3ac>)
     bca:	2203      	movs	r2, #3
     bcc:	428b      	cmp	r3, r1
     bce:	d133      	bne.n	c38 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
     bd0:	4b2a      	ldr	r3, [pc, #168]	; (c7c <find_volume+0x3b0>)
     bd2:	5ceb      	ldrb	r3, [r5, r3]
     bd4:	061b      	lsls	r3, r3, #24
     bd6:	4a2a      	ldr	r2, [pc, #168]	; (c80 <find_volume+0x3b4>)
     bd8:	5caa      	ldrb	r2, [r5, r2]
     bda:	0412      	lsls	r2, r2, #16
     bdc:	4313      	orrs	r3, r2
     bde:	2285      	movs	r2, #133	; 0x85
     be0:	0092      	lsls	r2, r2, #2
     be2:	5caa      	ldrb	r2, [r5, r2]
     be4:	4313      	orrs	r3, r2
     be6:	4a27      	ldr	r2, [pc, #156]	; (c84 <find_volume+0x3b8>)
     be8:	5caa      	ldrb	r2, [r5, r2]
     bea:	0212      	lsls	r2, r2, #8
     bec:	4313      	orrs	r3, r2
     bee:	4926      	ldr	r1, [pc, #152]	; (c88 <find_volume+0x3bc>)
     bf0:	2203      	movs	r2, #3
     bf2:	428b      	cmp	r3, r1
     bf4:	d120      	bne.n	c38 <find_volume+0x36c>
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
     bf6:	4b25      	ldr	r3, [pc, #148]	; (c8c <find_volume+0x3c0>)
     bf8:	5ceb      	ldrb	r3, [r5, r3]
     bfa:	061b      	lsls	r3, r3, #24
     bfc:	4a24      	ldr	r2, [pc, #144]	; (c90 <find_volume+0x3c4>)
     bfe:	5caa      	ldrb	r2, [r5, r2]
     c00:	0412      	lsls	r2, r2, #16
     c02:	4313      	orrs	r3, r2
     c04:	2286      	movs	r2, #134	; 0x86
     c06:	0092      	lsls	r2, r2, #2
     c08:	5caa      	ldrb	r2, [r5, r2]
     c0a:	4313      	orrs	r3, r2
     c0c:	4a21      	ldr	r2, [pc, #132]	; (c94 <find_volume+0x3c8>)
     c0e:	5caa      	ldrb	r2, [r5, r2]
     c10:	0212      	lsls	r2, r2, #8
     c12:	4313      	orrs	r3, r2
     c14:	612b      	str	r3, [r5, #16]
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
     c16:	4b20      	ldr	r3, [pc, #128]	; (c98 <find_volume+0x3cc>)
     c18:	5ceb      	ldrb	r3, [r5, r3]
     c1a:	061b      	lsls	r3, r3, #24
     c1c:	4a1f      	ldr	r2, [pc, #124]	; (c9c <find_volume+0x3d0>)
     c1e:	5caa      	ldrb	r2, [r5, r2]
     c20:	0412      	lsls	r2, r2, #16
     c22:	4313      	orrs	r3, r2
     c24:	2287      	movs	r2, #135	; 0x87
     c26:	0092      	lsls	r2, r2, #2
     c28:	5caa      	ldrb	r2, [r5, r2]
     c2a:	4313      	orrs	r3, r2
     c2c:	4a1c      	ldr	r2, [pc, #112]	; (ca0 <find_volume+0x3d4>)
     c2e:	5caa      	ldrb	r2, [r5, r2]
     c30:	0212      	lsls	r2, r2, #8
     c32:	4313      	orrs	r3, r2
     c34:	60eb      	str	r3, [r5, #12]
     c36:	2203      	movs	r2, #3
	fs->fs_type = fmt;	/* FAT sub-type */
     c38:	702a      	strb	r2, [r5, #0]
	fs->id = ++Fsid;	/* File system mount ID */
     c3a:	4a1a      	ldr	r2, [pc, #104]	; (ca4 <find_volume+0x3d8>)
     c3c:	8893      	ldrh	r3, [r2, #4]
     c3e:	3301      	adds	r3, #1
     c40:	b29b      	uxth	r3, r3
     c42:	8093      	strh	r3, [r2, #4]
     c44:	80eb      	strh	r3, [r5, #6]
	return FR_OK;
     c46:	2300      	movs	r3, #0
     c48:	e671      	b.n	92e <find_volume+0x62>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
     c4a:	230c      	movs	r3, #12
     c4c:	e66f      	b.n	92e <find_volume+0x62>
			return FR_OK;				/* The file system object is valid */
     c4e:	2300      	movs	r3, #0
     c50:	e66d      	b.n	92e <find_volume+0x62>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
     c52:	2301      	movs	r3, #1
     c54:	e66b      	b.n	92e <find_volume+0x62>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
     c56:	3002      	adds	r0, #2
     c58:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
     c5a:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
     c5c:	4643      	mov	r3, r8
     c5e:	19db      	adds	r3, r3, r7
     c60:	622b      	str	r3, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
     c62:	19f6      	adds	r6, r6, r7
     c64:	62ae      	str	r6, [r5, #40]	; 0x28
     c66:	e6fd      	b.n	a64 <find_volume+0x198>
     c68:	000007b1 	.word	0x000007b1
     c6c:	0000022f 	.word	0x0000022f
     c70:	0000022e 	.word	0x0000022e
     c74:	ffffaa55 	.word	0xffffaa55
     c78:	41615252 	.word	0x41615252
     c7c:	00000217 	.word	0x00000217
     c80:	00000216 	.word	0x00000216
     c84:	00000215 	.word	0x00000215
     c88:	61417272 	.word	0x61417272
     c8c:	0000021b 	.word	0x0000021b
     c90:	0000021a 	.word	0x0000021a
     c94:	00000219 	.word	0x00000219
     c98:	0000021f 	.word	0x0000021f
     c9c:	0000021e 	.word	0x0000021e
     ca0:	0000021d 	.word	0x0000021d
     ca4:	20000458 	.word	0x20000458

00000ca8 <sync_fs>:
{
     ca8:	b570      	push	{r4, r5, r6, lr}
     caa:	0004      	movs	r4, r0
	res = sync_window(fs);
     cac:	4b2d      	ldr	r3, [pc, #180]	; (d64 <sync_fs+0xbc>)
     cae:	4798      	blx	r3
	if (res == FR_OK) {
     cb0:	2800      	cmp	r0, #0
     cb2:	d10a      	bne.n	cca <sync_fs+0x22>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
     cb4:	7823      	ldrb	r3, [r4, #0]
     cb6:	2b03      	cmp	r3, #3
     cb8:	d008      	beq.n	ccc <sync_fs+0x24>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
     cba:	7860      	ldrb	r0, [r4, #1]
     cbc:	2200      	movs	r2, #0
     cbe:	2100      	movs	r1, #0
     cc0:	4b29      	ldr	r3, [pc, #164]	; (d68 <sync_fs+0xc0>)
     cc2:	4798      	blx	r3
     cc4:	1e43      	subs	r3, r0, #1
     cc6:	4198      	sbcs	r0, r3
	res = sync_window(fs);
     cc8:	b2c0      	uxtb	r0, r0
}
     cca:	bd70      	pop	{r4, r5, r6, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
     ccc:	7963      	ldrb	r3, [r4, #5]
     cce:	2b01      	cmp	r3, #1
     cd0:	d1f3      	bne.n	cba <sync_fs+0x12>
			mem_set(fs->win, 0, SS(fs));
     cd2:	0021      	movs	r1, r4
     cd4:	3130      	adds	r1, #48	; 0x30
     cd6:	000b      	movs	r3, r1
     cd8:	228c      	movs	r2, #140	; 0x8c
     cda:	0092      	lsls	r2, r2, #2
     cdc:	18a0      	adds	r0, r4, r2
		*d++ = (BYTE)val;
     cde:	2200      	movs	r2, #0
     ce0:	701a      	strb	r2, [r3, #0]
     ce2:	3301      	adds	r3, #1
	while (cnt--)
     ce4:	4283      	cmp	r3, r0
     ce6:	d1fb      	bne.n	ce0 <sync_fs+0x38>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
     ce8:	2255      	movs	r2, #85	; 0x55
     cea:	4b20      	ldr	r3, [pc, #128]	; (d6c <sync_fs+0xc4>)
     cec:	54e2      	strb	r2, [r4, r3]
     cee:	3255      	adds	r2, #85	; 0x55
     cf0:	4b1f      	ldr	r3, [pc, #124]	; (d70 <sync_fs+0xc8>)
     cf2:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
     cf4:	3bde      	subs	r3, #222	; 0xde
     cf6:	3bff      	subs	r3, #255	; 0xff
     cf8:	3a7a      	subs	r2, #122	; 0x7a
     cfa:	54a3      	strb	r3, [r4, r2]
     cfc:	3201      	adds	r2, #1
     cfe:	54a3      	strb	r3, [r4, r2]
     d00:	330f      	adds	r3, #15
     d02:	3201      	adds	r2, #1
     d04:	54a3      	strb	r3, [r4, r2]
     d06:	320f      	adds	r2, #15
     d08:	2033      	movs	r0, #51	; 0x33
     d0a:	5422      	strb	r2, [r4, r0]
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
     d0c:	303f      	adds	r0, #63	; 0x3f
     d0e:	2585      	movs	r5, #133	; 0x85
     d10:	00ad      	lsls	r5, r5, #2
     d12:	5560      	strb	r0, [r4, r5]
     d14:	4d17      	ldr	r5, [pc, #92]	; (d74 <sync_fs+0xcc>)
     d16:	5560      	strb	r0, [r4, r5]
     d18:	4817      	ldr	r0, [pc, #92]	; (d78 <sync_fs+0xd0>)
     d1a:	5422      	strb	r2, [r4, r0]
     d1c:	4a17      	ldr	r2, [pc, #92]	; (d7c <sync_fs+0xd4>)
     d1e:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
     d20:	6923      	ldr	r3, [r4, #16]
     d22:	3201      	adds	r2, #1
     d24:	54a3      	strb	r3, [r4, r2]
     d26:	0a18      	lsrs	r0, r3, #8
     d28:	4a15      	ldr	r2, [pc, #84]	; (d80 <sync_fs+0xd8>)
     d2a:	54a0      	strb	r0, [r4, r2]
     d2c:	0c18      	lsrs	r0, r3, #16
     d2e:	4a15      	ldr	r2, [pc, #84]	; (d84 <sync_fs+0xdc>)
     d30:	54a0      	strb	r0, [r4, r2]
     d32:	0e1b      	lsrs	r3, r3, #24
     d34:	4a14      	ldr	r2, [pc, #80]	; (d88 <sync_fs+0xe0>)
     d36:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
     d38:	68e3      	ldr	r3, [r4, #12]
     d3a:	3201      	adds	r2, #1
     d3c:	54a3      	strb	r3, [r4, r2]
     d3e:	0a18      	lsrs	r0, r3, #8
     d40:	4a12      	ldr	r2, [pc, #72]	; (d8c <sync_fs+0xe4>)
     d42:	54a0      	strb	r0, [r4, r2]
     d44:	0c18      	lsrs	r0, r3, #16
     d46:	4a12      	ldr	r2, [pc, #72]	; (d90 <sync_fs+0xe8>)
     d48:	54a0      	strb	r0, [r4, r2]
     d4a:	0e1b      	lsrs	r3, r3, #24
     d4c:	4a11      	ldr	r2, [pc, #68]	; (d94 <sync_fs+0xec>)
     d4e:	54a3      	strb	r3, [r4, r2]
			fs->winsect = fs->volbase + 1;
     d50:	69e3      	ldr	r3, [r4, #28]
     d52:	1c5a      	adds	r2, r3, #1
     d54:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
     d56:	7860      	ldrb	r0, [r4, #1]
     d58:	2301      	movs	r3, #1
     d5a:	4d0f      	ldr	r5, [pc, #60]	; (d98 <sync_fs+0xf0>)
     d5c:	47a8      	blx	r5
			fs->fsi_flag = 0;
     d5e:	2300      	movs	r3, #0
     d60:	7163      	strb	r3, [r4, #5]
     d62:	e7aa      	b.n	cba <sync_fs+0x12>
     d64:	00000745 	.word	0x00000745
     d68:	000005b5 	.word	0x000005b5
     d6c:	0000022e 	.word	0x0000022e
     d70:	0000022f 	.word	0x0000022f
     d74:	00000215 	.word	0x00000215
     d78:	00000216 	.word	0x00000216
     d7c:	00000217 	.word	0x00000217
     d80:	00000219 	.word	0x00000219
     d84:	0000021a 	.word	0x0000021a
     d88:	0000021b 	.word	0x0000021b
     d8c:	0000021d 	.word	0x0000021d
     d90:	0000021e 	.word	0x0000021e
     d94:	0000021f 	.word	0x0000021f
     d98:	0000055d 	.word	0x0000055d

00000d9c <clust2sect>:
{
     d9c:	0002      	movs	r2, r0
	clst -= 2;
     d9e:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
     da0:	6943      	ldr	r3, [r0, #20]
     da2:	3b02      	subs	r3, #2
     da4:	2000      	movs	r0, #0
     da6:	4299      	cmp	r1, r3
     da8:	d203      	bcs.n	db2 <clust2sect+0x16>
	return clst * fs->csize + fs->database;
     daa:	7890      	ldrb	r0, [r2, #2]
     dac:	4341      	muls	r1, r0
     dae:	6a90      	ldr	r0, [r2, #40]	; 0x28
     db0:	1808      	adds	r0, r1, r0
}
     db2:	4770      	bx	lr

00000db4 <get_fat>:
{
     db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     db6:	0005      	movs	r5, r0
     db8:	000c      	movs	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     dba:	2901      	cmp	r1, #1
     dbc:	d972      	bls.n	ea4 <get_fat+0xf0>
		val = 1;	/* Internal error */
     dbe:	2001      	movs	r0, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     dc0:	696b      	ldr	r3, [r5, #20]
     dc2:	4299      	cmp	r1, r3
     dc4:	d26f      	bcs.n	ea6 <get_fat+0xf2>
		switch (fs->fs_type) {
     dc6:	782b      	ldrb	r3, [r5, #0]
     dc8:	2b02      	cmp	r3, #2
     dca:	d032      	beq.n	e32 <get_fat+0x7e>
     dcc:	2b03      	cmp	r3, #3
     dce:	d047      	beq.n	e60 <get_fat+0xac>
			val = 1;	/* Internal error */
     dd0:	2001      	movs	r0, #1
		switch (fs->fs_type) {
     dd2:	2b01      	cmp	r3, #1
     dd4:	d167      	bne.n	ea6 <get_fat+0xf2>
			bc = (UINT)clst; bc += bc / 2;
     dd6:	084e      	lsrs	r6, r1, #1
     dd8:	1876      	adds	r6, r6, r1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
     dda:	0a71      	lsrs	r1, r6, #9
     ddc:	6a2b      	ldr	r3, [r5, #32]
     dde:	469c      	mov	ip, r3
     de0:	4461      	add	r1, ip
     de2:	0028      	movs	r0, r5
     de4:	4b30      	ldr	r3, [pc, #192]	; (ea8 <get_fat+0xf4>)
     de6:	4798      	blx	r3
     de8:	2800      	cmp	r0, #0
     dea:	d002      	beq.n	df2 <get_fat+0x3e>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     dec:	2001      	movs	r0, #1
     dee:	4240      	negs	r0, r0
     df0:	e059      	b.n	ea6 <get_fat+0xf2>
			wc = fs->win[bc++ % SS(fs)];
     df2:	1c77      	adds	r7, r6, #1
     df4:	05f3      	lsls	r3, r6, #23
     df6:	0ddb      	lsrs	r3, r3, #23
     df8:	18eb      	adds	r3, r5, r3
     dfa:	3330      	adds	r3, #48	; 0x30
     dfc:	781e      	ldrb	r6, [r3, #0]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
     dfe:	0a79      	lsrs	r1, r7, #9
     e00:	6a2b      	ldr	r3, [r5, #32]
     e02:	469c      	mov	ip, r3
     e04:	4461      	add	r1, ip
     e06:	0028      	movs	r0, r5
     e08:	4b27      	ldr	r3, [pc, #156]	; (ea8 <get_fat+0xf4>)
     e0a:	4798      	blx	r3
     e0c:	2800      	cmp	r0, #0
     e0e:	d002      	beq.n	e16 <get_fat+0x62>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     e10:	2001      	movs	r0, #1
     e12:	4240      	negs	r0, r0
     e14:	e047      	b.n	ea6 <get_fat+0xf2>
			wc |= fs->win[bc % SS(fs)] << 8;
     e16:	05ff      	lsls	r7, r7, #23
     e18:	0dff      	lsrs	r7, r7, #23
     e1a:	19ed      	adds	r5, r5, r7
     e1c:	3530      	adds	r5, #48	; 0x30
     e1e:	7828      	ldrb	r0, [r5, #0]
     e20:	0200      	lsls	r0, r0, #8
     e22:	4330      	orrs	r0, r6
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
     e24:	07e3      	lsls	r3, r4, #31
     e26:	d501      	bpl.n	e2c <get_fat+0x78>
     e28:	0900      	lsrs	r0, r0, #4
     e2a:	e03c      	b.n	ea6 <get_fat+0xf2>
     e2c:	0500      	lsls	r0, r0, #20
     e2e:	0d00      	lsrs	r0, r0, #20
     e30:	e039      	b.n	ea6 <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
     e32:	0a09      	lsrs	r1, r1, #8
     e34:	6a2b      	ldr	r3, [r5, #32]
     e36:	469c      	mov	ip, r3
     e38:	4461      	add	r1, ip
     e3a:	0028      	movs	r0, r5
     e3c:	4b1a      	ldr	r3, [pc, #104]	; (ea8 <get_fat+0xf4>)
     e3e:	4798      	blx	r3
     e40:	2800      	cmp	r0, #0
     e42:	d002      	beq.n	e4a <get_fat+0x96>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     e44:	2001      	movs	r0, #1
     e46:	4240      	negs	r0, r0
     e48:	e02d      	b.n	ea6 <get_fat+0xf2>
			p = &fs->win[clst * 2 % SS(fs)];
     e4a:	0064      	lsls	r4, r4, #1
     e4c:	23ff      	movs	r3, #255	; 0xff
     e4e:	005b      	lsls	r3, r3, #1
     e50:	401c      	ands	r4, r3
			val = LD_WORD(p);
     e52:	192d      	adds	r5, r5, r4
     e54:	3530      	adds	r5, #48	; 0x30
     e56:	786b      	ldrb	r3, [r5, #1]
     e58:	021b      	lsls	r3, r3, #8
     e5a:	7828      	ldrb	r0, [r5, #0]
     e5c:	4318      	orrs	r0, r3
			break;
     e5e:	e022      	b.n	ea6 <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
     e60:	09c9      	lsrs	r1, r1, #7
     e62:	6a2b      	ldr	r3, [r5, #32]
     e64:	469c      	mov	ip, r3
     e66:	4461      	add	r1, ip
     e68:	0028      	movs	r0, r5
     e6a:	4b0f      	ldr	r3, [pc, #60]	; (ea8 <get_fat+0xf4>)
     e6c:	4798      	blx	r3
     e6e:	2800      	cmp	r0, #0
     e70:	d002      	beq.n	e78 <get_fat+0xc4>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
     e72:	2001      	movs	r0, #1
     e74:	4240      	negs	r0, r0
	return val;
     e76:	e016      	b.n	ea6 <get_fat+0xf2>
			p = &fs->win[clst * 4 % SS(fs)];
     e78:	00a4      	lsls	r4, r4, #2
     e7a:	23fe      	movs	r3, #254	; 0xfe
     e7c:	005b      	lsls	r3, r3, #1
     e7e:	401c      	ands	r4, r3
     e80:	0023      	movs	r3, r4
     e82:	3330      	adds	r3, #48	; 0x30
     e84:	18eb      	adds	r3, r5, r3
			val = LD_DWORD(p) & 0x0FFFFFFF;
     e86:	78d8      	ldrb	r0, [r3, #3]
     e88:	0600      	lsls	r0, r0, #24
     e8a:	789a      	ldrb	r2, [r3, #2]
     e8c:	0412      	lsls	r2, r2, #16
     e8e:	4310      	orrs	r0, r2
     e90:	192c      	adds	r4, r5, r4
     e92:	3430      	adds	r4, #48	; 0x30
     e94:	7822      	ldrb	r2, [r4, #0]
     e96:	4310      	orrs	r0, r2
     e98:	785b      	ldrb	r3, [r3, #1]
     e9a:	021b      	lsls	r3, r3, #8
     e9c:	4318      	orrs	r0, r3
     e9e:	0100      	lsls	r0, r0, #4
     ea0:	0900      	lsrs	r0, r0, #4
			break;
     ea2:	e000      	b.n	ea6 <get_fat+0xf2>
		val = 1;	/* Internal error */
     ea4:	2001      	movs	r0, #1
}
     ea6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ea8:	000007b1 	.word	0x000007b1

00000eac <dir_sdi>:
{
     eac:	b5f0      	push	{r4, r5, r6, r7, lr}
     eae:	46c6      	mov	lr, r8
     eb0:	b500      	push	{lr}
     eb2:	0005      	movs	r5, r0
     eb4:	000e      	movs	r6, r1
	dp->index = (WORD)idx;	/* Current index */
     eb6:	80e9      	strh	r1, [r5, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
     eb8:	6884      	ldr	r4, [r0, #8]
		return FR_INT_ERR;
     eba:	2002      	movs	r0, #2
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
     ebc:	2c01      	cmp	r4, #1
     ebe:	d003      	beq.n	ec8 <dir_sdi+0x1c>
     ec0:	682b      	ldr	r3, [r5, #0]
     ec2:	695a      	ldr	r2, [r3, #20]
     ec4:	4294      	cmp	r4, r2
     ec6:	d302      	bcc.n	ece <dir_sdi+0x22>
}
     ec8:	bc04      	pop	{r2}
     eca:	4690      	mov	r8, r2
     ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
     ece:	2c00      	cmp	r4, #0
     ed0:	d11b      	bne.n	f0a <dir_sdi+0x5e>
     ed2:	781a      	ldrb	r2, [r3, #0]
     ed4:	2a03      	cmp	r2, #3
     ed6:	d014      	beq.n	f02 <dir_sdi+0x56>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
     ed8:	891a      	ldrh	r2, [r3, #8]
			return FR_INT_ERR;
     eda:	2002      	movs	r0, #2
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
     edc:	4296      	cmp	r6, r2
     ede:	d2f3      	bcs.n	ec8 <dir_sdi+0x1c>
		sect = dp->fs->dirbase;
     ee0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	dp->clust = clst;	/* Current cluster# */
     ee2:	60ec      	str	r4, [r5, #12]
	if (!sect) return FR_INT_ERR;
     ee4:	2002      	movs	r0, #2
     ee6:	2b00      	cmp	r3, #0
     ee8:	d0ee      	beq.n	ec8 <dir_sdi+0x1c>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
     eea:	0930      	lsrs	r0, r6, #4
     eec:	18c3      	adds	r3, r0, r3
     eee:	612b      	str	r3, [r5, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
     ef0:	682b      	ldr	r3, [r5, #0]
     ef2:	3330      	adds	r3, #48	; 0x30
     ef4:	220f      	movs	r2, #15
     ef6:	4016      	ands	r6, r2
     ef8:	0176      	lsls	r6, r6, #5
     efa:	199e      	adds	r6, r3, r6
     efc:	616e      	str	r6, [r5, #20]
	return FR_OK;
     efe:	2000      	movs	r0, #0
     f00:	e7e2      	b.n	ec8 <dir_sdi+0x1c>
		clst = dp->fs->dirbase;
     f02:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
     f04:	2a00      	cmp	r2, #0
     f06:	d0e7      	beq.n	ed8 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
     f08:	0014      	movs	r4, r2
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
     f0a:	789f      	ldrb	r7, [r3, #2]
     f0c:	013f      	lsls	r7, r7, #4
		while (idx >= ic) {	/* Follow cluster chain */
     f0e:	42be      	cmp	r6, r7
     f10:	d313      	bcc.n	f3a <dir_sdi+0x8e>
     f12:	1bf6      	subs	r6, r6, r7
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
     f14:	4b0f      	ldr	r3, [pc, #60]	; (f54 <dir_sdi+0xa8>)
     f16:	4698      	mov	r8, r3
     f18:	e000      	b.n	f1c <dir_sdi+0x70>
     f1a:	001e      	movs	r6, r3
     f1c:	0021      	movs	r1, r4
     f1e:	6828      	ldr	r0, [r5, #0]
     f20:	47c0      	blx	r8
     f22:	0004      	movs	r4, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
     f24:	1c43      	adds	r3, r0, #1
     f26:	d00e      	beq.n	f46 <dir_sdi+0x9a>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
     f28:	2801      	cmp	r0, #1
     f2a:	d90e      	bls.n	f4a <dir_sdi+0x9e>
     f2c:	682b      	ldr	r3, [r5, #0]
     f2e:	695b      	ldr	r3, [r3, #20]
     f30:	4298      	cmp	r0, r3
     f32:	d20c      	bcs.n	f4e <dir_sdi+0xa2>
     f34:	1bf3      	subs	r3, r6, r7
		while (idx >= ic) {	/* Follow cluster chain */
     f36:	42be      	cmp	r6, r7
     f38:	d2ef      	bcs.n	f1a <dir_sdi+0x6e>
		sect = clust2sect(dp->fs, clst);
     f3a:	0021      	movs	r1, r4
     f3c:	6828      	ldr	r0, [r5, #0]
     f3e:	4b06      	ldr	r3, [pc, #24]	; (f58 <dir_sdi+0xac>)
     f40:	4798      	blx	r3
     f42:	0003      	movs	r3, r0
     f44:	e7cd      	b.n	ee2 <dir_sdi+0x36>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
     f46:	2001      	movs	r0, #1
     f48:	e7be      	b.n	ec8 <dir_sdi+0x1c>
				return FR_INT_ERR;
     f4a:	2002      	movs	r0, #2
     f4c:	e7bc      	b.n	ec8 <dir_sdi+0x1c>
     f4e:	2002      	movs	r0, #2
     f50:	e7ba      	b.n	ec8 <dir_sdi+0x1c>
     f52:	46c0      	nop			; (mov r8, r8)
     f54:	00000db5 	.word	0x00000db5
     f58:	00000d9d 	.word	0x00000d9d

00000f5c <put_fat>:
{
     f5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     f5e:	46ce      	mov	lr, r9
     f60:	4647      	mov	r7, r8
     f62:	b580      	push	{r7, lr}
     f64:	0007      	movs	r7, r0
     f66:	000c      	movs	r4, r1
     f68:	0016      	movs	r6, r2
		res = FR_INT_ERR;
     f6a:	2502      	movs	r5, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
     f6c:	2901      	cmp	r1, #1
     f6e:	d902      	bls.n	f76 <put_fat+0x1a>
     f70:	6943      	ldr	r3, [r0, #20]
     f72:	4299      	cmp	r1, r3
     f74:	d304      	bcc.n	f80 <put_fat+0x24>
}
     f76:	0028      	movs	r0, r5
     f78:	bc0c      	pop	{r2, r3}
     f7a:	4690      	mov	r8, r2
     f7c:	4699      	mov	r9, r3
     f7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (fs->fs_type) {
     f80:	7803      	ldrb	r3, [r0, #0]
     f82:	2b02      	cmp	r3, #2
     f84:	d055      	beq.n	1032 <put_fat+0xd6>
     f86:	2b03      	cmp	r3, #3
     f88:	d067      	beq.n	105a <put_fat+0xfe>
			res = FR_INT_ERR;
     f8a:	2502      	movs	r5, #2
		switch (fs->fs_type) {
     f8c:	2b01      	cmp	r3, #1
     f8e:	d1f2      	bne.n	f76 <put_fat+0x1a>
			bc = (UINT)clst; bc += bc / 2;
     f90:	084b      	lsrs	r3, r1, #1
     f92:	4698      	mov	r8, r3
     f94:	4488      	add	r8, r1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
     f96:	4643      	mov	r3, r8
     f98:	0a59      	lsrs	r1, r3, #9
     f9a:	6a03      	ldr	r3, [r0, #32]
     f9c:	469c      	mov	ip, r3
     f9e:	4461      	add	r1, ip
     fa0:	4b40      	ldr	r3, [pc, #256]	; (10a4 <put_fat+0x148>)
     fa2:	4798      	blx	r3
     fa4:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
     fa6:	d1e6      	bne.n	f76 <put_fat+0x1a>
			p = &fs->win[bc++ % SS(fs)];
     fa8:	2301      	movs	r3, #1
     faa:	4443      	add	r3, r8
     fac:	4699      	mov	r9, r3
     fae:	4643      	mov	r3, r8
     fb0:	05db      	lsls	r3, r3, #23
     fb2:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     fb4:	07e2      	lsls	r2, r4, #31
     fb6:	d521      	bpl.n	ffc <put_fat+0xa0>
     fb8:	18fb      	adds	r3, r7, r3
     fba:	3330      	adds	r3, #48	; 0x30
     fbc:	7819      	ldrb	r1, [r3, #0]
     fbe:	220f      	movs	r2, #15
     fc0:	400a      	ands	r2, r1
     fc2:	0131      	lsls	r1, r6, #4
     fc4:	20ff      	movs	r0, #255	; 0xff
     fc6:	0100      	lsls	r0, r0, #4
     fc8:	4001      	ands	r1, r0
     fca:	430a      	orrs	r2, r1
     fcc:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
     fce:	2301      	movs	r3, #1
     fd0:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
     fd2:	464b      	mov	r3, r9
     fd4:	0a59      	lsrs	r1, r3, #9
     fd6:	6a3b      	ldr	r3, [r7, #32]
     fd8:	469c      	mov	ip, r3
     fda:	4461      	add	r1, ip
     fdc:	0038      	movs	r0, r7
     fde:	4b31      	ldr	r3, [pc, #196]	; (10a4 <put_fat+0x148>)
     fe0:	4798      	blx	r3
			if (res != FR_OK) break;
     fe2:	2800      	cmp	r0, #0
     fe4:	d159      	bne.n	109a <put_fat+0x13e>
			p = &fs->win[bc % SS(fs)];
     fe6:	464b      	mov	r3, r9
     fe8:	05db      	lsls	r3, r3, #23
     fea:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
     fec:	0936      	lsrs	r6, r6, #4
     fee:	b2f6      	uxtb	r6, r6
     ff0:	18fb      	adds	r3, r7, r3
     ff2:	3330      	adds	r3, #48	; 0x30
     ff4:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
     ff6:	2301      	movs	r3, #1
     ff8:	713b      	strb	r3, [r7, #4]
			break;
     ffa:	e7bc      	b.n	f76 <put_fat+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
     ffc:	18fb      	adds	r3, r7, r3
     ffe:	3330      	adds	r3, #48	; 0x30
    1000:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
    1002:	2301      	movs	r3, #1
    1004:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    1006:	464b      	mov	r3, r9
    1008:	0a59      	lsrs	r1, r3, #9
    100a:	6a3b      	ldr	r3, [r7, #32]
    100c:	469c      	mov	ip, r3
    100e:	4461      	add	r1, ip
    1010:	0038      	movs	r0, r7
    1012:	4b24      	ldr	r3, [pc, #144]	; (10a4 <put_fat+0x148>)
    1014:	4798      	blx	r3
			if (res != FR_OK) break;
    1016:	2800      	cmp	r0, #0
    1018:	d141      	bne.n	109e <put_fat+0x142>
			p = &fs->win[bc % SS(fs)];
    101a:	464b      	mov	r3, r9
    101c:	05db      	lsls	r3, r3, #23
    101e:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    1020:	18fa      	adds	r2, r7, r3
    1022:	3230      	adds	r2, #48	; 0x30
    1024:	7812      	ldrb	r2, [r2, #0]
    1026:	210f      	movs	r1, #15
    1028:	438a      	bics	r2, r1
    102a:	0536      	lsls	r6, r6, #20
    102c:	0f36      	lsrs	r6, r6, #28
    102e:	4316      	orrs	r6, r2
    1030:	e7de      	b.n	ff0 <put_fat+0x94>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    1032:	0a09      	lsrs	r1, r1, #8
    1034:	6a03      	ldr	r3, [r0, #32]
    1036:	469c      	mov	ip, r3
    1038:	4461      	add	r1, ip
    103a:	4b1a      	ldr	r3, [pc, #104]	; (10a4 <put_fat+0x148>)
    103c:	4798      	blx	r3
    103e:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    1040:	d199      	bne.n	f76 <put_fat+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
    1042:	0063      	lsls	r3, r4, #1
    1044:	24ff      	movs	r4, #255	; 0xff
    1046:	0064      	lsls	r4, r4, #1
    1048:	4023      	ands	r3, r4
			ST_WORD(p, (WORD)val);
    104a:	18fb      	adds	r3, r7, r3
    104c:	3330      	adds	r3, #48	; 0x30
    104e:	701e      	strb	r6, [r3, #0]
    1050:	0a36      	lsrs	r6, r6, #8
    1052:	705e      	strb	r6, [r3, #1]
			fs->wflag = 1;
    1054:	2301      	movs	r3, #1
    1056:	713b      	strb	r3, [r7, #4]
			break;
    1058:	e78d      	b.n	f76 <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    105a:	09c9      	lsrs	r1, r1, #7
    105c:	6a03      	ldr	r3, [r0, #32]
    105e:	469c      	mov	ip, r3
    1060:	4461      	add	r1, ip
    1062:	4b10      	ldr	r3, [pc, #64]	; (10a4 <put_fat+0x148>)
    1064:	4798      	blx	r3
    1066:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    1068:	d000      	beq.n	106c <put_fat+0x110>
    106a:	e784      	b.n	f76 <put_fat+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
    106c:	00a4      	lsls	r4, r4, #2
    106e:	23fe      	movs	r3, #254	; 0xfe
    1070:	005b      	lsls	r3, r3, #1
    1072:	401c      	ands	r4, r3
    1074:	0022      	movs	r2, r4
    1076:	3230      	adds	r2, #48	; 0x30
    1078:	18ba      	adds	r2, r7, r2
			val |= LD_DWORD(p) & 0xF0000000;
    107a:	78d3      	ldrb	r3, [r2, #3]
    107c:	193c      	adds	r4, r7, r4
    107e:	3430      	adds	r4, #48	; 0x30
    1080:	091b      	lsrs	r3, r3, #4
    1082:	071b      	lsls	r3, r3, #28
    1084:	431e      	orrs	r6, r3
			ST_DWORD(p, val);
    1086:	7026      	strb	r6, [r4, #0]
    1088:	0a33      	lsrs	r3, r6, #8
    108a:	7053      	strb	r3, [r2, #1]
    108c:	0c33      	lsrs	r3, r6, #16
    108e:	7093      	strb	r3, [r2, #2]
    1090:	0e36      	lsrs	r6, r6, #24
    1092:	70d6      	strb	r6, [r2, #3]
			fs->wflag = 1;
    1094:	2301      	movs	r3, #1
    1096:	713b      	strb	r3, [r7, #4]
			break;
    1098:	e76d      	b.n	f76 <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    109a:	0005      	movs	r5, r0
    109c:	e76b      	b.n	f76 <put_fat+0x1a>
    109e:	0005      	movs	r5, r0
	return res;
    10a0:	e769      	b.n	f76 <put_fat+0x1a>
    10a2:	46c0      	nop			; (mov r8, r8)
    10a4:	000007b1 	.word	0x000007b1

000010a8 <create_chain>:
{
    10a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    10aa:	46c6      	mov	lr, r8
    10ac:	b500      	push	{lr}
    10ae:	0005      	movs	r5, r0
    10b0:	4688      	mov	r8, r1
	if (clst == 0) {		/* Create a new chain */
    10b2:	2900      	cmp	r1, #0
    10b4:	d107      	bne.n	10c6 <create_chain+0x1e>
		scl = fs->last_clust;			/* Get suggested start point */
    10b6:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
    10b8:	2e00      	cmp	r6, #0
    10ba:	d00f      	beq.n	10dc <create_chain+0x34>
    10bc:	6943      	ldr	r3, [r0, #20]
    10be:	429e      	cmp	r6, r3
    10c0:	d30d      	bcc.n	10de <create_chain+0x36>
    10c2:	2601      	movs	r6, #1
    10c4:	e00b      	b.n	10de <create_chain+0x36>
		cs = get_fat(fs, clst);			/* Check the cluster status */
    10c6:	4b28      	ldr	r3, [pc, #160]	; (1168 <create_chain+0xc0>)
    10c8:	4798      	blx	r3
		if (cs < 2) return 1;			/* Invalid value */
    10ca:	2801      	cmp	r0, #1
    10cc:	d941      	bls.n	1152 <create_chain+0xaa>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
    10ce:	1c43      	adds	r3, r0, #1
    10d0:	d044      	beq.n	115c <create_chain+0xb4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    10d2:	696b      	ldr	r3, [r5, #20]
		scl = clst;
    10d4:	4646      	mov	r6, r8
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    10d6:	4298      	cmp	r0, r3
    10d8:	d201      	bcs.n	10de <create_chain+0x36>
    10da:	e03f      	b.n	115c <create_chain+0xb4>
		if (!scl || scl >= fs->n_fatent) scl = 1;
    10dc:	2601      	movs	r6, #1
	ncl = scl;				/* Start cluster */
    10de:	0034      	movs	r4, r6
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    10e0:	4f21      	ldr	r7, [pc, #132]	; (1168 <create_chain+0xc0>)
    10e2:	e00a      	b.n	10fa <create_chain+0x52>
    10e4:	0021      	movs	r1, r4
    10e6:	0028      	movs	r0, r5
    10e8:	47b8      	blx	r7
		if (cs == 0) break;				/* Found a free cluster */
    10ea:	2800      	cmp	r0, #0
    10ec:	d00d      	beq.n	110a <create_chain+0x62>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    10ee:	1c43      	adds	r3, r0, #1
    10f0:	d034      	beq.n	115c <create_chain+0xb4>
    10f2:	2801      	cmp	r0, #1
    10f4:	d032      	beq.n	115c <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    10f6:	42b4      	cmp	r4, r6
    10f8:	d02f      	beq.n	115a <create_chain+0xb2>
		ncl++;							/* Next cluster */
    10fa:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
    10fc:	696b      	ldr	r3, [r5, #20]
    10fe:	429c      	cmp	r4, r3
    1100:	d3f0      	bcc.n	10e4 <create_chain+0x3c>
			if (ncl > scl) return 0;	/* No free cluster */
    1102:	2e01      	cmp	r6, #1
    1104:	d927      	bls.n	1156 <create_chain+0xae>
			ncl = 2;
    1106:	2402      	movs	r4, #2
    1108:	e7ec      	b.n	10e4 <create_chain+0x3c>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    110a:	4a18      	ldr	r2, [pc, #96]	; (116c <create_chain+0xc4>)
    110c:	0021      	movs	r1, r4
    110e:	0028      	movs	r0, r5
    1110:	4b17      	ldr	r3, [pc, #92]	; (1170 <create_chain+0xc8>)
    1112:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
    1114:	2800      	cmp	r0, #0
    1116:	d115      	bne.n	1144 <create_chain+0x9c>
    1118:	4643      	mov	r3, r8
    111a:	2b00      	cmp	r3, #0
    111c:	d10b      	bne.n	1136 <create_chain+0x8e>
		fs->last_clust = ncl;			/* Update FSINFO */
    111e:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
    1120:	692b      	ldr	r3, [r5, #16]
    1122:	1c5a      	adds	r2, r3, #1
    1124:	d01d      	beq.n	1162 <create_chain+0xba>
			fs->free_clust--;
    1126:	3b01      	subs	r3, #1
    1128:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
    112a:	796b      	ldrb	r3, [r5, #5]
    112c:	2201      	movs	r2, #1
    112e:	4313      	orrs	r3, r2
    1130:	716b      	strb	r3, [r5, #5]
    1132:	0020      	movs	r0, r4
    1134:	e012      	b.n	115c <create_chain+0xb4>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    1136:	0022      	movs	r2, r4
    1138:	4641      	mov	r1, r8
    113a:	0028      	movs	r0, r5
    113c:	4b0c      	ldr	r3, [pc, #48]	; (1170 <create_chain+0xc8>)
    113e:	4798      	blx	r3
	if (res == FR_OK) {
    1140:	2800      	cmp	r0, #0
    1142:	d0ec      	beq.n	111e <create_chain+0x76>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    1144:	3801      	subs	r0, #1
    1146:	4242      	negs	r2, r0
    1148:	4142      	adcs	r2, r0
    114a:	4250      	negs	r0, r2
    114c:	2301      	movs	r3, #1
    114e:	4318      	orrs	r0, r3
    1150:	e004      	b.n	115c <create_chain+0xb4>
		if (cs < 2) return 1;			/* Invalid value */
    1152:	2001      	movs	r0, #1
    1154:	e002      	b.n	115c <create_chain+0xb4>
			if (ncl > scl) return 0;	/* No free cluster */
    1156:	2000      	movs	r0, #0
    1158:	e000      	b.n	115c <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    115a:	2000      	movs	r0, #0
}
    115c:	bc04      	pop	{r2}
    115e:	4690      	mov	r8, r2
    1160:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1162:	0020      	movs	r0, r4
    1164:	e7fa      	b.n	115c <create_chain+0xb4>
    1166:	46c0      	nop			; (mov r8, r8)
    1168:	00000db5 	.word	0x00000db5
    116c:	0fffffff 	.word	0x0fffffff
    1170:	00000f5d 	.word	0x00000f5d

00001174 <dir_next>:
{
    1174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1176:	46ce      	mov	lr, r9
    1178:	4647      	mov	r7, r8
    117a:	b580      	push	{r7, lr}
    117c:	0006      	movs	r6, r0
    117e:	000d      	movs	r5, r1
	i = dp->index + 1;
    1180:	88c4      	ldrh	r4, [r0, #6]
    1182:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    1184:	0423      	lsls	r3, r4, #16
		return FR_NO_FILE;
    1186:	2004      	movs	r0, #4
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    1188:	2b00      	cmp	r3, #0
    118a:	d103      	bne.n	1194 <dir_next+0x20>
}
    118c:	bc0c      	pop	{r2, r3}
    118e:	4690      	mov	r8, r2
    1190:	4699      	mov	r9, r3
    1192:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    1194:	6933      	ldr	r3, [r6, #16]
    1196:	2b00      	cmp	r3, #0
    1198:	d0f8      	beq.n	118c <dir_next+0x18>
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
    119a:	270f      	movs	r7, #15
    119c:	4027      	ands	r7, r4
    119e:	d110      	bne.n	11c2 <dir_next+0x4e>
		dp->sect++;					/* Next sector */
    11a0:	3301      	adds	r3, #1
    11a2:	6133      	str	r3, [r6, #16]
		if (!dp->clust) {		/* Static table */
    11a4:	68f1      	ldr	r1, [r6, #12]
    11a6:	2900      	cmp	r1, #0
    11a8:	d104      	bne.n	11b4 <dir_next+0x40>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
    11aa:	6833      	ldr	r3, [r6, #0]
    11ac:	891b      	ldrh	r3, [r3, #8]
    11ae:	429c      	cmp	r4, r3
    11b0:	d2ec      	bcs.n	118c <dir_next+0x18>
    11b2:	e006      	b.n	11c2 <dir_next+0x4e>
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
    11b4:	6830      	ldr	r0, [r6, #0]
    11b6:	7883      	ldrb	r3, [r0, #2]
    11b8:	3b01      	subs	r3, #1
    11ba:	0922      	lsrs	r2, r4, #4
    11bc:	401a      	ands	r2, r3
    11be:	4690      	mov	r8, r2
    11c0:	d007      	beq.n	11d2 <dir_next+0x5e>
	dp->index = (WORD)i;	/* Current index */
    11c2:	80f4      	strh	r4, [r6, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
    11c4:	6833      	ldr	r3, [r6, #0]
    11c6:	3330      	adds	r3, #48	; 0x30
    11c8:	017f      	lsls	r7, r7, #5
    11ca:	19df      	adds	r7, r3, r7
    11cc:	6177      	str	r7, [r6, #20]
	return FR_OK;
    11ce:	2000      	movs	r0, #0
    11d0:	e7dc      	b.n	118c <dir_next+0x18>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
    11d2:	4b2d      	ldr	r3, [pc, #180]	; (1288 <dir_next+0x114>)
    11d4:	4798      	blx	r3
    11d6:	4681      	mov	r9, r0
				if (clst <= 1) return FR_INT_ERR;
    11d8:	2002      	movs	r0, #2
    11da:	464b      	mov	r3, r9
    11dc:	2b01      	cmp	r3, #1
    11de:	d9d5      	bls.n	118c <dir_next+0x18>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    11e0:	3301      	adds	r3, #1
    11e2:	d04d      	beq.n	1280 <dir_next+0x10c>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
    11e4:	6833      	ldr	r3, [r6, #0]
    11e6:	695a      	ldr	r2, [r3, #20]
    11e8:	4591      	cmp	r9, r2
    11ea:	d341      	bcc.n	1270 <dir_next+0xfc>
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
    11ec:	3002      	adds	r0, #2
    11ee:	2d00      	cmp	r5, #0
    11f0:	d0cc      	beq.n	118c <dir_next+0x18>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
    11f2:	68f1      	ldr	r1, [r6, #12]
    11f4:	0018      	movs	r0, r3
    11f6:	4b25      	ldr	r3, [pc, #148]	; (128c <dir_next+0x118>)
    11f8:	4798      	blx	r3
    11fa:	4681      	mov	r9, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    11fc:	2007      	movs	r0, #7
    11fe:	464b      	mov	r3, r9
    1200:	2b00      	cmp	r3, #0
    1202:	d0c3      	beq.n	118c <dir_next+0x18>
					if (clst == 1) return FR_INT_ERR;
    1204:	3805      	subs	r0, #5
    1206:	2b01      	cmp	r3, #1
    1208:	d0c0      	beq.n	118c <dir_next+0x18>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    120a:	3801      	subs	r0, #1
    120c:	3301      	adds	r3, #1
    120e:	d0bd      	beq.n	118c <dir_next+0x18>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
    1210:	6830      	ldr	r0, [r6, #0]
    1212:	4b1f      	ldr	r3, [pc, #124]	; (1290 <dir_next+0x11c>)
    1214:	4798      	blx	r3
    1216:	0003      	movs	r3, r0
    1218:	2001      	movs	r0, #1
    121a:	2b00      	cmp	r3, #0
    121c:	d1b6      	bne.n	118c <dir_next+0x18>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
    121e:	6833      	ldr	r3, [r6, #0]
    1220:	001a      	movs	r2, r3
    1222:	3230      	adds	r2, #48	; 0x30
    1224:	218c      	movs	r1, #140	; 0x8c
    1226:	0089      	lsls	r1, r1, #2
    1228:	468c      	mov	ip, r1
    122a:	4463      	add	r3, ip
		*d++ = (BYTE)val;
    122c:	2100      	movs	r1, #0
    122e:	7011      	strb	r1, [r2, #0]
    1230:	3201      	adds	r2, #1
	while (cnt--)
    1232:	429a      	cmp	r2, r3
    1234:	d1fb      	bne.n	122e <dir_next+0xba>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
    1236:	6835      	ldr	r5, [r6, #0]
    1238:	4649      	mov	r1, r9
    123a:	0028      	movs	r0, r5
    123c:	4b15      	ldr	r3, [pc, #84]	; (1294 <dir_next+0x120>)
    123e:	4798      	blx	r3
    1240:	62e8      	str	r0, [r5, #44]	; 0x2c
						dp->fs->wflag = 1;
    1242:	2501      	movs	r5, #1
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    1244:	6833      	ldr	r3, [r6, #0]
    1246:	789a      	ldrb	r2, [r3, #2]
    1248:	4590      	cmp	r8, r2
    124a:	d20d      	bcs.n	1268 <dir_next+0xf4>
						dp->fs->wflag = 1;
    124c:	711d      	strb	r5, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    124e:	6830      	ldr	r0, [r6, #0]
    1250:	4b0f      	ldr	r3, [pc, #60]	; (1290 <dir_next+0x11c>)
    1252:	4798      	blx	r3
    1254:	2800      	cmp	r0, #0
    1256:	d115      	bne.n	1284 <dir_next+0x110>
						dp->fs->winsect++;
    1258:	6832      	ldr	r2, [r6, #0]
    125a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    125c:	3301      	adds	r3, #1
    125e:	62d3      	str	r3, [r2, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    1260:	2301      	movs	r3, #1
    1262:	469c      	mov	ip, r3
    1264:	44e0      	add	r8, ip
    1266:	e7ed      	b.n	1244 <dir_next+0xd0>
					dp->fs->winsect -= c;						/* Rewind window offset */
    1268:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    126a:	4641      	mov	r1, r8
    126c:	1a52      	subs	r2, r2, r1
    126e:	62da      	str	r2, [r3, #44]	; 0x2c
				dp->clust = clst;				/* Initialize data for new cluster */
    1270:	464b      	mov	r3, r9
    1272:	60f3      	str	r3, [r6, #12]
				dp->sect = clust2sect(dp->fs, clst);
    1274:	4649      	mov	r1, r9
    1276:	6830      	ldr	r0, [r6, #0]
    1278:	4b06      	ldr	r3, [pc, #24]	; (1294 <dir_next+0x120>)
    127a:	4798      	blx	r3
    127c:	6130      	str	r0, [r6, #16]
    127e:	e7a0      	b.n	11c2 <dir_next+0x4e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    1280:	2001      	movs	r0, #1
    1282:	e783      	b.n	118c <dir_next+0x18>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    1284:	2001      	movs	r0, #1
    1286:	e781      	b.n	118c <dir_next+0x18>
    1288:	00000db5 	.word	0x00000db5
    128c:	000010a9 	.word	0x000010a9
    1290:	00000745 	.word	0x00000745
    1294:	00000d9d 	.word	0x00000d9d

00001298 <follow_path>:
{
    1298:	b5f0      	push	{r4, r5, r6, r7, lr}
    129a:	46de      	mov	lr, fp
    129c:	4657      	mov	r7, sl
    129e:	464e      	mov	r6, r9
    12a0:	4645      	mov	r5, r8
    12a2:	b5e0      	push	{r5, r6, r7, lr}
    12a4:	b085      	sub	sp, #20
    12a6:	0004      	movs	r4, r0
    12a8:	000e      	movs	r6, r1
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
    12aa:	780b      	ldrb	r3, [r1, #0]
    12ac:	2b2f      	cmp	r3, #47	; 0x2f
    12ae:	d009      	beq.n	12c4 <follow_path+0x2c>
    12b0:	2b5c      	cmp	r3, #92	; 0x5c
    12b2:	d007      	beq.n	12c4 <follow_path+0x2c>
	dp->sclust = 0;							/* Always start from the root directory */
    12b4:	2300      	movs	r3, #0
    12b6:	60a3      	str	r3, [r4, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
    12b8:	7833      	ldrb	r3, [r6, #0]
    12ba:	2b1f      	cmp	r3, #31
    12bc:	d904      	bls.n	12c8 <follow_path+0x30>
		res = dir_next(dp, 0);		/* Next entry */
    12be:	4b95      	ldr	r3, [pc, #596]	; (1514 <follow_path+0x27c>)
    12c0:	469a      	mov	sl, r3
    12c2:	e009      	b.n	12d8 <follow_path+0x40>
		path++;
    12c4:	3601      	adds	r6, #1
    12c6:	e7f5      	b.n	12b4 <follow_path+0x1c>
		res = dir_sdi(dp, 0);
    12c8:	2100      	movs	r1, #0
    12ca:	0020      	movs	r0, r4
    12cc:	4b92      	ldr	r3, [pc, #584]	; (1518 <follow_path+0x280>)
    12ce:	4798      	blx	r3
		dp->dir = 0;
    12d0:	2300      	movs	r3, #0
    12d2:	6163      	str	r3, [r4, #20]
    12d4:	e10d      	b.n	14f2 <follow_path+0x25a>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    12d6:	3601      	adds	r6, #1
    12d8:	7833      	ldrb	r3, [r6, #0]
    12da:	2b2f      	cmp	r3, #47	; 0x2f
    12dc:	d0fb      	beq.n	12d6 <follow_path+0x3e>
    12de:	2b5c      	cmp	r3, #92	; 0x5c
    12e0:	d0f9      	beq.n	12d6 <follow_path+0x3e>
	sfn = dp->fn;
    12e2:	69a1      	ldr	r1, [r4, #24]
    12e4:	000b      	movs	r3, r1
    12e6:	0008      	movs	r0, r1
    12e8:	300b      	adds	r0, #11
		*d++ = (BYTE)val;
    12ea:	2220      	movs	r2, #32
    12ec:	701a      	strb	r2, [r3, #0]
    12ee:	3301      	adds	r3, #1
	while (cnt--)
    12f0:	4298      	cmp	r0, r3
    12f2:	d1fb      	bne.n	12ec <follow_path+0x54>
    12f4:	2000      	movs	r0, #0
    12f6:	2200      	movs	r2, #0
    12f8:	2508      	movs	r5, #8
    12fa:	2300      	movs	r3, #0
    12fc:	469c      	mov	ip, r3
					b |= 1; c -= 0x20;
    12fe:	2301      	movs	r3, #1
    1300:	4699      	mov	r9, r3
			b |= 3;						/* Eliminate NT flag */
    1302:	2303      	movs	r3, #3
    1304:	4698      	mov	r8, r3
    1306:	9101      	str	r1, [sp, #4]
    1308:	9402      	str	r4, [sp, #8]
		c = (BYTE)p[si++];
    130a:	1c57      	adds	r7, r2, #1
    130c:	5cb3      	ldrb	r3, [r6, r2]
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    130e:	2b20      	cmp	r3, #32
    1310:	d800      	bhi.n	1314 <follow_path+0x7c>
    1312:	e0e5      	b.n	14e0 <follow_path+0x248>
    1314:	2b2f      	cmp	r3, #47	; 0x2f
    1316:	d100      	bne.n	131a <follow_path+0x82>
    1318:	e0da      	b.n	14d0 <follow_path+0x238>
    131a:	2b5c      	cmp	r3, #92	; 0x5c
    131c:	d100      	bne.n	1320 <follow_path+0x88>
    131e:	e0d7      	b.n	14d0 <follow_path+0x238>
		if (c == '.' || i >= ni) {
    1320:	2b2e      	cmp	r3, #46	; 0x2e
    1322:	d100      	bne.n	1326 <follow_path+0x8e>
    1324:	e0ec      	b.n	1500 <follow_path+0x268>
    1326:	4285      	cmp	r5, r0
    1328:	d800      	bhi.n	132c <follow_path+0x94>
    132a:	e0c5      	b.n	14b8 <follow_path+0x220>
		if (c >= 0x80) {				/* Extended character? */
    132c:	b25c      	sxtb	r4, r3
    132e:	2c00      	cmp	r4, #0
    1330:	db27      	blt.n	1382 <follow_path+0xea>
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    1332:	247f      	movs	r4, #127	; 0x7f
    1334:	46a3      	mov	fp, r4
    1336:	449b      	add	fp, r3
    1338:	465c      	mov	r4, fp
    133a:	4669      	mov	r1, sp
    133c:	730c      	strb	r4, [r1, #12]
    133e:	b2e4      	uxtb	r4, r4
    1340:	2c1e      	cmp	r4, #30
    1342:	d907      	bls.n	1354 <follow_path+0xbc>
    1344:	2420      	movs	r4, #32
    1346:	46a3      	mov	fp, r4
    1348:	449b      	add	fp, r3
    134a:	465c      	mov	r4, fp
    134c:	730c      	strb	r4, [r1, #12]
    134e:	b2e4      	uxtb	r4, r4
    1350:	2c1c      	cmp	r4, #28
    1352:	d81f      	bhi.n	1394 <follow_path+0xfc>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    1354:	3202      	adds	r2, #2
    1356:	5df4      	ldrb	r4, [r6, r7]
    1358:	46a3      	mov	fp, r4
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    135a:	0027      	movs	r7, r4
    135c:	3f40      	subs	r7, #64	; 0x40
    135e:	2f3e      	cmp	r7, #62	; 0x3e
    1360:	d904      	bls.n	136c <follow_path+0xd4>
    1362:	3f40      	subs	r7, #64	; 0x40
    1364:	b2ff      	uxtb	r7, r7
    1366:	2f7c      	cmp	r7, #124	; 0x7c
    1368:	d900      	bls.n	136c <follow_path+0xd4>
    136a:	e0a7      	b.n	14bc <follow_path+0x224>
    136c:	1e6f      	subs	r7, r5, #1
    136e:	42b8      	cmp	r0, r7
    1370:	d300      	bcc.n	1374 <follow_path+0xdc>
    1372:	e0a5      	b.n	14c0 <follow_path+0x228>
			sfn[i++] = c;
    1374:	1c47      	adds	r7, r0, #1
    1376:	9901      	ldr	r1, [sp, #4]
    1378:	540b      	strb	r3, [r1, r0]
			sfn[i++] = d;
    137a:	465b      	mov	r3, fp
    137c:	55cb      	strb	r3, [r1, r7]
    137e:	3002      	adds	r0, #2
    1380:	e7c3      	b.n	130a <follow_path+0x72>
			b |= 3;						/* Eliminate NT flag */
    1382:	4664      	mov	r4, ip
    1384:	4641      	mov	r1, r8
    1386:	430c      	orrs	r4, r1
    1388:	1c21      	adds	r1, r4, #0
    138a:	466c      	mov	r4, sp
    138c:	7321      	strb	r1, [r4, #12]
    138e:	7b21      	ldrb	r1, [r4, #12]
    1390:	468c      	mov	ip, r1
    1392:	e7ce      	b.n	1332 <follow_path+0x9a>
	while (*str && *str != chr) str++;
    1394:	2b22      	cmp	r3, #34	; 0x22
    1396:	d021      	beq.n	13dc <follow_path+0x144>
    1398:	222a      	movs	r2, #42	; 0x2a
    139a:	4693      	mov	fp, r2
    139c:	4a5f      	ldr	r2, [pc, #380]	; (151c <follow_path+0x284>)
    139e:	4659      	mov	r1, fp
    13a0:	9103      	str	r1, [sp, #12]
    13a2:	9901      	ldr	r1, [sp, #4]
    13a4:	468b      	mov	fp, r1
    13a6:	0019      	movs	r1, r3
    13a8:	9c02      	ldr	r4, [sp, #8]
    13aa:	232a      	movs	r3, #42	; 0x2a
    13ac:	4299      	cmp	r1, r3
    13ae:	d017      	beq.n	13e0 <follow_path+0x148>
    13b0:	3201      	adds	r2, #1
    13b2:	7813      	ldrb	r3, [r2, #0]
    13b4:	2b00      	cmp	r3, #0
    13b6:	d1f9      	bne.n	13ac <follow_path+0x114>
    13b8:	000b      	movs	r3, r1
    13ba:	465a      	mov	r2, fp
    13bc:	9201      	str	r2, [sp, #4]
    13be:	9402      	str	r4, [sp, #8]
			if (IsUpper(c)) {			/* ASCII large capital? */
    13c0:	000a      	movs	r2, r1
    13c2:	3a41      	subs	r2, #65	; 0x41
    13c4:	2a19      	cmp	r2, #25
    13c6:	d810      	bhi.n	13ea <follow_path+0x152>
				b |= 2;
    13c8:	4662      	mov	r2, ip
    13ca:	2102      	movs	r1, #2
    13cc:	430a      	orrs	r2, r1
    13ce:	b2d2      	uxtb	r2, r2
    13d0:	4694      	mov	ip, r2
			sfn[i++] = c;
    13d2:	9a01      	ldr	r2, [sp, #4]
    13d4:	5413      	strb	r3, [r2, r0]
    13d6:	3001      	adds	r0, #1
		c = (BYTE)p[si++];
    13d8:	003a      	movs	r2, r7
    13da:	e796      	b.n	130a <follow_path+0x72>
				return FR_INVALID_NAME;
    13dc:	2006      	movs	r0, #6
    13de:	e088      	b.n	14f2 <follow_path+0x25a>
    13e0:	1e0b      	subs	r3, r1, #0
    13e2:	465a      	mov	r2, fp
    13e4:	9201      	str	r2, [sp, #4]
    13e6:	9402      	str	r4, [sp, #8]
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    13e8:	d16c      	bne.n	14c4 <follow_path+0x22c>
				if (IsLower(c)) {		/* ASCII small capital? */
    13ea:	001a      	movs	r2, r3
    13ec:	3a61      	subs	r2, #97	; 0x61
    13ee:	2a19      	cmp	r2, #25
    13f0:	d8ef      	bhi.n	13d2 <follow_path+0x13a>
					b |= 1; c -= 0x20;
    13f2:	4662      	mov	r2, ip
    13f4:	4649      	mov	r1, r9
    13f6:	430a      	orrs	r2, r1
    13f8:	b2d2      	uxtb	r2, r2
    13fa:	4694      	mov	ip, r2
    13fc:	3b20      	subs	r3, #32
    13fe:	b2db      	uxtb	r3, r3
    1400:	e7e7      	b.n	13d2 <follow_path+0x13a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    1402:	780a      	ldrb	r2, [r1, #0]
    1404:	2ae5      	cmp	r2, #229	; 0xe5
    1406:	d018      	beq.n	143a <follow_path+0x1a2>
	if (ni == 8) b <<= 2;
    1408:	2d08      	cmp	r5, #8
    140a:	d019      	beq.n	1440 <follow_path+0x1a8>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    140c:	2203      	movs	r2, #3
    140e:	4660      	mov	r0, ip
    1410:	4002      	ands	r2, r0
    1412:	2a01      	cmp	r2, #1
    1414:	d019      	beq.n	144a <follow_path+0x1b2>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    1416:	220c      	movs	r2, #12
    1418:	4660      	mov	r0, ip
    141a:	4002      	ands	r2, r0
    141c:	2a04      	cmp	r2, #4
    141e:	d017      	beq.n	1450 <follow_path+0x1b8>
	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
    1420:	72cb      	strb	r3, [r1, #11]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
    1422:	2100      	movs	r1, #0
    1424:	0020      	movs	r0, r4
    1426:	4b3c      	ldr	r3, [pc, #240]	; (1518 <follow_path+0x280>)
    1428:	4798      	blx	r3
	if (res != FR_OK) return res;
    142a:	2800      	cmp	r0, #0
    142c:	d15d      	bne.n	14ea <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    142e:	4b3c      	ldr	r3, [pc, #240]	; (1520 <follow_path+0x288>)
    1430:	469b      	mov	fp, r3
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    1432:	2308      	movs	r3, #8
    1434:	4698      	mov	r8, r3
    1436:	46b1      	mov	r9, r6
    1438:	e012      	b.n	1460 <follow_path+0x1c8>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    143a:	3ae0      	subs	r2, #224	; 0xe0
    143c:	700a      	strb	r2, [r1, #0]
    143e:	e7e3      	b.n	1408 <follow_path+0x170>
	if (ni == 8) b <<= 2;
    1440:	4662      	mov	r2, ip
    1442:	0092      	lsls	r2, r2, #2
    1444:	b2d2      	uxtb	r2, r2
    1446:	4694      	mov	ip, r2
    1448:	e7e0      	b.n	140c <follow_path+0x174>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    144a:	320f      	adds	r2, #15
    144c:	4313      	orrs	r3, r2
    144e:	e7e2      	b.n	1416 <follow_path+0x17e>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    1450:	3204      	adds	r2, #4
    1452:	4313      	orrs	r3, r2
    1454:	e7e4      	b.n	1420 <follow_path+0x188>
		res = dir_next(dp, 0);		/* Next entry */
    1456:	2100      	movs	r1, #0
    1458:	0020      	movs	r0, r4
    145a:	47d0      	blx	sl
	} while (res == FR_OK);
    145c:	2800      	cmp	r0, #0
    145e:	d144      	bne.n	14ea <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    1460:	6921      	ldr	r1, [r4, #16]
    1462:	6820      	ldr	r0, [r4, #0]
    1464:	47d8      	blx	fp
		if (res != FR_OK) break;
    1466:	2800      	cmp	r0, #0
    1468:	d13f      	bne.n	14ea <follow_path+0x252>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
    146a:	6961      	ldr	r1, [r4, #20]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    146c:	780b      	ldrb	r3, [r1, #0]
    146e:	2b00      	cmp	r3, #0
    1470:	d01a      	beq.n	14a8 <follow_path+0x210>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    1472:	7ace      	ldrb	r6, [r1, #11]
    1474:	4643      	mov	r3, r8
    1476:	4233      	tst	r3, r6
    1478:	d1ed      	bne.n	1456 <follow_path+0x1be>
    147a:	69a7      	ldr	r7, [r4, #24]
    147c:	2300      	movs	r3, #0
	while (cnt-- && (r = *d++ - *s++) == 0) ;
    147e:	5ccd      	ldrb	r5, [r1, r3]
    1480:	5cfa      	ldrb	r2, [r7, r3]
    1482:	4295      	cmp	r5, r2
    1484:	d1e7      	bne.n	1456 <follow_path+0x1be>
    1486:	3301      	adds	r3, #1
    1488:	2b0b      	cmp	r3, #11
    148a:	d1f8      	bne.n	147e <follow_path+0x1e6>
    148c:	464b      	mov	r3, r9
    148e:	46b1      	mov	r9, r6
    1490:	001e      	movs	r6, r3
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
    1492:	7afb      	ldrb	r3, [r7, #11]
    1494:	075b      	lsls	r3, r3, #29
    1496:	d42c      	bmi.n	14f2 <follow_path+0x25a>
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
    1498:	464b      	mov	r3, r9
    149a:	06db      	lsls	r3, r3, #27
    149c:	d514      	bpl.n	14c8 <follow_path+0x230>
			dp->sclust = ld_clust(dp->fs, dir);
    149e:	6820      	ldr	r0, [r4, #0]
    14a0:	4b20      	ldr	r3, [pc, #128]	; (1524 <follow_path+0x28c>)
    14a2:	4798      	blx	r3
    14a4:	60a0      	str	r0, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
    14a6:	e717      	b.n	12d8 <follow_path+0x40>
			ns = dp->fn[NSFLAG];
    14a8:	69a3      	ldr	r3, [r4, #24]
    14aa:	7adb      	ldrb	r3, [r3, #11]
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
    14ac:	2004      	movs	r0, #4
    14ae:	4003      	ands	r3, r0
    14b0:	4258      	negs	r0, r3
    14b2:	4158      	adcs	r0, r3
    14b4:	3004      	adds	r0, #4
    14b6:	e01c      	b.n	14f2 <follow_path+0x25a>
		if (c == '.' || i >= ni) {
    14b8:	2006      	movs	r0, #6
    14ba:	e01a      	b.n	14f2 <follow_path+0x25a>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    14bc:	2006      	movs	r0, #6
    14be:	e018      	b.n	14f2 <follow_path+0x25a>
    14c0:	2006      	movs	r0, #6
    14c2:	e016      	b.n	14f2 <follow_path+0x25a>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    14c4:	2006      	movs	r0, #6
    14c6:	e014      	b.n	14f2 <follow_path+0x25a>
				res = FR_NO_PATH; break;
    14c8:	2005      	movs	r0, #5
    14ca:	e012      	b.n	14f2 <follow_path+0x25a>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    14cc:	2006      	movs	r0, #6
    14ce:	e010      	b.n	14f2 <follow_path+0x25a>
    14d0:	9901      	ldr	r1, [sp, #4]
    14d2:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    14d4:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    14d6:	2300      	movs	r3, #0
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    14d8:	2800      	cmp	r0, #0
    14da:	d192      	bne.n	1402 <follow_path+0x16a>
    14dc:	2006      	movs	r0, #6
    14de:	e008      	b.n	14f2 <follow_path+0x25a>
    14e0:	9901      	ldr	r1, [sp, #4]
    14e2:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    14e4:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    14e6:	2304      	movs	r3, #4
    14e8:	e7f6      	b.n	14d8 <follow_path+0x240>
			ns = dp->fn[NSFLAG];
    14ea:	69a3      	ldr	r3, [r4, #24]
    14ec:	7adb      	ldrb	r3, [r3, #11]
				if (res == FR_NO_FILE) {	/* Object is not found */
    14ee:	2804      	cmp	r0, #4
    14f0:	d0dc      	beq.n	14ac <follow_path+0x214>
}
    14f2:	b005      	add	sp, #20
    14f4:	bc3c      	pop	{r2, r3, r4, r5}
    14f6:	4690      	mov	r8, r2
    14f8:	4699      	mov	r9, r3
    14fa:	46a2      	mov	sl, r4
    14fc:	46ab      	mov	fp, r5
    14fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    1500:	2d08      	cmp	r5, #8
    1502:	d1e3      	bne.n	14cc <follow_path+0x234>
			b <<= 2; continue;
    1504:	4663      	mov	r3, ip
    1506:	009b      	lsls	r3, r3, #2
    1508:	b2db      	uxtb	r3, r3
    150a:	469c      	mov	ip, r3
			i = 8; ni = 11;
    150c:	0028      	movs	r0, r5
		c = (BYTE)p[si++];
    150e:	003a      	movs	r2, r7
			i = 8; ni = 11;
    1510:	250b      	movs	r5, #11
    1512:	e6fa      	b.n	130a <follow_path+0x72>
    1514:	00001175 	.word	0x00001175
    1518:	00000ead 	.word	0x00000ead
    151c:	00002ba1 	.word	0x00002ba1
    1520:	000007b1 	.word	0x000007b1
    1524:	000006cd 	.word	0x000006cd

00001528 <dir_register>:
{
    1528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    152a:	0005      	movs	r5, r0
	res = dir_sdi(dp, 0);
    152c:	2100      	movs	r1, #0
    152e:	4b1b      	ldr	r3, [pc, #108]	; (159c <dir_register+0x74>)
    1530:	4798      	blx	r3
    1532:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
    1534:	d12b      	bne.n	158e <dir_register+0x66>
			res = move_window(dp->fs, dp->sect);
    1536:	4e1a      	ldr	r6, [pc, #104]	; (15a0 <dir_register+0x78>)
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
    1538:	4f1a      	ldr	r7, [pc, #104]	; (15a4 <dir_register+0x7c>)
    153a:	e004      	b.n	1546 <dir_register+0x1e>
    153c:	2101      	movs	r1, #1
    153e:	0028      	movs	r0, r5
    1540:	47b8      	blx	r7
    1542:	1e04      	subs	r4, r0, #0
		} while (res == FR_OK);
    1544:	d127      	bne.n	1596 <dir_register+0x6e>
			res = move_window(dp->fs, dp->sect);
    1546:	6929      	ldr	r1, [r5, #16]
    1548:	6828      	ldr	r0, [r5, #0]
    154a:	47b0      	blx	r6
    154c:	1e04      	subs	r4, r0, #0
			if (res != FR_OK) break;
    154e:	d122      	bne.n	1596 <dir_register+0x6e>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
    1550:	696b      	ldr	r3, [r5, #20]
    1552:	781b      	ldrb	r3, [r3, #0]
    1554:	2be5      	cmp	r3, #229	; 0xe5
    1556:	d001      	beq.n	155c <dir_register+0x34>
    1558:	2b00      	cmp	r3, #0
    155a:	d1ef      	bne.n	153c <dir_register+0x14>
		res = move_window(dp->fs, dp->sect);
    155c:	6929      	ldr	r1, [r5, #16]
    155e:	6828      	ldr	r0, [r5, #0]
    1560:	4b0f      	ldr	r3, [pc, #60]	; (15a0 <dir_register+0x78>)
    1562:	4798      	blx	r3
    1564:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
    1566:	d001      	beq.n	156c <dir_register+0x44>
}
    1568:	0020      	movs	r0, r4
    156a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
    156c:	696b      	ldr	r3, [r5, #20]
    156e:	0019      	movs	r1, r3
    1570:	3120      	adds	r1, #32
		*d++ = (BYTE)val;
    1572:	2200      	movs	r2, #0
    1574:	701a      	strb	r2, [r3, #0]
    1576:	3301      	adds	r3, #1
	while (cnt--)
    1578:	428b      	cmp	r3, r1
    157a:	d1fb      	bne.n	1574 <dir_register+0x4c>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
    157c:	220b      	movs	r2, #11
    157e:	69a9      	ldr	r1, [r5, #24]
    1580:	6968      	ldr	r0, [r5, #20]
    1582:	4b09      	ldr	r3, [pc, #36]	; (15a8 <dir_register+0x80>)
    1584:	4798      	blx	r3
			dp->fs->wflag = 1;
    1586:	682b      	ldr	r3, [r5, #0]
    1588:	2201      	movs	r2, #1
    158a:	711a      	strb	r2, [r3, #4]
    158c:	e7ec      	b.n	1568 <dir_register+0x40>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    158e:	2804      	cmp	r0, #4
    1590:	d1ea      	bne.n	1568 <dir_register+0x40>
    1592:	2407      	movs	r4, #7
    1594:	e7e8      	b.n	1568 <dir_register+0x40>
    1596:	2c04      	cmp	r4, #4
    1598:	d0fb      	beq.n	1592 <dir_register+0x6a>
    159a:	e7e5      	b.n	1568 <dir_register+0x40>
    159c:	00000ead 	.word	0x00000ead
    15a0:	000007b1 	.word	0x000007b1
    15a4:	00001175 	.word	0x00001175
    15a8:	000006b9 	.word	0x000006b9

000015ac <remove_chain>:
{
    15ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    15ae:	46ce      	mov	lr, r9
    15b0:	4647      	mov	r7, r8
    15b2:	b580      	push	{r7, lr}
    15b4:	0004      	movs	r4, r0
    15b6:	000d      	movs	r5, r1
		res = FR_INT_ERR;
    15b8:	2002      	movs	r0, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    15ba:	2901      	cmp	r1, #1
    15bc:	d902      	bls.n	15c4 <remove_chain+0x18>
    15be:	6963      	ldr	r3, [r4, #20]
    15c0:	4299      	cmp	r1, r3
    15c2:	d303      	bcc.n	15cc <remove_chain+0x20>
}
    15c4:	bc0c      	pop	{r2, r3}
    15c6:	4690      	mov	r8, r2
    15c8:	4699      	mov	r9, r3
    15ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			nxt = get_fat(fs, clst);			/* Get cluster status */
    15cc:	4f14      	ldr	r7, [pc, #80]	; (1620 <remove_chain+0x74>)
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    15ce:	4b15      	ldr	r3, [pc, #84]	; (1624 <remove_chain+0x78>)
    15d0:	4698      	mov	r8, r3
				fs->fsi_flag |= 1;
    15d2:	2301      	movs	r3, #1
    15d4:	4699      	mov	r9, r3
    15d6:	e003      	b.n	15e0 <remove_chain+0x34>
    15d8:	0035      	movs	r5, r6
		while (clst < fs->n_fatent) {			/* Not a last link? */
    15da:	6963      	ldr	r3, [r4, #20]
    15dc:	42b3      	cmp	r3, r6
    15de:	d9f1      	bls.n	15c4 <remove_chain+0x18>
			nxt = get_fat(fs, clst);			/* Get cluster status */
    15e0:	0029      	movs	r1, r5
    15e2:	0020      	movs	r0, r4
    15e4:	47b8      	blx	r7
    15e6:	1e06      	subs	r6, r0, #0
			if (nxt == 0) break;				/* Empty cluster? */
    15e8:	d013      	beq.n	1612 <remove_chain+0x66>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    15ea:	2801      	cmp	r0, #1
    15ec:	d013      	beq.n	1616 <remove_chain+0x6a>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    15ee:	1c43      	adds	r3, r0, #1
    15f0:	d013      	beq.n	161a <remove_chain+0x6e>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    15f2:	2200      	movs	r2, #0
    15f4:	0029      	movs	r1, r5
    15f6:	0020      	movs	r0, r4
    15f8:	47c0      	blx	r8
			if (res != FR_OK) break;
    15fa:	2800      	cmp	r0, #0
    15fc:	d1e2      	bne.n	15c4 <remove_chain+0x18>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
    15fe:	6923      	ldr	r3, [r4, #16]
    1600:	1c5a      	adds	r2, r3, #1
    1602:	d0e9      	beq.n	15d8 <remove_chain+0x2c>
				fs->free_clust++;
    1604:	3301      	adds	r3, #1
    1606:	6123      	str	r3, [r4, #16]
				fs->fsi_flag |= 1;
    1608:	7963      	ldrb	r3, [r4, #5]
    160a:	464a      	mov	r2, r9
    160c:	4313      	orrs	r3, r2
    160e:	7163      	strb	r3, [r4, #5]
    1610:	e7e2      	b.n	15d8 <remove_chain+0x2c>
    1612:	2000      	movs	r0, #0
    1614:	e7d6      	b.n	15c4 <remove_chain+0x18>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    1616:	2002      	movs	r0, #2
    1618:	e7d4      	b.n	15c4 <remove_chain+0x18>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    161a:	2001      	movs	r0, #1
    161c:	e7d2      	b.n	15c4 <remove_chain+0x18>
    161e:	46c0      	nop			; (mov r8, r8)
    1620:	00000db5 	.word	0x00000db5
    1624:	00000f5d 	.word	0x00000f5d

00001628 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    1628:	b510      	push	{r4, lr}
    162a:	b084      	sub	sp, #16
    162c:	9001      	str	r0, [sp, #4]
    162e:	9100      	str	r1, [sp, #0]
    1630:	0014      	movs	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
    1632:	9103      	str	r1, [sp, #12]


	vol = get_ldnumber(&rp);
    1634:	a803      	add	r0, sp, #12
    1636:	4b15      	ldr	r3, [pc, #84]	; (168c <f_mount+0x64>)
    1638:	4798      	blx	r3
	if (vol < 0) return FR_INVALID_DRIVE;
    163a:	230b      	movs	r3, #11
    163c:	2800      	cmp	r0, #0
    163e:	db14      	blt.n	166a <f_mount+0x42>
	cfs = FatFs[vol];					/* Pointer to fs object */
    1640:	0083      	lsls	r3, r0, #2
    1642:	4a13      	ldr	r2, [pc, #76]	; (1690 <f_mount+0x68>)
    1644:	589b      	ldr	r3, [r3, r2]

	if (cfs) {
    1646:	2b00      	cmp	r3, #0
    1648:	d001      	beq.n	164e <f_mount+0x26>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
    164a:	2200      	movs	r2, #0
    164c:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
    164e:	9b01      	ldr	r3, [sp, #4]
    1650:	2b00      	cmp	r3, #0
    1652:	d014      	beq.n	167e <f_mount+0x56>
		fs->fs_type = 0;				/* Clear new fs object */
    1654:	2200      	movs	r2, #0
    1656:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
    1658:	9a01      	ldr	r2, [sp, #4]
    165a:	0080      	lsls	r0, r0, #2
    165c:	4b0c      	ldr	r3, [pc, #48]	; (1690 <f_mount+0x68>)
    165e:	50c2      	str	r2, [r0, r3]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    1660:	2300      	movs	r3, #0
    1662:	2a00      	cmp	r2, #0
    1664:	d001      	beq.n	166a <f_mount+0x42>
    1666:	2c01      	cmp	r4, #1
    1668:	d002      	beq.n	1670 <f_mount+0x48>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
    166a:	0018      	movs	r0, r3
    166c:	b004      	add	sp, #16
    166e:	bd10      	pop	{r4, pc}
	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
    1670:	2200      	movs	r2, #0
    1672:	4669      	mov	r1, sp
    1674:	a801      	add	r0, sp, #4
    1676:	4b07      	ldr	r3, [pc, #28]	; (1694 <f_mount+0x6c>)
    1678:	4798      	blx	r3
    167a:	0003      	movs	r3, r0
	LEAVE_FF(fs, res);
    167c:	e7f5      	b.n	166a <f_mount+0x42>
	FatFs[vol] = fs;					/* Register new fs object */
    167e:	0080      	lsls	r0, r0, #2
    1680:	2200      	movs	r2, #0
    1682:	4b03      	ldr	r3, [pc, #12]	; (1690 <f_mount+0x68>)
    1684:	50c2      	str	r2, [r0, r3]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    1686:	2300      	movs	r3, #0
    1688:	e7ef      	b.n	166a <f_mount+0x42>
    168a:	46c0      	nop			; (mov r8, r8)
    168c:	000006ef 	.word	0x000006ef
    1690:	20000458 	.word	0x20000458
    1694:	000008cd 	.word	0x000008cd

00001698 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    1698:	b5f0      	push	{r4, r5, r6, r7, lr}
    169a:	46d6      	mov	lr, sl
    169c:	464f      	mov	r7, r9
    169e:	4646      	mov	r6, r8
    16a0:	b5c0      	push	{r6, r7, lr}
    16a2:	b08c      	sub	sp, #48	; 0x30
    16a4:	0005      	movs	r5, r0
    16a6:	9101      	str	r1, [sp, #4]
    16a8:	0016      	movs	r6, r2
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
    16aa:	2409      	movs	r4, #9
    16ac:	2800      	cmp	r0, #0
    16ae:	d009      	beq.n	16c4 <f_open+0x2c>
	fp->fs = 0;			/* Clear file object */
    16b0:	2300      	movs	r3, #0
    16b2:	6003      	str	r3, [r0, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
    16b4:	221e      	movs	r2, #30
    16b6:	4032      	ands	r2, r6
    16b8:	a901      	add	r1, sp, #4
    16ba:	a805      	add	r0, sp, #20
    16bc:	4b57      	ldr	r3, [pc, #348]	; (181c <f_open+0x184>)
    16be:	4798      	blx	r3
    16c0:	1e04      	subs	r4, r0, #0
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
    16c2:	d006      	beq.n	16d2 <f_open+0x3a>
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
    16c4:	0020      	movs	r0, r4
    16c6:	b00c      	add	sp, #48	; 0x30
    16c8:	bc1c      	pop	{r2, r3, r4}
    16ca:	4690      	mov	r8, r2
    16cc:	4699      	mov	r9, r3
    16ce:	46a2      	mov	sl, r4
    16d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    16d2:	231f      	movs	r3, #31
    16d4:	4033      	ands	r3, r6
    16d6:	4698      	mov	r8, r3
		INIT_BUF(dj);
    16d8:	ab02      	add	r3, sp, #8
    16da:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
    16dc:	9901      	ldr	r1, [sp, #4]
    16de:	a805      	add	r0, sp, #20
    16e0:	4b4f      	ldr	r3, [pc, #316]	; (1820 <f_open+0x188>)
    16e2:	4798      	blx	r3
		dir = dj.dir;
    16e4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    16e6:	2800      	cmp	r0, #0
    16e8:	d135      	bne.n	1756 <f_open+0xbe>
			if (!dir)	/* Default directory itself */
    16ea:	2f00      	cmp	r7, #0
    16ec:	d100      	bne.n	16f0 <f_open+0x58>
    16ee:	e088      	b.n	1802 <f_open+0x16a>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    16f0:	231c      	movs	r3, #28
    16f2:	4233      	tst	r3, r6
    16f4:	d149      	bne.n	178a <f_open+0xf2>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
    16f6:	7afb      	ldrb	r3, [r7, #11]
    16f8:	06da      	lsls	r2, r3, #27
    16fa:	d500      	bpl.n	16fe <f_open+0x66>
    16fc:	e08c      	b.n	1818 <f_open+0x180>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    16fe:	07b2      	lsls	r2, r6, #30
    1700:	d502      	bpl.n	1708 <f_open+0x70>
    1702:	07db      	lsls	r3, r3, #31
    1704:	d500      	bpl.n	1708 <f_open+0x70>
    1706:	e085      	b.n	1814 <f_open+0x17c>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
    1708:	0733      	lsls	r3, r6, #28
    170a:	d503      	bpl.n	1714 <f_open+0x7c>
				mode |= FA__WRITTEN;
    170c:	2320      	movs	r3, #32
    170e:	4642      	mov	r2, r8
    1710:	431a      	orrs	r2, r3
    1712:	4690      	mov	r8, r2
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    1714:	9b05      	ldr	r3, [sp, #20]
    1716:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1718:	61eb      	str	r3, [r5, #28]
			fp->dir_ptr = dir;
    171a:	622f      	str	r7, [r5, #32]
			fp->flag = mode;					/* File access mode */
    171c:	4643      	mov	r3, r8
    171e:	71ab      	strb	r3, [r5, #6]
			fp->err = 0;						/* Clear error flag */
    1720:	2300      	movs	r3, #0
    1722:	4698      	mov	r8, r3
    1724:	71eb      	strb	r3, [r5, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    1726:	9e05      	ldr	r6, [sp, #20]
    1728:	0039      	movs	r1, r7
    172a:	0030      	movs	r0, r6
    172c:	4b3d      	ldr	r3, [pc, #244]	; (1824 <f_open+0x18c>)
    172e:	4798      	blx	r3
    1730:	6128      	str	r0, [r5, #16]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
    1732:	7ffb      	ldrb	r3, [r7, #31]
    1734:	061b      	lsls	r3, r3, #24
    1736:	7fba      	ldrb	r2, [r7, #30]
    1738:	0412      	lsls	r2, r2, #16
    173a:	4313      	orrs	r3, r2
    173c:	7f3a      	ldrb	r2, [r7, #28]
    173e:	4313      	orrs	r3, r2
    1740:	7f7a      	ldrb	r2, [r7, #29]
    1742:	0212      	lsls	r2, r2, #8
    1744:	4313      	orrs	r3, r2
    1746:	60eb      	str	r3, [r5, #12]
			fp->fptr = 0;						/* File pointer */
    1748:	4643      	mov	r3, r8
    174a:	60ab      	str	r3, [r5, #8]
			fp->dsect = 0;
    174c:	61ab      	str	r3, [r5, #24]
			fp->fs = dj.fs;	 					/* Validate file object */
    174e:	602e      	str	r6, [r5, #0]
			fp->id = fp->fs->id;
    1750:	88f3      	ldrh	r3, [r6, #6]
    1752:	80ab      	strh	r3, [r5, #4]
    1754:	e7b6      	b.n	16c4 <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1756:	231c      	movs	r3, #28
    1758:	4233      	tst	r3, r6
    175a:	d006      	beq.n	176a <f_open+0xd2>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    175c:	2804      	cmp	r0, #4
    175e:	d008      	beq.n	1772 <f_open+0xda>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    1760:	2308      	movs	r3, #8
    1762:	4642      	mov	r2, r8
    1764:	431a      	orrs	r2, r3
    1766:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    1768:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    176a:	2800      	cmp	r0, #0
    176c:	d0d6      	beq.n	171c <f_open+0x84>
    176e:	0004      	movs	r4, r0
    1770:	e7a8      	b.n	16c4 <f_open+0x2c>
					res = dir_register(&dj);
    1772:	a805      	add	r0, sp, #20
    1774:	4b2c      	ldr	r3, [pc, #176]	; (1828 <f_open+0x190>)
    1776:	4798      	blx	r3
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    1778:	2308      	movs	r3, #8
    177a:	4642      	mov	r2, r8
    177c:	431a      	orrs	r2, r3
    177e:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    1780:	9f0a      	ldr	r7, [sp, #40]	; 0x28
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    1782:	2800      	cmp	r0, #0
    1784:	d007      	beq.n	1796 <f_open+0xfe>
					res = dir_register(&dj);
    1786:	0004      	movs	r4, r0
    1788:	e79c      	b.n	16c4 <f_open+0x2c>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    178a:	7afb      	ldrb	r3, [r7, #11]
    178c:	2211      	movs	r2, #17
    178e:	421a      	tst	r2, r3
    1790:	d13c      	bne.n	180c <f_open+0x174>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    1792:	0773      	lsls	r3, r6, #29
    1794:	d43c      	bmi.n	1810 <f_open+0x178>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    1796:	4643      	mov	r3, r8
    1798:	071b      	lsls	r3, r3, #28
    179a:	d5bb      	bpl.n	1714 <f_open+0x7c>
				dw = GET_FATTIME();				/* Created time */
    179c:	4b23      	ldr	r3, [pc, #140]	; (182c <f_open+0x194>)
    179e:	4798      	blx	r3
				ST_DWORD(dir + DIR_CrtTime, dw);
    17a0:	73b8      	strb	r0, [r7, #14]
    17a2:	0a03      	lsrs	r3, r0, #8
    17a4:	73fb      	strb	r3, [r7, #15]
    17a6:	0c03      	lsrs	r3, r0, #16
    17a8:	743b      	strb	r3, [r7, #16]
    17aa:	0e00      	lsrs	r0, r0, #24
    17ac:	7478      	strb	r0, [r7, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
    17ae:	2600      	movs	r6, #0
    17b0:	72fe      	strb	r6, [r7, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
    17b2:	773e      	strb	r6, [r7, #28]
    17b4:	777e      	strb	r6, [r7, #29]
    17b6:	77be      	strb	r6, [r7, #30]
    17b8:	77fe      	strb	r6, [r7, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
    17ba:	9b05      	ldr	r3, [sp, #20]
    17bc:	4699      	mov	r9, r3
    17be:	0039      	movs	r1, r7
    17c0:	0018      	movs	r0, r3
    17c2:	4b18      	ldr	r3, [pc, #96]	; (1824 <f_open+0x18c>)
    17c4:	4798      	blx	r3
    17c6:	4682      	mov	sl, r0
	ST_WORD(dir + DIR_FstClusLO, cl);
    17c8:	76be      	strb	r6, [r7, #26]
    17ca:	76fe      	strb	r6, [r7, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    17cc:	753e      	strb	r6, [r7, #20]
    17ce:	757e      	strb	r6, [r7, #21]
				dj.fs->wflag = 1;
    17d0:	2301      	movs	r3, #1
    17d2:	464a      	mov	r2, r9
    17d4:	7113      	strb	r3, [r2, #4]
				if (cl) {						/* Remove the cluster chain if exist */
    17d6:	2800      	cmp	r0, #0
    17d8:	d098      	beq.n	170c <f_open+0x74>
					dw = dj.fs->winsect;
    17da:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
					res = remove_chain(dj.fs, cl);
    17dc:	0001      	movs	r1, r0
    17de:	4648      	mov	r0, r9
    17e0:	4b13      	ldr	r3, [pc, #76]	; (1830 <f_open+0x198>)
    17e2:	4798      	blx	r3
					if (res == FR_OK) {
    17e4:	2800      	cmp	r0, #0
    17e6:	d001      	beq.n	17ec <f_open+0x154>
					res = remove_chain(dj.fs, cl);
    17e8:	0004      	movs	r4, r0
    17ea:	e76b      	b.n	16c4 <f_open+0x2c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    17ec:	9805      	ldr	r0, [sp, #20]
    17ee:	4653      	mov	r3, sl
    17f0:	3b01      	subs	r3, #1
    17f2:	60c3      	str	r3, [r0, #12]
						res = move_window(dj.fs, dw);
    17f4:	0031      	movs	r1, r6
    17f6:	4b0f      	ldr	r3, [pc, #60]	; (1834 <f_open+0x19c>)
    17f8:	4798      	blx	r3
		if (res == FR_OK) {
    17fa:	2800      	cmp	r0, #0
    17fc:	d086      	beq.n	170c <f_open+0x74>
						res = move_window(dj.fs, dw);
    17fe:	0004      	movs	r4, r0
    1800:	e760      	b.n	16c4 <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1802:	231c      	movs	r3, #28
				res = FR_INVALID_NAME;
    1804:	2006      	movs	r0, #6
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1806:	4233      	tst	r3, r6
    1808:	d1aa      	bne.n	1760 <f_open+0xc8>
    180a:	e7ae      	b.n	176a <f_open+0xd2>
					res = FR_DENIED;
    180c:	2407      	movs	r4, #7
    180e:	e759      	b.n	16c4 <f_open+0x2c>
						res = FR_EXIST;
    1810:	2408      	movs	r4, #8
    1812:	e757      	b.n	16c4 <f_open+0x2c>
						res = FR_DENIED;
    1814:	2407      	movs	r4, #7
    1816:	e755      	b.n	16c4 <f_open+0x2c>
					res = FR_NO_FILE;
    1818:	2404      	movs	r4, #4
    181a:	e753      	b.n	16c4 <f_open+0x2c>
    181c:	000008cd 	.word	0x000008cd
    1820:	00001299 	.word	0x00001299
    1824:	000006cd 	.word	0x000006cd
    1828:	00001529 	.word	0x00001529
    182c:	000006b5 	.word	0x000006b5
    1830:	000015ad 	.word	0x000015ad
    1834:	000007b1 	.word	0x000007b1

00001838 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
    1838:	b5f0      	push	{r4, r5, r6, r7, lr}
    183a:	46de      	mov	lr, fp
    183c:	4657      	mov	r7, sl
    183e:	464e      	mov	r6, r9
    1840:	4645      	mov	r5, r8
    1842:	b5e0      	push	{r5, r6, r7, lr}
    1844:	b083      	sub	sp, #12
    1846:	0004      	movs	r4, r0
    1848:	000e      	movs	r6, r1
    184a:	0015      	movs	r5, r2
    184c:	4699      	mov	r9, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    184e:	2300      	movs	r3, #0
    1850:	464a      	mov	r2, r9
    1852:	6013      	str	r3, [r2, #0]

	res = validate(fp);							/* Check validity */
    1854:	4b5d      	ldr	r3, [pc, #372]	; (19cc <f_read+0x194>)
    1856:	4798      	blx	r3
    1858:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    185a:	2800      	cmp	r0, #0
    185c:	d108      	bne.n	1870 <f_read+0x38>
	if (fp->err)								/* Check error */
    185e:	79e3      	ldrb	r3, [r4, #7]
    1860:	2b00      	cmp	r3, #0
    1862:	d000      	beq.n	1866 <f_read+0x2e>
    1864:	e0af      	b.n	19c6 <f_read+0x18e>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    1866:	79a3      	ldrb	r3, [r4, #6]
    1868:	07db      	lsls	r3, r3, #31
    186a:	d409      	bmi.n	1880 <f_read+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    186c:	2307      	movs	r3, #7
    186e:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    1870:	9801      	ldr	r0, [sp, #4]
    1872:	b003      	add	sp, #12
    1874:	bc3c      	pop	{r2, r3, r4, r5}
    1876:	4690      	mov	r8, r2
    1878:	4699      	mov	r9, r3
    187a:	46a2      	mov	sl, r4
    187c:	46ab      	mov	fp, r5
    187e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	remain = fp->fsize - fp->fptr;
    1880:	68e3      	ldr	r3, [r4, #12]
    1882:	68a2      	ldr	r2, [r4, #8]
    1884:	1a9f      	subs	r7, r3, r2
    1886:	42af      	cmp	r7, r5
    1888:	d900      	bls.n	188c <f_read+0x54>
    188a:	002f      	movs	r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    188c:	2f00      	cmp	r7, #0
    188e:	d156      	bne.n	193e <f_read+0x106>
    1890:	e7ee      	b.n	1870 <f_read+0x38>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    1892:	6961      	ldr	r1, [r4, #20]
    1894:	4b4e      	ldr	r3, [pc, #312]	; (19d0 <f_read+0x198>)
    1896:	4798      	blx	r3
    1898:	e05f      	b.n	195a <f_read+0x122>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    189a:	2302      	movs	r3, #2
    189c:	71e3      	strb	r3, [r4, #7]
    189e:	9301      	str	r3, [sp, #4]
    18a0:	e7e6      	b.n	1870 <f_read+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    18a2:	2301      	movs	r3, #1
    18a4:	71e3      	strb	r3, [r4, #7]
    18a6:	9301      	str	r3, [sp, #4]
    18a8:	e7e2      	b.n	1870 <f_read+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    18aa:	2302      	movs	r3, #2
    18ac:	71e3      	strb	r3, [r4, #7]
    18ae:	9301      	str	r3, [sp, #4]
    18b0:	e7de      	b.n	1870 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    18b2:	2301      	movs	r3, #1
    18b4:	71e3      	strb	r3, [r4, #7]
    18b6:	9301      	str	r3, [sp, #4]
    18b8:	e7da      	b.n	1870 <f_read+0x38>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    18ba:	0021      	movs	r1, r4
    18bc:	3124      	adds	r1, #36	; 0x24
    18be:	0240      	lsls	r0, r0, #9
    18c0:	1830      	adds	r0, r6, r0
    18c2:	2280      	movs	r2, #128	; 0x80
    18c4:	0092      	lsls	r2, r2, #2
    18c6:	4b43      	ldr	r3, [pc, #268]	; (19d4 <f_read+0x19c>)
    18c8:	4798      	blx	r3
    18ca:	e071      	b.n	19b0 <f_read+0x178>
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    18cc:	69a2      	ldr	r2, [r4, #24]
    18ce:	4593      	cmp	fp, r2
    18d0:	d019      	beq.n	1906 <f_read+0xce>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    18d2:	79a3      	ldrb	r3, [r4, #6]
    18d4:	065b      	lsls	r3, r3, #25
    18d6:	d50c      	bpl.n	18f2 <f_read+0xba>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    18d8:	0021      	movs	r1, r4
    18da:	3124      	adds	r1, #36	; 0x24
    18dc:	4653      	mov	r3, sl
    18de:	7858      	ldrb	r0, [r3, #1]
    18e0:	2301      	movs	r3, #1
    18e2:	4d3d      	ldr	r5, [pc, #244]	; (19d8 <f_read+0x1a0>)
    18e4:	47a8      	blx	r5
    18e6:	2800      	cmp	r0, #0
    18e8:	d165      	bne.n	19b6 <f_read+0x17e>
					fp->flag &= ~FA__DIRTY;
    18ea:	79a3      	ldrb	r3, [r4, #6]
    18ec:	2240      	movs	r2, #64	; 0x40
    18ee:	4393      	bics	r3, r2
    18f0:	71a3      	strb	r3, [r4, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    18f2:	0021      	movs	r1, r4
    18f4:	3124      	adds	r1, #36	; 0x24
    18f6:	6823      	ldr	r3, [r4, #0]
    18f8:	7858      	ldrb	r0, [r3, #1]
    18fa:	2301      	movs	r3, #1
    18fc:	465a      	mov	r2, fp
    18fe:	4d37      	ldr	r5, [pc, #220]	; (19dc <f_read+0x1a4>)
    1900:	47a8      	blx	r5
    1902:	2800      	cmp	r0, #0
    1904:	d15b      	bne.n	19be <f_read+0x186>
			fp->dsect = sect;
    1906:	465b      	mov	r3, fp
    1908:	61a3      	str	r3, [r4, #24]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    190a:	68a3      	ldr	r3, [r4, #8]
    190c:	05d9      	lsls	r1, r3, #23
    190e:	0dc9      	lsrs	r1, r1, #23
    1910:	2580      	movs	r5, #128	; 0x80
    1912:	00ad      	lsls	r5, r5, #2
    1914:	1a6d      	subs	r5, r5, r1
    1916:	42bd      	cmp	r5, r7
    1918:	d900      	bls.n	191c <f_read+0xe4>
    191a:	003d      	movs	r5, r7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    191c:	3124      	adds	r1, #36	; 0x24
    191e:	1861      	adds	r1, r4, r1
    1920:	002a      	movs	r2, r5
    1922:	0030      	movs	r0, r6
    1924:	4b2b      	ldr	r3, [pc, #172]	; (19d4 <f_read+0x19c>)
    1926:	4798      	blx	r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    1928:	1976      	adds	r6, r6, r5
    192a:	68a3      	ldr	r3, [r4, #8]
    192c:	195b      	adds	r3, r3, r5
    192e:	60a3      	str	r3, [r4, #8]
    1930:	464b      	mov	r3, r9
    1932:	681b      	ldr	r3, [r3, #0]
    1934:	195b      	adds	r3, r3, r5
    1936:	464a      	mov	r2, r9
    1938:	6013      	str	r3, [r2, #0]
    193a:	1b7f      	subs	r7, r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    193c:	d098      	beq.n	1870 <f_read+0x38>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    193e:	68a3      	ldr	r3, [r4, #8]
    1940:	05da      	lsls	r2, r3, #23
    1942:	d1e2      	bne.n	190a <f_read+0xd2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    1944:	6820      	ldr	r0, [r4, #0]
    1946:	7882      	ldrb	r2, [r0, #2]
    1948:	3a01      	subs	r2, #1
    194a:	0a5d      	lsrs	r5, r3, #9
    194c:	4015      	ands	r5, r2
    194e:	b2ed      	uxtb	r5, r5
			if (!csect) {						/* On the cluster boundary? */
    1950:	2d00      	cmp	r5, #0
    1952:	d107      	bne.n	1964 <f_read+0x12c>
				if (fp->fptr == 0) {			/* On the top of the file? */
    1954:	2b00      	cmp	r3, #0
    1956:	d19c      	bne.n	1892 <f_read+0x5a>
					clst = fp->sclust;			/* Follow from the origin */
    1958:	6920      	ldr	r0, [r4, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    195a:	2801      	cmp	r0, #1
    195c:	d99d      	bls.n	189a <f_read+0x62>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    195e:	1c43      	adds	r3, r0, #1
    1960:	d09f      	beq.n	18a2 <f_read+0x6a>
				fp->clust = clst;				/* Update current cluster */
    1962:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    1964:	6823      	ldr	r3, [r4, #0]
    1966:	469a      	mov	sl, r3
    1968:	6961      	ldr	r1, [r4, #20]
    196a:	0018      	movs	r0, r3
    196c:	4b1c      	ldr	r3, [pc, #112]	; (19e0 <f_read+0x1a8>)
    196e:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1970:	2800      	cmp	r0, #0
    1972:	d09a      	beq.n	18aa <f_read+0x72>
			sect += csect;
    1974:	4683      	mov	fp, r0
    1976:	44ab      	add	fp, r5
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    1978:	0a7b      	lsrs	r3, r7, #9
    197a:	4698      	mov	r8, r3
			if (cc) {							/* Read maximum contiguous sectors directly */
    197c:	d0a6      	beq.n	18cc <f_read+0x94>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    197e:	4653      	mov	r3, sl
    1980:	789b      	ldrb	r3, [r3, #2]
    1982:	4642      	mov	r2, r8
    1984:	18aa      	adds	r2, r5, r2
    1986:	429a      	cmp	r2, r3
    1988:	d901      	bls.n	198e <f_read+0x156>
					cc = fp->fs->csize - csect;
    198a:	1b5b      	subs	r3, r3, r5
    198c:	4698      	mov	r8, r3
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
    198e:	4653      	mov	r3, sl
    1990:	7858      	ldrb	r0, [r3, #1]
    1992:	4643      	mov	r3, r8
    1994:	465a      	mov	r2, fp
    1996:	0031      	movs	r1, r6
    1998:	4d10      	ldr	r5, [pc, #64]	; (19dc <f_read+0x1a4>)
    199a:	47a8      	blx	r5
    199c:	2800      	cmp	r0, #0
    199e:	d188      	bne.n	18b2 <f_read+0x7a>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    19a0:	79a3      	ldrb	r3, [r4, #6]
    19a2:	065b      	lsls	r3, r3, #25
    19a4:	d504      	bpl.n	19b0 <f_read+0x178>
    19a6:	69a3      	ldr	r3, [r4, #24]
    19a8:	465a      	mov	r2, fp
    19aa:	1a98      	subs	r0, r3, r2
    19ac:	4580      	cmp	r8, r0
    19ae:	d884      	bhi.n	18ba <f_read+0x82>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    19b0:	4643      	mov	r3, r8
    19b2:	025d      	lsls	r5, r3, #9
				continue;
    19b4:	e7b8      	b.n	1928 <f_read+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    19b6:	2301      	movs	r3, #1
    19b8:	71e3      	strb	r3, [r4, #7]
    19ba:	9301      	str	r3, [sp, #4]
    19bc:	e758      	b.n	1870 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    19be:	2301      	movs	r3, #1
    19c0:	71e3      	strb	r3, [r4, #7]
    19c2:	9301      	str	r3, [sp, #4]
    19c4:	e754      	b.n	1870 <f_read+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    19c6:	9301      	str	r3, [sp, #4]
    19c8:	e752      	b.n	1870 <f_read+0x38>
    19ca:	46c0      	nop			; (mov r8, r8)
    19cc:	00000891 	.word	0x00000891
    19d0:	00000db5 	.word	0x00000db5
    19d4:	000006b9 	.word	0x000006b9
    19d8:	0000055d 	.word	0x0000055d
    19dc:	000004f9 	.word	0x000004f9
    19e0:	00000d9d 	.word	0x00000d9d

000019e4 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    19e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    19e6:	46de      	mov	lr, fp
    19e8:	4657      	mov	r7, sl
    19ea:	464e      	mov	r6, r9
    19ec:	4645      	mov	r5, r8
    19ee:	b5e0      	push	{r5, r6, r7, lr}
    19f0:	b083      	sub	sp, #12
    19f2:	0004      	movs	r4, r0
    19f4:	000d      	movs	r5, r1
    19f6:	0017      	movs	r7, r2
    19f8:	4699      	mov	r9, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    19fa:	2300      	movs	r3, #0
    19fc:	464a      	mov	r2, r9
    19fe:	6013      	str	r3, [r2, #0]

	res = validate(fp);						/* Check validity */
    1a00:	4b6f      	ldr	r3, [pc, #444]	; (1bc0 <f_write+0x1dc>)
    1a02:	4798      	blx	r3
    1a04:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    1a06:	2800      	cmp	r0, #0
    1a08:	d108      	bne.n	1a1c <f_write+0x38>
	if (fp->err)							/* Check error */
    1a0a:	79e3      	ldrb	r3, [r4, #7]
    1a0c:	2b00      	cmp	r3, #0
    1a0e:	d000      	beq.n	1a12 <f_write+0x2e>
    1a10:	e0d3      	b.n	1bba <f_write+0x1d6>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    1a12:	79a3      	ldrb	r3, [r4, #6]
    1a14:	079b      	lsls	r3, r3, #30
    1a16:	d409      	bmi.n	1a2c <f_write+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    1a18:	2307      	movs	r3, #7
    1a1a:	9301      	str	r3, [sp, #4]

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    1a1c:	9801      	ldr	r0, [sp, #4]
    1a1e:	b003      	add	sp, #12
    1a20:	bc3c      	pop	{r2, r3, r4, r5}
    1a22:	4690      	mov	r8, r2
    1a24:	4699      	mov	r9, r3
    1a26:	46a2      	mov	sl, r4
    1a28:	46ab      	mov	fp, r5
    1a2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
    1a2c:	68a3      	ldr	r3, [r4, #8]
    1a2e:	19da      	adds	r2, r3, r7
    1a30:	4293      	cmp	r3, r2
    1a32:	d80e      	bhi.n	1a52 <f_write+0x6e>
	for ( ;  btw;							/* Repeat until all data written */
    1a34:	2f00      	cmp	r7, #0
    1a36:	d00c      	beq.n	1a52 <f_write+0x6e>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    1a38:	002e      	movs	r6, r5
    1a3a:	e06b      	b.n	1b14 <f_write+0x130>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    1a3c:	2100      	movs	r1, #0
    1a3e:	4b61      	ldr	r3, [pc, #388]	; (1bc4 <f_write+0x1e0>)
    1a40:	4798      	blx	r3
    1a42:	0003      	movs	r3, r0
    1a44:	e003      	b.n	1a4e <f_write+0x6a>
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    1a46:	6961      	ldr	r1, [r4, #20]
    1a48:	4b5e      	ldr	r3, [pc, #376]	; (1bc4 <f_write+0x1e0>)
    1a4a:	4798      	blx	r3
    1a4c:	0003      	movs	r3, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    1a4e:	2b00      	cmp	r3, #0
    1a50:	d171      	bne.n	1b36 <f_write+0x152>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    1a52:	68a3      	ldr	r3, [r4, #8]
    1a54:	68e2      	ldr	r2, [r4, #12]
    1a56:	4293      	cmp	r3, r2
    1a58:	d900      	bls.n	1a5c <f_write+0x78>
    1a5a:	60e3      	str	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    1a5c:	79a3      	ldrb	r3, [r4, #6]
    1a5e:	2220      	movs	r2, #32
    1a60:	4313      	orrs	r3, r2
    1a62:	71a3      	strb	r3, [r4, #6]
	LEAVE_FF(fp->fs, FR_OK);
    1a64:	e7da      	b.n	1a1c <f_write+0x38>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    1a66:	3301      	adds	r3, #1
    1a68:	71e3      	strb	r3, [r4, #7]
    1a6a:	9301      	str	r3, [sp, #4]
    1a6c:	e7d6      	b.n	1a1c <f_write+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    1a6e:	3302      	adds	r3, #2
    1a70:	71e3      	strb	r3, [r4, #7]
    1a72:	9301      	str	r3, [sp, #4]
    1a74:	e7d2      	b.n	1a1c <f_write+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1a76:	0021      	movs	r1, r4
    1a78:	3124      	adds	r1, #36	; 0x24
    1a7a:	6823      	ldr	r3, [r4, #0]
    1a7c:	7858      	ldrb	r0, [r3, #1]
    1a7e:	2301      	movs	r3, #1
    1a80:	69a2      	ldr	r2, [r4, #24]
    1a82:	4d51      	ldr	r5, [pc, #324]	; (1bc8 <f_write+0x1e4>)
    1a84:	47a8      	blx	r5
    1a86:	2800      	cmp	r0, #0
    1a88:	d104      	bne.n	1a94 <f_write+0xb0>
				fp->flag &= ~FA__DIRTY;
    1a8a:	79a3      	ldrb	r3, [r4, #6]
    1a8c:	2240      	movs	r2, #64	; 0x40
    1a8e:	4393      	bics	r3, r2
    1a90:	71a3      	strb	r3, [r4, #6]
    1a92:	e05c      	b.n	1b4e <f_write+0x16a>
					ABORT(fp->fs, FR_DISK_ERR);
    1a94:	2301      	movs	r3, #1
    1a96:	71e3      	strb	r3, [r4, #7]
    1a98:	9301      	str	r3, [sp, #4]
    1a9a:	e7bf      	b.n	1a1c <f_write+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1a9c:	2302      	movs	r3, #2
    1a9e:	71e3      	strb	r3, [r4, #7]
    1aa0:	9301      	str	r3, [sp, #4]
    1aa2:	e7bb      	b.n	1a1c <f_write+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    1aa4:	2301      	movs	r3, #1
    1aa6:	71e3      	strb	r3, [r4, #7]
    1aa8:	9301      	str	r3, [sp, #4]
    1aaa:	e7b7      	b.n	1a1c <f_write+0x38>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    1aac:	0240      	lsls	r0, r0, #9
    1aae:	1831      	adds	r1, r6, r0
    1ab0:	0020      	movs	r0, r4
    1ab2:	3024      	adds	r0, #36	; 0x24
    1ab4:	2280      	movs	r2, #128	; 0x80
    1ab6:	0092      	lsls	r2, r2, #2
    1ab8:	4b44      	ldr	r3, [pc, #272]	; (1bcc <f_write+0x1e8>)
    1aba:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
    1abc:	79a3      	ldrb	r3, [r4, #6]
    1abe:	2240      	movs	r2, #64	; 0x40
    1ac0:	4393      	bics	r3, r2
    1ac2:	71a3      	strb	r3, [r4, #6]
    1ac4:	e068      	b.n	1b98 <f_write+0x1b4>
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    1ac6:	69a3      	ldr	r3, [r4, #24]
    1ac8:	4598      	cmp	r8, r3
    1aca:	d003      	beq.n	1ad4 <f_write+0xf0>
				if (fp->fptr < fp->fsize &&
    1acc:	68a3      	ldr	r3, [r4, #8]
    1ace:	68e2      	ldr	r2, [r4, #12]
    1ad0:	4293      	cmp	r3, r2
    1ad2:	d364      	bcc.n	1b9e <f_write+0x1ba>
			fp->dsect = sect;
    1ad4:	4643      	mov	r3, r8
    1ad6:	61a3      	str	r3, [r4, #24]
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    1ad8:	68a3      	ldr	r3, [r4, #8]
    1ada:	05d8      	lsls	r0, r3, #23
    1adc:	0dc0      	lsrs	r0, r0, #23
    1ade:	2580      	movs	r5, #128	; 0x80
    1ae0:	00ad      	lsls	r5, r5, #2
    1ae2:	1a2d      	subs	r5, r5, r0
    1ae4:	42bd      	cmp	r5, r7
    1ae6:	d900      	bls.n	1aea <f_write+0x106>
    1ae8:	003d      	movs	r5, r7
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    1aea:	3024      	adds	r0, #36	; 0x24
    1aec:	1820      	adds	r0, r4, r0
    1aee:	002a      	movs	r2, r5
    1af0:	0031      	movs	r1, r6
    1af2:	4b36      	ldr	r3, [pc, #216]	; (1bcc <f_write+0x1e8>)
    1af4:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
    1af6:	79a3      	ldrb	r3, [r4, #6]
    1af8:	2240      	movs	r2, #64	; 0x40
    1afa:	4313      	orrs	r3, r2
    1afc:	71a3      	strb	r3, [r4, #6]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    1afe:	1976      	adds	r6, r6, r5
    1b00:	68a3      	ldr	r3, [r4, #8]
    1b02:	195b      	adds	r3, r3, r5
    1b04:	60a3      	str	r3, [r4, #8]
    1b06:	464b      	mov	r3, r9
    1b08:	681b      	ldr	r3, [r3, #0]
    1b0a:	195b      	adds	r3, r3, r5
    1b0c:	464a      	mov	r2, r9
    1b0e:	6013      	str	r3, [r2, #0]
    1b10:	1b7f      	subs	r7, r7, r5
	for ( ;  btw;							/* Repeat until all data written */
    1b12:	d09e      	beq.n	1a52 <f_write+0x6e>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    1b14:	68a3      	ldr	r3, [r4, #8]
    1b16:	05da      	lsls	r2, r3, #23
    1b18:	d1de      	bne.n	1ad8 <f_write+0xf4>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    1b1a:	6820      	ldr	r0, [r4, #0]
    1b1c:	7882      	ldrb	r2, [r0, #2]
    1b1e:	3a01      	subs	r2, #1
    1b20:	0a5d      	lsrs	r5, r3, #9
    1b22:	4015      	ands	r5, r2
    1b24:	b2ea      	uxtb	r2, r5
    1b26:	4693      	mov	fp, r2
			if (!csect) {					/* On the cluster boundary? */
    1b28:	2a00      	cmp	r2, #0
    1b2a:	d10d      	bne.n	1b48 <f_write+0x164>
				if (fp->fptr == 0) {		/* On the top of the file? */
    1b2c:	2b00      	cmp	r3, #0
    1b2e:	d18a      	bne.n	1a46 <f_write+0x62>
					clst = fp->sclust;		/* Follow from the origin */
    1b30:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
    1b32:	2b00      	cmp	r3, #0
    1b34:	d082      	beq.n	1a3c <f_write+0x58>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    1b36:	2b01      	cmp	r3, #1
    1b38:	d095      	beq.n	1a66 <f_write+0x82>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    1b3a:	1c5a      	adds	r2, r3, #1
    1b3c:	d097      	beq.n	1a6e <f_write+0x8a>
				fp->clust = clst;			/* Update current cluster */
    1b3e:	6163      	str	r3, [r4, #20]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
    1b40:	6922      	ldr	r2, [r4, #16]
    1b42:	2a00      	cmp	r2, #0
    1b44:	d100      	bne.n	1b48 <f_write+0x164>
    1b46:	6123      	str	r3, [r4, #16]
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    1b48:	79a3      	ldrb	r3, [r4, #6]
    1b4a:	065b      	lsls	r3, r3, #25
    1b4c:	d493      	bmi.n	1a76 <f_write+0x92>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    1b4e:	6823      	ldr	r3, [r4, #0]
    1b50:	469a      	mov	sl, r3
    1b52:	6961      	ldr	r1, [r4, #20]
    1b54:	0018      	movs	r0, r3
    1b56:	4b1e      	ldr	r3, [pc, #120]	; (1bd0 <f_write+0x1ec>)
    1b58:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    1b5a:	2800      	cmp	r0, #0
    1b5c:	d09e      	beq.n	1a9c <f_write+0xb8>
			sect += csect;
    1b5e:	4680      	mov	r8, r0
    1b60:	4658      	mov	r0, fp
    1b62:	4684      	mov	ip, r0
    1b64:	44d8      	add	r8, fp
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    1b66:	0a7b      	lsrs	r3, r7, #9
    1b68:	469b      	mov	fp, r3
			if (cc) {						/* Write maximum contiguous sectors directly */
    1b6a:	d0ac      	beq.n	1ac6 <f_write+0xe2>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    1b6c:	4653      	mov	r3, sl
    1b6e:	789b      	ldrb	r3, [r3, #2]
    1b70:	465a      	mov	r2, fp
    1b72:	4462      	add	r2, ip
    1b74:	429a      	cmp	r2, r3
    1b76:	d901      	bls.n	1b7c <f_write+0x198>
					cc = fp->fs->csize - csect;
    1b78:	1a1b      	subs	r3, r3, r0
    1b7a:	469b      	mov	fp, r3
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
    1b7c:	4653      	mov	r3, sl
    1b7e:	7858      	ldrb	r0, [r3, #1]
    1b80:	465b      	mov	r3, fp
    1b82:	4642      	mov	r2, r8
    1b84:	0031      	movs	r1, r6
    1b86:	4d10      	ldr	r5, [pc, #64]	; (1bc8 <f_write+0x1e4>)
    1b88:	47a8      	blx	r5
    1b8a:	2800      	cmp	r0, #0
    1b8c:	d18a      	bne.n	1aa4 <f_write+0xc0>
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    1b8e:	69a3      	ldr	r3, [r4, #24]
    1b90:	4642      	mov	r2, r8
    1b92:	1a98      	subs	r0, r3, r2
    1b94:	4583      	cmp	fp, r0
    1b96:	d889      	bhi.n	1aac <f_write+0xc8>
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    1b98:	465b      	mov	r3, fp
    1b9a:	025d      	lsls	r5, r3, #9
				continue;
    1b9c:	e7af      	b.n	1afe <f_write+0x11a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    1b9e:	0021      	movs	r1, r4
    1ba0:	3124      	adds	r1, #36	; 0x24
    1ba2:	4653      	mov	r3, sl
    1ba4:	7858      	ldrb	r0, [r3, #1]
    1ba6:	2301      	movs	r3, #1
    1ba8:	4642      	mov	r2, r8
    1baa:	4d0a      	ldr	r5, [pc, #40]	; (1bd4 <f_write+0x1f0>)
    1bac:	47a8      	blx	r5
				if (fp->fptr < fp->fsize &&
    1bae:	2800      	cmp	r0, #0
    1bb0:	d090      	beq.n	1ad4 <f_write+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    1bb2:	2001      	movs	r0, #1
    1bb4:	71e0      	strb	r0, [r4, #7]
    1bb6:	9001      	str	r0, [sp, #4]
    1bb8:	e730      	b.n	1a1c <f_write+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    1bba:	9301      	str	r3, [sp, #4]
    1bbc:	e72e      	b.n	1a1c <f_write+0x38>
    1bbe:	46c0      	nop			; (mov r8, r8)
    1bc0:	00000891 	.word	0x00000891
    1bc4:	000010a9 	.word	0x000010a9
    1bc8:	0000055d 	.word	0x0000055d
    1bcc:	000006b9 	.word	0x000006b9
    1bd0:	00000d9d 	.word	0x00000d9d
    1bd4:	000004f9 	.word	0x000004f9

00001bd8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    1bd8:	b570      	push	{r4, r5, r6, lr}
    1bda:	0004      	movs	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    1bdc:	4b26      	ldr	r3, [pc, #152]	; (1c78 <f_sync+0xa0>)
    1bde:	4798      	blx	r3
	if (res == FR_OK) {
    1be0:	2800      	cmp	r0, #0
    1be2:	d11a      	bne.n	1c1a <f_sync+0x42>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    1be4:	79a3      	ldrb	r3, [r4, #6]
    1be6:	069a      	lsls	r2, r3, #26
    1be8:	d517      	bpl.n	1c1a <f_sync+0x42>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
    1bea:	065b      	lsls	r3, r3, #25
    1bec:	d50f      	bpl.n	1c0e <f_sync+0x36>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1bee:	0021      	movs	r1, r4
    1bf0:	3124      	adds	r1, #36	; 0x24
    1bf2:	6823      	ldr	r3, [r4, #0]
    1bf4:	7858      	ldrb	r0, [r3, #1]
    1bf6:	2301      	movs	r3, #1
    1bf8:	69a2      	ldr	r2, [r4, #24]
    1bfa:	4d20      	ldr	r5, [pc, #128]	; (1c7c <f_sync+0xa4>)
    1bfc:	47a8      	blx	r5
    1bfe:	0003      	movs	r3, r0
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    1c00:	2001      	movs	r0, #1
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1c02:	2b00      	cmp	r3, #0
    1c04:	d109      	bne.n	1c1a <f_sync+0x42>
				fp->flag &= ~FA__DIRTY;
    1c06:	79a3      	ldrb	r3, [r4, #6]
    1c08:	2240      	movs	r2, #64	; 0x40
    1c0a:	4393      	bics	r3, r2
    1c0c:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    1c0e:	69e1      	ldr	r1, [r4, #28]
    1c10:	6820      	ldr	r0, [r4, #0]
    1c12:	4b1b      	ldr	r3, [pc, #108]	; (1c80 <f_sync+0xa8>)
    1c14:	4798      	blx	r3
			if (res == FR_OK) {
    1c16:	2800      	cmp	r0, #0
    1c18:	d000      	beq.n	1c1c <f_sync+0x44>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    1c1a:	bd70      	pop	{r4, r5, r6, pc}
				dir = fp->dir_ptr;
    1c1c:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    1c1e:	7aeb      	ldrb	r3, [r5, #11]
    1c20:	2220      	movs	r2, #32
    1c22:	4313      	orrs	r3, r2
    1c24:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
    1c26:	7b23      	ldrb	r3, [r4, #12]
    1c28:	772b      	strb	r3, [r5, #28]
    1c2a:	89a3      	ldrh	r3, [r4, #12]
    1c2c:	0a1b      	lsrs	r3, r3, #8
    1c2e:	776b      	strb	r3, [r5, #29]
    1c30:	89e3      	ldrh	r3, [r4, #14]
    1c32:	77ab      	strb	r3, [r5, #30]
    1c34:	7be3      	ldrb	r3, [r4, #15]
    1c36:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
    1c38:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir + DIR_FstClusLO, cl);
    1c3a:	76ab      	strb	r3, [r5, #26]
    1c3c:	0a1a      	lsrs	r2, r3, #8
    1c3e:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    1c40:	0c1b      	lsrs	r3, r3, #16
    1c42:	752b      	strb	r3, [r5, #20]
    1c44:	0a1b      	lsrs	r3, r3, #8
    1c46:	756b      	strb	r3, [r5, #21]
				tm = GET_FATTIME();							/* Update updated time */
    1c48:	4b0e      	ldr	r3, [pc, #56]	; (1c84 <f_sync+0xac>)
    1c4a:	4798      	blx	r3
				ST_DWORD(dir + DIR_WrtTime, tm);
    1c4c:	75a8      	strb	r0, [r5, #22]
    1c4e:	0a03      	lsrs	r3, r0, #8
    1c50:	75eb      	strb	r3, [r5, #23]
    1c52:	0c03      	lsrs	r3, r0, #16
    1c54:	762b      	strb	r3, [r5, #24]
    1c56:	0e00      	lsrs	r0, r0, #24
    1c58:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
    1c5a:	2300      	movs	r3, #0
    1c5c:	74ab      	strb	r3, [r5, #18]
    1c5e:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
    1c60:	79a3      	ldrb	r3, [r4, #6]
    1c62:	2220      	movs	r2, #32
    1c64:	4393      	bics	r3, r2
    1c66:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    1c68:	2301      	movs	r3, #1
    1c6a:	6822      	ldr	r2, [r4, #0]
    1c6c:	7113      	strb	r3, [r2, #4]
				res = sync_fs(fp->fs);
    1c6e:	6820      	ldr	r0, [r4, #0]
    1c70:	4b05      	ldr	r3, [pc, #20]	; (1c88 <f_sync+0xb0>)
    1c72:	4798      	blx	r3
    1c74:	e7d1      	b.n	1c1a <f_sync+0x42>
    1c76:	46c0      	nop			; (mov r8, r8)
    1c78:	00000891 	.word	0x00000891
    1c7c:	0000055d 	.word	0x0000055d
    1c80:	000007b1 	.word	0x000007b1
    1c84:	000006b5 	.word	0x000006b5
    1c88:	00000ca9 	.word	0x00000ca9

00001c8c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    1c8c:	b510      	push	{r4, lr}
    1c8e:	0004      	movs	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
    1c90:	4b06      	ldr	r3, [pc, #24]	; (1cac <f_close+0x20>)
    1c92:	4798      	blx	r3
	if (res == FR_OK)
    1c94:	2800      	cmp	r0, #0
    1c96:	d000      	beq.n	1c9a <f_close+0xe>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
    1c98:	bd10      	pop	{r4, pc}
		res = validate(fp);				/* Lock volume */
    1c9a:	0020      	movs	r0, r4
    1c9c:	4b04      	ldr	r3, [pc, #16]	; (1cb0 <f_close+0x24>)
    1c9e:	4798      	blx	r3
		if (res == FR_OK) {
    1ca0:	2800      	cmp	r0, #0
    1ca2:	d1f9      	bne.n	1c98 <f_close+0xc>
				fp->fs = 0;				/* Invalidate file object */
    1ca4:	2300      	movs	r3, #0
    1ca6:	6023      	str	r3, [r4, #0]
    1ca8:	e7f6      	b.n	1c98 <f_close+0xc>
    1caa:	46c0      	nop			; (mov r8, r8)
    1cac:	00001bd9 	.word	0x00001bd9
    1cb0:	00000891 	.word	0x00000891

00001cb4 <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
    1cb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    1cb6:	b085      	sub	sp, #20
    1cb8:	9001      	str	r0, [sp, #4]
    1cba:	9200      	str	r2, [sp, #0]
	int n = 0;
	TCHAR c, *p = buff;
    1cbc:	0007      	movs	r7, r0
	int n = 0;
    1cbe:	2400      	movs	r4, #0
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
    1cc0:	1e4d      	subs	r5, r1, #1
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
    1cc2:	4e10      	ldr	r6, [pc, #64]	; (1d04 <f_gets+0x50>)
	while (n < len - 1) {	/* Read characters until buffer gets filled */
    1cc4:	42ac      	cmp	r4, r5
    1cc6:	da13      	bge.n	1cf0 <f_gets+0x3c>
		f_read(fp, s, 1, &rc);
    1cc8:	ab02      	add	r3, sp, #8
    1cca:	2201      	movs	r2, #1
    1ccc:	a903      	add	r1, sp, #12
    1cce:	9800      	ldr	r0, [sp, #0]
    1cd0:	47b0      	blx	r6
		if (rc != 1) break;
    1cd2:	9b02      	ldr	r3, [sp, #8]
    1cd4:	2b01      	cmp	r3, #1
    1cd6:	d10b      	bne.n	1cf0 <f_gets+0x3c>
		c = s[0];
    1cd8:	ab03      	add	r3, sp, #12
    1cda:	781b      	ldrb	r3, [r3, #0]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
    1cdc:	2b0d      	cmp	r3, #13
    1cde:	d0f1      	beq.n	1cc4 <f_gets+0x10>
		*p++ = c;
    1ce0:	1c7a      	adds	r2, r7, #1
    1ce2:	703b      	strb	r3, [r7, #0]
		n++;
    1ce4:	3401      	adds	r4, #1
		if (c == '\n') break;		/* Break on EOL */
    1ce6:	2b0a      	cmp	r3, #10
    1ce8:	d001      	beq.n	1cee <f_gets+0x3a>
		*p++ = c;
    1cea:	0017      	movs	r7, r2
    1cec:	e7ea      	b.n	1cc4 <f_gets+0x10>
    1cee:	0017      	movs	r7, r2
	}
	*p = 0;
    1cf0:	2300      	movs	r3, #0
    1cf2:	703b      	strb	r3, [r7, #0]
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
    1cf4:	1e63      	subs	r3, r4, #1
    1cf6:	419c      	sbcs	r4, r3
    1cf8:	4264      	negs	r4, r4
    1cfa:	9b01      	ldr	r3, [sp, #4]
    1cfc:	4023      	ands	r3, r4
}
    1cfe:	0018      	movs	r0, r3
    1d00:	b005      	add	sp, #20
    1d02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d04:	00001839 	.word	0x00001839

00001d08 <main>:
 *
 * Note:
 *
 ******************************************************************************/
int main(void)
{
    1d08:	b510      	push	{r4, lr}
	// CMSIS compliant function not used
	//SystemInit();
	
	// Application hardware and software initialization 
	AppInit();
    1d0a:	4b02      	ldr	r3, [pc, #8]	; (1d14 <main+0xc>)
    1d0c:	4798      	blx	r3

	// Super loop
	while(1)
	{
		// Run your application
		AppRun();
    1d0e:	4c02      	ldr	r4, [pc, #8]	; (1d18 <main+0x10>)
    1d10:	47a0      	blx	r4
    1d12:	e7fd      	b.n	1d10 <main+0x8>
    1d14:	00000115 	.word	0x00000115
    1d18:	00000135 	.word	0x00000135

00001d1c <SDCard_WaitRead>:

/*-----------------------------------------------------------------------*/
/* Wait for SD Card to Read                                              */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WaitRead( void )
{
    1d1c:	b570      	push	{r4, r5, r6, lr}
    1d1e:	4c06      	ldr	r4, [pc, #24]	; (1d38 <SDCard_WaitRead+0x1c>)
	uint32_t cnt = 0x00FFFFF;
	uint8_t  res;
	
	do
	{
		res = SPI_SD_Send_Byte( 0xFF );
    1d20:	4d06      	ldr	r5, [pc, #24]	; (1d3c <SDCard_WaitRead+0x20>)
    1d22:	20ff      	movs	r0, #255	; 0xff
    1d24:	47a8      	blx	r5
		
		if ( res == 0xff ) //
    1d26:	28ff      	cmp	r0, #255	; 0xff
    1d28:	d004      	beq.n	1d34 <SDCard_WaitRead+0x18>
    1d2a:	3c01      	subs	r4, #1
		{
			return 0;
		}
		cnt--;

	} while ( cnt );
    1d2c:	2c00      	cmp	r4, #0
    1d2e:	d1f8      	bne.n	1d22 <SDCard_WaitRead+0x6>

	return 1;
    1d30:	2001      	movs	r0, #1
    1d32:	e000      	b.n	1d36 <SDCard_WaitRead+0x1a>
			return 0;
    1d34:	2000      	movs	r0, #0
} // SDCard_WaitRead()
    1d36:	bd70      	pop	{r4, r5, r6, pc}
    1d38:	000fffff 	.word	0x000fffff
    1d3c:	00002429 	.word	0x00002429

00001d40 <SDCard_WriteCmd>:

/*-----------------------------------------------------------------------*/
/* Write a command to the card                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteCmd(uint8_t cmd, uint32_t arg, uint8_t crc )
{
    1d40:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d42:	b083      	sub	sp, #12
    1d44:	0007      	movs	r7, r0
    1d46:	000d      	movs	r5, r1
    1d48:	9201      	str	r2, [sp, #4]
		SPI_CS_HIGH();
    1d4a:	4c19      	ldr	r4, [pc, #100]	; (1db0 <SDCard_WriteCmd+0x70>)
    1d4c:	2680      	movs	r6, #128	; 0x80
    1d4e:	0076      	lsls	r6, r6, #1
    1d50:	61a6      	str	r6, [r4, #24]
	uint16_t cnt = 512;
	uint8_t  res;

    // toggle line and transmit data
	SDCard_SS(1); 
    SPI_SD_Send_Byte( 0xFF); 
    1d52:	20ff      	movs	r0, #255	; 0xff
    1d54:	4b17      	ldr	r3, [pc, #92]	; (1db4 <SDCard_WriteCmd+0x74>)
    1d56:	4798      	blx	r3
		SPI_CS_LOW();
    1d58:	6166      	str	r6, [r4, #20]
    1d5a:	6166      	str	r6, [r4, #20]
	if ( SDCard_WaitRead() == 0 ) // ??SD/MMC??
    1d5c:	4b16      	ldr	r3, [pc, #88]	; (1db8 <SDCard_WriteCmd+0x78>)
    1d5e:	4798      	blx	r3
    1d60:	2800      	cmp	r0, #0
    1d62:	d11c      	bne.n	1d9e <SDCard_WriteCmd+0x5e>
     if (SDCard_EnableSelect())              // Select the card and wait for ready except to stop multiple block read
     {
	  return 0xFF;
     } 
	
     SPI_SD_Send_Byte( cmd | 0x40 );          // start command and index
    1d64:	2040      	movs	r0, #64	; 0x40
    1d66:	4338      	orrs	r0, r7
    1d68:	4c12      	ldr	r4, [pc, #72]	; (1db4 <SDCard_WriteCmd+0x74>)
    1d6a:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>24) );  // argument [31..24]
    1d6c:	0e28      	lsrs	r0, r5, #24
    1d6e:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>16) );  // argument [23..16]
    1d70:	0c28      	lsrs	r0, r5, #16
    1d72:	b2c0      	uxtb	r0, r0
    1d74:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg>>8) );   // argument [15..8]
    1d76:	0a28      	lsrs	r0, r5, #8
    1d78:	b2c0      	uxtb	r0, r0
    1d7a:	47a0      	blx	r4
     SPI_SD_Send_Byte( (uint8_t)(arg) );      // argument [7..0]
    1d7c:	b2e8      	uxtb	r0, r5
    1d7e:	47a0      	blx	r4
     SPI_SD_Send_Byte( crc );                 // Send valid CRC and stop
    1d80:	9801      	ldr	r0, [sp, #4]
    1d82:	47a0      	blx	r4
	 
	 do                                       // Wait for a valid response
	 {
		 res = SPI_SD_Send_Byte(0xFF);
    1d84:	20ff      	movs	r0, #255	; 0xff
    1d86:	47a0      	blx	r4
    1d88:	4c0c      	ldr	r4, [pc, #48]	; (1dbc <SDCard_WriteCmd+0x7c>)
    1d8a:	4d0a      	ldr	r5, [pc, #40]	; (1db4 <SDCard_WriteCmd+0x74>)
		 cnt--;
	 } while ((cnt)&&(res==0xFF));
    1d8c:	28ff      	cmp	r0, #255	; 0xff
    1d8e:	d10c      	bne.n	1daa <SDCard_WriteCmd+0x6a>
		 res = SPI_SD_Send_Byte(0xFF);
    1d90:	20ff      	movs	r0, #255	; 0xff
    1d92:	47a8      	blx	r5
    1d94:	3c01      	subs	r4, #1
    1d96:	b2a4      	uxth	r4, r4
	 } while ((cnt)&&(res==0xFF));
    1d98:	2c00      	cmp	r4, #0
    1d9a:	d1f7      	bne.n	1d8c <SDCard_WriteCmd+0x4c>
    1d9c:	e005      	b.n	1daa <SDCard_WriteCmd+0x6a>
		SPI_CS_HIGH();
    1d9e:	0023      	movs	r3, r4
    1da0:	619e      	str	r6, [r3, #24]
	SPI_SD_Send_Byte(0xFF); 
    1da2:	20ff      	movs	r0, #255	; 0xff
    1da4:	4b03      	ldr	r3, [pc, #12]	; (1db4 <SDCard_WriteCmd+0x74>)
    1da6:	4798      	blx	r3
	  return 0xFF;
    1da8:	20ff      	movs	r0, #255	; 0xff

 	 return res;                              // Return with a response value
} // SDCard_WriteCmd()
    1daa:	b003      	add	sp, #12
    1dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1dae:	46c0      	nop			; (mov r8, r8)
    1db0:	41004400 	.word	0x41004400
    1db4:	00002429 	.word	0x00002429
    1db8:	00001d1d 	.word	0x00001d1d
    1dbc:	000001ff 	.word	0x000001ff

00001dc0 <SDCard_Init>:
uint8_t SDCard_Init(void){
    1dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SPI_Initialize_Slow();
    1dc2:	4b4c      	ldr	r3, [pc, #304]	; (1ef4 <SDCard_Init+0x134>)
    1dc4:	4798      	blx	r3
	delay_ms(100);
    1dc6:	484c      	ldr	r0, [pc, #304]	; (1ef8 <SDCard_Init+0x138>)
    1dc8:	4b4c      	ldr	r3, [pc, #304]	; (1efc <SDCard_Init+0x13c>)
    1dca:	4798      	blx	r3
    1dcc:	240f      	movs	r4, #15
		SPI_SD_Send_Byte(0xFF);  // send dummy clocks
    1dce:	4d4c      	ldr	r5, [pc, #304]	; (1f00 <SDCard_Init+0x140>)
    1dd0:	20ff      	movs	r0, #255	; 0xff
    1dd2:	47a8      	blx	r5
    1dd4:	3c01      	subs	r4, #1
    1dd6:	b2e4      	uxtb	r4, r4
	for (tvar=0; tvar<0x0F; tvar++)
    1dd8:	2c00      	cmp	r4, #0
    1dda:	d1f9      	bne.n	1dd0 <SDCard_Init+0x10>
		tmp_0 = SDCard_WriteCmd(CMD0,0x00,0x95);
    1ddc:	4d49      	ldr	r5, [pc, #292]	; (1f04 <SDCard_Init+0x144>)
    1dde:	4c4a      	ldr	r4, [pc, #296]	; (1f08 <SDCard_Init+0x148>)
    1de0:	2295      	movs	r2, #149	; 0x95
    1de2:	2100      	movs	r1, #0
    1de4:	2040      	movs	r0, #64	; 0x40
    1de6:	47a8      	blx	r5
    1de8:	7020      	strb	r0, [r4, #0]
		lvar++;
    1dea:	7863      	ldrb	r3, [r4, #1]
    1dec:	3301      	adds	r3, #1
    1dee:	b2db      	uxtb	r3, r3
    1df0:	7063      	strb	r3, [r4, #1]
    }   while ((tmp_0 != 1) && (lvar < 200)); 
    1df2:	2801      	cmp	r0, #1
    1df4:	d001      	beq.n	1dfa <SDCard_Init+0x3a>
    1df6:	2bc7      	cmp	r3, #199	; 0xc7
    1df8:	d9f2      	bls.n	1de0 <SDCard_Init+0x20>
	if(lvar == 0)
    1dfa:	2b00      	cmp	r3, #0
    1dfc:	d016      	beq.n	1e2c <SDCard_Init+0x6c>
    tmp_8 = SDCard_WriteCmd(CMD8,0x1AA,0x87);
    1dfe:	2287      	movs	r2, #135	; 0x87
    1e00:	21d5      	movs	r1, #213	; 0xd5
    1e02:	0049      	lsls	r1, r1, #1
    1e04:	2048      	movs	r0, #72	; 0x48
    1e06:	4b3f      	ldr	r3, [pc, #252]	; (1f04 <SDCard_Init+0x144>)
    1e08:	4798      	blx	r3
    1e0a:	0006      	movs	r6, r0
    1e0c:	4b3e      	ldr	r3, [pc, #248]	; (1f08 <SDCard_Init+0x148>)
    1e0e:	7098      	strb	r0, [r3, #2]
    if(tmp_8 == 1)
    1e10:	2801      	cmp	r0, #1
    1e12:	d017      	beq.n	1e44 <SDCard_Init+0x84>
			UART3_Write_Text("Initialization Complete \n");
    1e14:	483d      	ldr	r0, [pc, #244]	; (1f0c <SDCard_Init+0x14c>)
    1e16:	4b3e      	ldr	r3, [pc, #248]	; (1f10 <SDCard_Init+0x150>)
    1e18:	4798      	blx	r3
	SPI_Initialize_Fast();
    1e1a:	4b3e      	ldr	r3, [pc, #248]	; (1f14 <SDCard_Init+0x154>)
    1e1c:	4798      	blx	r3
		SPI_CS_HIGH();
    1e1e:	2280      	movs	r2, #128	; 0x80
    1e20:	0052      	lsls	r2, r2, #1
    1e22:	4b3d      	ldr	r3, [pc, #244]	; (1f18 <SDCard_Init+0x158>)
    1e24:	619a      	str	r2, [r3, #24]
			return 0;
    1e26:	2600      	movs	r6, #0
}// SDCard_Init()
    1e28:	0030      	movs	r0, r6
    1e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		SPI_CS_HIGH();
    1e2c:	2280      	movs	r2, #128	; 0x80
    1e2e:	0052      	lsls	r2, r2, #1
    1e30:	4b39      	ldr	r3, [pc, #228]	; (1f18 <SDCard_Init+0x158>)
    1e32:	619a      	str	r2, [r3, #24]
		SPI_SD_Send_Byte(0xFF);
    1e34:	20ff      	movs	r0, #255	; 0xff
    1e36:	4b32      	ldr	r3, [pc, #200]	; (1f00 <SDCard_Init+0x140>)
    1e38:	4798      	blx	r3
		UART3_Write_Text("Faile to reset card");
    1e3a:	4838      	ldr	r0, [pc, #224]	; (1f1c <SDCard_Init+0x15c>)
    1e3c:	4b34      	ldr	r3, [pc, #208]	; (1f10 <SDCard_Init+0x150>)
    1e3e:	4798      	blx	r3
		return 1;
    1e40:	2601      	movs	r6, #1
    1e42:	e7f1      	b.n	1e28 <SDCard_Init+0x68>
    1e44:	4c36      	ldr	r4, [pc, #216]	; (1f20 <SDCard_Init+0x160>)
		 		  tmp_55 = SDCard_WriteCmd( CMD55, 0, 0xff );
    1e46:	4d2f      	ldr	r5, [pc, #188]	; (1f04 <SDCard_Init+0x144>)
    1e48:	001f      	movs	r7, r3
    1e4a:	22ff      	movs	r2, #255	; 0xff
    1e4c:	2100      	movs	r1, #0
    1e4e:	2077      	movs	r0, #119	; 0x77
    1e50:	47a8      	blx	r5
    1e52:	70f8      	strb	r0, [r7, #3]
		 		  tmp_41 = SDCard_WriteCmd( CMD41,0x40000000, 0xff);//CMD41
    1e54:	22ff      	movs	r2, #255	; 0xff
    1e56:	2180      	movs	r1, #128	; 0x80
    1e58:	05c9      	lsls	r1, r1, #23
    1e5a:	2069      	movs	r0, #105	; 0x69
    1e5c:	47a8      	blx	r5
    1e5e:	7138      	strb	r0, [r7, #4]
		 	   } while ((tmp_41) && (cnt));
    1e60:	2800      	cmp	r0, #0
    1e62:	d003      	beq.n	1e6c <SDCard_Init+0xac>
    1e64:	3c01      	subs	r4, #1
    1e66:	b2a4      	uxth	r4, r4
    1e68:	2c00      	cmp	r4, #0
    1e6a:	d1ee      	bne.n	1e4a <SDCard_Init+0x8a>
		 	        tmp_1 = SDCard_WriteCmd(CMD1,0, 0xff);
    1e6c:	22ff      	movs	r2, #255	; 0xff
    1e6e:	2100      	movs	r1, #0
    1e70:	2041      	movs	r0, #65	; 0x41
    1e72:	4d24      	ldr	r5, [pc, #144]	; (1f04 <SDCard_Init+0x144>)
    1e74:	47a8      	blx	r5
    1e76:	4c24      	ldr	r4, [pc, #144]	; (1f08 <SDCard_Init+0x148>)
    1e78:	7160      	strb	r0, [r4, #5]
				   tmp_58 = SDCard_WriteCmd(CMD58, 0, 0);
    1e7a:	2200      	movs	r2, #0
    1e7c:	2100      	movs	r1, #0
    1e7e:	207a      	movs	r0, #122	; 0x7a
    1e80:	47a8      	blx	r5
    1e82:	71a0      	strb	r0, [r4, #6]
    1e84:	2400      	movs	r4, #0
				   if ( tmp_58 != 0x00 )
    1e86:	2800      	cmp	r0, #0
    1e88:	d125      	bne.n	1ed6 <SDCard_Init+0x116>
					 dataBuff[tvar] = SPI_SD_Read_Byte();
    1e8a:	4e26      	ldr	r6, [pc, #152]	; (1f24 <SDCard_Init+0x164>)
    1e8c:	4d26      	ldr	r5, [pc, #152]	; (1f28 <SDCard_Init+0x168>)
    1e8e:	47b0      	blx	r6
    1e90:	5528      	strb	r0, [r5, r4]
    1e92:	3401      	adds	r4, #1
				   for ( tvar = 0; tvar < 4; tvar++ )
    1e94:	2c04      	cmp	r4, #4
    1e96:	d1fa      	bne.n	1e8e <SDCard_Init+0xce>
		SPI_CS_HIGH();
    1e98:	2280      	movs	r2, #128	; 0x80
    1e9a:	0052      	lsls	r2, r2, #1
    1e9c:	4b1e      	ldr	r3, [pc, #120]	; (1f18 <SDCard_Init+0x158>)
    1e9e:	619a      	str	r2, [r3, #24]
		 	       if ( dataBuff[0] & 0x40 )
    1ea0:	4b21      	ldr	r3, [pc, #132]	; (1f28 <SDCard_Init+0x168>)
    1ea2:	781b      	ldrb	r3, [r3, #0]
    1ea4:	065b      	lsls	r3, r3, #25
    1ea6:	d51e      	bpl.n	1ee6 <SDCard_Init+0x126>
		 		      SD_Type = SD_TYPE_V2HC;
    1ea8:	3afc      	subs	r2, #252	; 0xfc
    1eaa:	4b17      	ldr	r3, [pc, #92]	; (1f08 <SDCard_Init+0x148>)
    1eac:	71da      	strb	r2, [r3, #7]
		 		      UART3_Write_Text( "Card: V2.0 SDHC\n");
    1eae:	481f      	ldr	r0, [pc, #124]	; (1f2c <SDCard_Init+0x16c>)
    1eb0:	4b17      	ldr	r3, [pc, #92]	; (1f10 <SDCard_Init+0x150>)
    1eb2:	4798      	blx	r3
		 	       while(SDCard_WriteCmd(CMD16,512,0xff) != 0)
    1eb4:	2580      	movs	r5, #128	; 0x80
    1eb6:	00ad      	lsls	r5, r5, #2
    1eb8:	4c12      	ldr	r4, [pc, #72]	; (1f04 <SDCard_Init+0x144>)
    1eba:	22ff      	movs	r2, #255	; 0xff
    1ebc:	0029      	movs	r1, r5
    1ebe:	2050      	movs	r0, #80	; 0x50
    1ec0:	47a0      	blx	r4
    1ec2:	2800      	cmp	r0, #0
    1ec4:	d1f9      	bne.n	1eba <SDCard_Init+0xfa>
			      tmp_9 = SDCard_WriteCmd(CMD9,0,0xff);
    1ec6:	22ff      	movs	r2, #255	; 0xff
    1ec8:	2100      	movs	r1, #0
    1eca:	3049      	adds	r0, #73	; 0x49
    1ecc:	4b0d      	ldr	r3, [pc, #52]	; (1f04 <SDCard_Init+0x144>)
    1ece:	4798      	blx	r3
    1ed0:	4b0d      	ldr	r3, [pc, #52]	; (1f08 <SDCard_Init+0x148>)
    1ed2:	7218      	strb	r0, [r3, #8]
    1ed4:	e79e      	b.n	1e14 <SDCard_Init+0x54>
		SPI_CS_HIGH();
    1ed6:	2280      	movs	r2, #128	; 0x80
    1ed8:	0052      	lsls	r2, r2, #1
    1eda:	4b0f      	ldr	r3, [pc, #60]	; (1f18 <SDCard_Init+0x158>)
    1edc:	619a      	str	r2, [r3, #24]
					   UART3_Write_Text( "Problem taking OCR data\n");
    1ede:	4814      	ldr	r0, [pc, #80]	; (1f30 <SDCard_Init+0x170>)
    1ee0:	4b0b      	ldr	r3, [pc, #44]	; (1f10 <SDCard_Init+0x150>)
    1ee2:	4798      	blx	r3
					   return 1;
    1ee4:	e7a0      	b.n	1e28 <SDCard_Init+0x68>
		 		      SD_Type = SD_TYPE_V2;
    1ee6:	2202      	movs	r2, #2
    1ee8:	4b07      	ldr	r3, [pc, #28]	; (1f08 <SDCard_Init+0x148>)
    1eea:	71da      	strb	r2, [r3, #7]
		 		      UART3_Write_Text( "Card Type: V2.0\n");
    1eec:	4811      	ldr	r0, [pc, #68]	; (1f34 <SDCard_Init+0x174>)
    1eee:	4b08      	ldr	r3, [pc, #32]	; (1f10 <SDCard_Init+0x150>)
    1ef0:	4798      	blx	r3
    1ef2:	e7df      	b.n	1eb4 <SDCard_Init+0xf4>
    1ef4:	00002365 	.word	0x00002365
    1ef8:	000a7693 	.word	0x000a7693
    1efc:	000003e5 	.word	0x000003e5
    1f00:	00002429 	.word	0x00002429
    1f04:	00001d41 	.word	0x00001d41
    1f08:	2000045e 	.word	0x2000045e
    1f0c:	00002c08 	.word	0x00002c08
    1f10:	00002505 	.word	0x00002505
    1f14:	000022c1 	.word	0x000022c1
    1f18:	41004400 	.word	0x41004400
    1f1c:	00002bb0 	.word	0x00002bb0
    1f20:	0000ffff 	.word	0x0000ffff
    1f24:	00002435 	.word	0x00002435
    1f28:	200008c8 	.word	0x200008c8
    1f2c:	00002be0 	.word	0x00002be0
    1f30:	00002bc4 	.word	0x00002bc4
    1f34:	00002bf4 	.word	0x00002bf4

00001f38 <SDCard_CardID>:

/*-----------------------------------------------------------------------*/
/* Get the SD Card ID                                                    */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_CardID(uint8_t cmd, uint8_t *buf)
{
    1f38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1f3a:	000d      	movs	r5, r1
	uint8_t i;

	if (SDCard_WriteCmd(cmd,0x00,0xFF) != 0x00)
    1f3c:	22ff      	movs	r2, #255	; 0xff
    1f3e:	2100      	movs	r1, #0
    1f40:	4b08      	ldr	r3, [pc, #32]	; (1f64 <SDCard_CardID+0x2c>)
    1f42:	4798      	blx	r3
    1f44:	1e06      	subs	r6, r0, #0
    1f46:	d10a      	bne.n	1f5e <SDCard_CardID+0x26>
    1f48:	002c      	movs	r4, r5
    1f4a:	3510      	adds	r5, #16
	    return 1;                                    
	}

	for (i=0; i<16; i++)
	{
	    *buf++ = SPI_SD_Send_Byte(0xFF);
    1f4c:	4f06      	ldr	r7, [pc, #24]	; (1f68 <SDCard_CardID+0x30>)
    1f4e:	20ff      	movs	r0, #255	; 0xff
    1f50:	47b8      	blx	r7
    1f52:	7020      	strb	r0, [r4, #0]
    1f54:	3401      	adds	r4, #1
	for (i=0; i<16; i++)
    1f56:	42a5      	cmp	r5, r4
    1f58:	d1f9      	bne.n	1f4e <SDCard_CardID+0x16>
	}

	return 0;                                        
}
    1f5a:	0030      	movs	r0, r6
    1f5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    return 1;                                    
    1f5e:	2601      	movs	r6, #1
    1f60:	e7fb      	b.n	1f5a <SDCard_CardID+0x22>
    1f62:	46c0      	nop			; (mov r8, r8)
    1f64:	00001d41 	.word	0x00001d41
    1f68:	00002429 	.word	0x00002429

00001f6c <SDCard_ReadSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Read a single block of Data                                           */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadSingleBlock(uint32_t addr, uint8_t *buf)
{
    1f6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f6e:	b083      	sub	sp, #12
    1f70:	0004      	movs	r4, r0
    1f72:	9101      	str	r1, [sp, #4]
		uint16_t i;
	   
		if(SD_Type!=SD_TYPE_V2HC)
    1f74:	4b24      	ldr	r3, [pc, #144]	; (2008 <STACK_SIZE+0x8>)
    1f76:	79db      	ldrb	r3, [r3, #7]
    1f78:	2b04      	cmp	r3, #4
    1f7a:	d003      	beq.n	1f84 <SDCard_ReadSingleBlock+0x18>
		{
			UART3_Write_Text("Not SD_TYPE_V2HC\n");
    1f7c:	4823      	ldr	r0, [pc, #140]	; (200c <STACK_SIZE+0xc>)
    1f7e:	4b24      	ldr	r3, [pc, #144]	; (2010 <STACK_SIZE+0x10>)
    1f80:	4798      	blx	r3
			  addr= addr<<9;
    1f82:	0264      	lsls	r4, r4, #9
		}
		
		//////////////////////////
		// read a block address
		//////////////////////////
		tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1f84:	2201      	movs	r2, #1
    1f86:	0021      	movs	r1, r4
    1f88:	2051      	movs	r0, #81	; 0x51
    1f8a:	4b22      	ldr	r3, [pc, #136]	; (2014 <STACK_SIZE+0x14>)
    1f8c:	4798      	blx	r3
    1f8e:	4b1e      	ldr	r3, [pc, #120]	; (2008 <STACK_SIZE+0x8>)
    1f90:	7258      	strb	r0, [r3, #9]
		
		while(tmp17 !=0)
    1f92:	2800      	cmp	r0, #0
    1f94:	d00c      	beq.n	1fb0 <SDCard_ReadSingleBlock+0x44>
		{
			UART3_Write_Text("Read block address\n");
    1f96:	4e20      	ldr	r6, [pc, #128]	; (2018 <STACK_SIZE+0x18>)
    1f98:	4d1d      	ldr	r5, [pc, #116]	; (2010 <STACK_SIZE+0x10>)
			
			tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1f9a:	4f1e      	ldr	r7, [pc, #120]	; (2014 <STACK_SIZE+0x14>)
			UART3_Write_Text("Read block address\n");
    1f9c:	0030      	movs	r0, r6
    1f9e:	47a8      	blx	r5
			tmp17 = SDCard_WriteCmd(CMD17,addr,0x01);
    1fa0:	2201      	movs	r2, #1
    1fa2:	0021      	movs	r1, r4
    1fa4:	2051      	movs	r0, #81	; 0x51
    1fa6:	47b8      	blx	r7
    1fa8:	4b17      	ldr	r3, [pc, #92]	; (2008 <STACK_SIZE+0x8>)
    1faa:	7258      	strb	r0, [r3, #9]
		while(tmp17 !=0)
    1fac:	2800      	cmp	r0, #0
    1fae:	d1f5      	bne.n	1f9c <SDCard_ReadSingleBlock+0x30>
		}
		delay_ms(1);
    1fb0:	481a      	ldr	r0, [pc, #104]	; (201c <STACK_SIZE+0x1c>)
    1fb2:	4b1b      	ldr	r3, [pc, #108]	; (2020 <STACK_SIZE+0x20>)
    1fb4:	4798      	blx	r3

    
		while (SPI_SD_Read_Byte() != 0xFE)
    1fb6:	4c1b      	ldr	r4, [pc, #108]	; (2024 <STACK_SIZE+0x24>)
    1fb8:	47a0      	blx	r4
    1fba:	28fe      	cmp	r0, #254	; 0xfe
    1fbc:	d1fc      	bne.n	1fb8 <SDCard_ReadSingleBlock+0x4c>
		{
			
		}

		if(tmp17 == 0)
    1fbe:	4b12      	ldr	r3, [pc, #72]	; (2008 <STACK_SIZE+0x8>)
    1fc0:	7a5b      	ldrb	r3, [r3, #9]
    1fc2:	2b00      	cmp	r3, #0
    1fc4:	d00e      	beq.n	1fe4 <SDCard_ReadSingleBlock+0x78>
			  buf[i] = SPI_SD_Send_Byte(0xFF); 
		   }
		}
		
		// Done reading
		UART3_Write_Text("Read complete\n");
    1fc6:	4818      	ldr	r0, [pc, #96]	; (2028 <STACK_SIZE+0x28>)
    1fc8:	4b11      	ldr	r3, [pc, #68]	; (2010 <STACK_SIZE+0x10>)
    1fca:	4798      	blx	r3
		SPI_SD_Send_Byte(0xFF);
    1fcc:	20ff      	movs	r0, #255	; 0xff
    1fce:	4c17      	ldr	r4, [pc, #92]	; (202c <STACK_SIZE+0x2c>)
    1fd0:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    1fd2:	20ff      	movs	r0, #255	; 0xff
    1fd4:	47a0      	blx	r4
		SPI_CS_HIGH();
    1fd6:	2280      	movs	r2, #128	; 0x80
    1fd8:	0052      	lsls	r2, r2, #1
    1fda:	4b15      	ldr	r3, [pc, #84]	; (2030 <STACK_SIZE+0x30>)
    1fdc:	619a      	str	r2, [r3, #24]
		SDCard_SS(1);
		return 0;
}
    1fde:	2000      	movs	r0, #0
    1fe0:	b003      	add	sp, #12
    1fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	       UART3_Write_Text("Reading\n");
    1fe4:	4813      	ldr	r0, [pc, #76]	; (2034 <STACK_SIZE+0x34>)
    1fe6:	4b0a      	ldr	r3, [pc, #40]	; (2010 <STACK_SIZE+0x10>)
    1fe8:	4798      	blx	r3
    1fea:	9b01      	ldr	r3, [sp, #4]
    1fec:	001c      	movs	r4, r3
    1fee:	2280      	movs	r2, #128	; 0x80
    1ff0:	0092      	lsls	r2, r2, #2
    1ff2:	4694      	mov	ip, r2
    1ff4:	4463      	add	r3, ip
    1ff6:	001d      	movs	r5, r3
			  buf[i] = SPI_SD_Send_Byte(0xFF); 
    1ff8:	4e0c      	ldr	r6, [pc, #48]	; (202c <STACK_SIZE+0x2c>)
    1ffa:	20ff      	movs	r0, #255	; 0xff
    1ffc:	47b0      	blx	r6
    1ffe:	7020      	strb	r0, [r4, #0]
    2000:	3401      	adds	r4, #1
		   for (i=0; i<512; i++)
    2002:	42ac      	cmp	r4, r5
    2004:	d1f9      	bne.n	1ffa <SDCard_ReadSingleBlock+0x8e>
    2006:	e7de      	b.n	1fc6 <SDCard_ReadSingleBlock+0x5a>
    2008:	2000045e 	.word	0x2000045e
    200c:	00002c24 	.word	0x00002c24
    2010:	00002505 	.word	0x00002505
    2014:	00001d41 	.word	0x00001d41
    2018:	00002c38 	.word	0x00002c38
    201c:	00001aca 	.word	0x00001aca
    2020:	000003e5 	.word	0x000003e5
    2024:	00002435 	.word	0x00002435
    2028:	00002c58 	.word	0x00002c58
    202c:	00002429 	.word	0x00002429
    2030:	41004400 	.word	0x41004400
    2034:	00002c4c 	.word	0x00002c4c

00002038 <SDCard_ReadMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Read multiple blocks of Data                                          */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_ReadMultipleBlock(uint32_t addr,uint8_t *buf,uint8_t count)
{
    2038:	b5f0      	push	{r4, r5, r6, r7, lr}
    203a:	46d6      	mov	lr, sl
    203c:	464f      	mov	r7, r9
    203e:	4646      	mov	r6, r8
    2040:	b5c0      	push	{r6, r7, lr}
    2042:	4689      	mov	r9, r1
    2044:	4690      	mov	r8, r2
	uint16_t i;
	
	//////////////////////////////////
	// Read Multiple Block Addresses
	/////////////////////////////////
	if(SD_Type!=SD_TYPE_V2HC)
    2046:	4b21      	ldr	r3, [pc, #132]	; (20cc <SDCard_ReadMultipleBlock+0x94>)
    2048:	79db      	ldrb	r3, [r3, #7]
    204a:	2b04      	cmp	r3, #4
    204c:	d000      	beq.n	2050 <SDCard_ReadMultipleBlock+0x18>
	{
		addr = addr<<9;
    204e:	0240      	lsls	r0, r0, #9
	}
 
    // keep transferring data until interrupted
	// by stop transmission command
	if (SDCard_WriteCmd(CMD18,addr,0xFF) != 0x00)
    2050:	22ff      	movs	r2, #255	; 0xff
    2052:	0001      	movs	r1, r0
    2054:	2052      	movs	r0, #82	; 0x52
    2056:	4b1e      	ldr	r3, [pc, #120]	; (20d0 <SDCard_ReadMultipleBlock+0x98>)
    2058:	4798      	blx	r3
	{
		return 1;
    205a:	2301      	movs	r3, #1
	if (SDCard_WriteCmd(CMD18,addr,0xFF) != 0x00)
    205c:	2800      	cmp	r0, #0
    205e:	d005      	beq.n	206c <SDCard_ReadMultipleBlock+0x34>
	
	// Force stop transmission after multiple block read 
	SDCard_WriteCmd(CMD12,0x00,0xFF);
	SPI_SD_Send_Byte(0xFF);
	return 0;
}
    2060:	0018      	movs	r0, r3
    2062:	bc1c      	pop	{r2, r3, r4}
    2064:	4690      	mov	r8, r2
    2066:	4699      	mov	r9, r3
    2068:	46a2      	mov	sl, r4
    206a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		SPI_CS_LOW();
    206c:	2280      	movs	r2, #128	; 0x80
    206e:	0052      	lsls	r2, r2, #1
    2070:	4b18      	ldr	r3, [pc, #96]	; (20d4 <SDCard_ReadMultipleBlock+0x9c>)
    2072:	615a      	str	r2, [r3, #20]
		while(SPI_SD_Send_Byte(0xFF) != 0xFE){;}
    2074:	4f18      	ldr	r7, [pc, #96]	; (20d8 <SDCard_ReadMultipleBlock+0xa0>)
			*buf++ = SPI_SD_Send_Byte(0xFF);
    2076:	003e      	movs	r6, r7
		SPI_SD_Send_Byte(0xFF);
    2078:	46ba      	mov	sl, r7
		while(SPI_SD_Send_Byte(0xFF) != 0xFE){;}
    207a:	20ff      	movs	r0, #255	; 0xff
    207c:	47b8      	blx	r7
    207e:	28fe      	cmp	r0, #254	; 0xfe
    2080:	d1fb      	bne.n	207a <SDCard_ReadMultipleBlock+0x42>
    2082:	464c      	mov	r4, r9
    2084:	2380      	movs	r3, #128	; 0x80
    2086:	009b      	lsls	r3, r3, #2
    2088:	469c      	mov	ip, r3
    208a:	44e1      	add	r9, ip
    208c:	464d      	mov	r5, r9
			*buf++ = SPI_SD_Send_Byte(0xFF);
    208e:	20ff      	movs	r0, #255	; 0xff
    2090:	47b0      	blx	r6
    2092:	7020      	strb	r0, [r4, #0]
    2094:	3401      	adds	r4, #1
		for (i=0; i<512; i++)
    2096:	42a5      	cmp	r5, r4
    2098:	d1f9      	bne.n	208e <SDCard_ReadMultipleBlock+0x56>
		SPI_SD_Send_Byte(0xFF);
    209a:	20ff      	movs	r0, #255	; 0xff
    209c:	47d0      	blx	sl
		SPI_SD_Send_Byte(0xFF);
    209e:	20ff      	movs	r0, #255	; 0xff
    20a0:	47d0      	blx	sl
	}while (--count);
    20a2:	4643      	mov	r3, r8
    20a4:	3b01      	subs	r3, #1
    20a6:	b2db      	uxtb	r3, r3
    20a8:	4698      	mov	r8, r3
    20aa:	2b00      	cmp	r3, #0
    20ac:	d1e5      	bne.n	207a <SDCard_ReadMultipleBlock+0x42>
		SPI_CS_HIGH();
    20ae:	2280      	movs	r2, #128	; 0x80
    20b0:	0052      	lsls	r2, r2, #1
    20b2:	4b08      	ldr	r3, [pc, #32]	; (20d4 <SDCard_ReadMultipleBlock+0x9c>)
    20b4:	619a      	str	r2, [r3, #24]
	SDCard_WriteCmd(CMD12,0x00,0xFF);
    20b6:	3a01      	subs	r2, #1
    20b8:	2100      	movs	r1, #0
    20ba:	204c      	movs	r0, #76	; 0x4c
    20bc:	4b04      	ldr	r3, [pc, #16]	; (20d0 <SDCard_ReadMultipleBlock+0x98>)
    20be:	4798      	blx	r3
	SPI_SD_Send_Byte(0xFF);
    20c0:	20ff      	movs	r0, #255	; 0xff
    20c2:	4b05      	ldr	r3, [pc, #20]	; (20d8 <SDCard_ReadMultipleBlock+0xa0>)
    20c4:	4798      	blx	r3
	return 0;
    20c6:	4643      	mov	r3, r8
    20c8:	e7ca      	b.n	2060 <SDCard_ReadMultipleBlock+0x28>
    20ca:	46c0      	nop			; (mov r8, r8)
    20cc:	2000045e 	.word	0x2000045e
    20d0:	00001d41 	.word	0x00001d41
    20d4:	41004400 	.word	0x41004400
    20d8:	00002429 	.word	0x00002429

000020dc <SDCard_WriteSingleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Single Block of Data                                            */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteSingleBlock(uint32_t addr,const uint8_t *buf)
{
    20dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20de:	0004      	movs	r4, r0
    20e0:	000d      	movs	r5, r1
		uint16_t i;

        //////////////////////////////////
        // Write Single Block Address
        /////////////////////////////////
        if(SD_Type!=SD_TYPE_V2HC)
    20e2:	4b2f      	ldr	r3, [pc, #188]	; (21a0 <SDCard_WriteSingleBlock+0xc4>)
    20e4:	79db      	ldrb	r3, [r3, #7]
    20e6:	2b04      	cmp	r3, #4
    20e8:	d000      	beq.n	20ec <SDCard_WriteSingleBlock+0x10>
        {
             addr=addr<<9 ;
    20ea:	0244      	lsls	r4, r0, #9
        }

        tmp_24 = SDCard_WriteCmd(CMD24,addr,0x01);
    20ec:	2201      	movs	r2, #1
    20ee:	0021      	movs	r1, r4
    20f0:	2058      	movs	r0, #88	; 0x58
    20f2:	4b2c      	ldr	r3, [pc, #176]	; (21a4 <SDCard_WriteSingleBlock+0xc8>)
    20f4:	4798      	blx	r3
    20f6:	4b2a      	ldr	r3, [pc, #168]	; (21a0 <SDCard_WriteSingleBlock+0xc4>)
    20f8:	7298      	strb	r0, [r3, #10]
		
		
        while(tmp_24 != 0)
    20fa:	2800      	cmp	r0, #0
    20fc:	d008      	beq.n	2110 <SDCard_WriteSingleBlock+0x34>
		{
        	tmp_24 = SDCard_WriteCmd(CMD24,addr,0x01);
    20fe:	4f29      	ldr	r7, [pc, #164]	; (21a4 <SDCard_WriteSingleBlock+0xc8>)
    2100:	001e      	movs	r6, r3
    2102:	2201      	movs	r2, #1
    2104:	0021      	movs	r1, r4
    2106:	2058      	movs	r0, #88	; 0x58
    2108:	47b8      	blx	r7
    210a:	72b0      	strb	r0, [r6, #10]
        while(tmp_24 != 0)
    210c:	2800      	cmp	r0, #0
    210e:	d1f8      	bne.n	2102 <SDCard_WriteSingleBlock+0x26>
		SPI_CS_LOW();
    2110:	2280      	movs	r2, #128	; 0x80
    2112:	0052      	lsls	r2, r2, #1
    2114:	4b24      	ldr	r3, [pc, #144]	; (21a8 <SDCard_WriteSingleBlock+0xcc>)
    2116:	615a      	str	r2, [r3, #20]
        }

        SDCard_SS(0);
		
		//Wait until SD Card is ready
		SPI_SD_Send_Byte(0xFF);
    2118:	20ff      	movs	r0, #255	; 0xff
    211a:	4c24      	ldr	r4, [pc, #144]	; (21ac <SDCard_WriteSingleBlock+0xd0>)
    211c:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    211e:	20ff      	movs	r0, #255	; 0xff
    2120:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    2122:	20ff      	movs	r0, #255	; 0xff
    2124:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFE);
    2126:	20fe      	movs	r0, #254	; 0xfe
    2128:	47a0      	blx	r4
    212a:	002c      	movs	r4, r5
    212c:	2380      	movs	r3, #128	; 0x80
    212e:	009b      	lsls	r3, r3, #2
    2130:	469c      	mov	ip, r3
    2132:	4465      	add	r5, ip

		for (i=0; i<512; i++)
		{
			SPI_SD_Send_Byte(buf[i]);
    2134:	4e1d      	ldr	r6, [pc, #116]	; (21ac <SDCard_WriteSingleBlock+0xd0>)
    2136:	7820      	ldrb	r0, [r4, #0]
    2138:	47b0      	blx	r6
    213a:	3401      	adds	r4, #1
		for (i=0; i<512; i++)
    213c:	42a5      	cmp	r5, r4
    213e:	d1fa      	bne.n	2136 <SDCard_WriteSingleBlock+0x5a>
		}
		
	    // Send CRC Info (dummy)
		SPI_SD_Send_Byte(0xFF);
    2140:	20ff      	movs	r0, #255	; 0xff
    2142:	4c1a      	ldr	r4, [pc, #104]	; (21ac <SDCard_WriteSingleBlock+0xd0>)
    2144:	47a0      	blx	r4
		SPI_SD_Send_Byte(0xFF);
    2146:	20ff      	movs	r0, #255	; 0xff
    2148:	47a0      	blx	r4
		temp = SPI_SD_Send_Byte(0xFF);
    214a:	20ff      	movs	r0, #255	; 0xff
    214c:	47a0      	blx	r4
		temp &= 0x1F;
		
		if (temp != 0x05)
    214e:	231f      	movs	r3, #31
    2150:	4018      	ands	r0, r3
    2152:	2805      	cmp	r0, #5
    2154:	d10f      	bne.n	2176 <SDCard_WriteSingleBlock+0x9a>
    2156:	4c16      	ldr	r4, [pc, #88]	; (21b0 <SDCard_WriteSingleBlock+0xd4>)
			UART3_Write_Text("CRC Write Fail");
			SDCard_SS(1);
			return 1;
		}

		while (SPI_SD_Send_Byte(0xFF) == 0x00)
    2158:	4d14      	ldr	r5, [pc, #80]	; (21ac <SDCard_WriteSingleBlock+0xd0>)
    215a:	20ff      	movs	r0, #255	; 0xff
    215c:	47a8      	blx	r5
    215e:	2800      	cmp	r0, #0
    2160:	d112      	bne.n	2188 <SDCard_WriteSingleBlock+0xac>
    2162:	3c01      	subs	r4, #1
    2164:	b2a4      	uxth	r4, r4
		{
			 retry++;
			 if(retry>0xfffe)
    2166:	2c00      	cmp	r4, #0
    2168:	d1f7      	bne.n	215a <SDCard_WriteSingleBlock+0x7e>
		SPI_CS_HIGH();
    216a:	2280      	movs	r2, #128	; 0x80
    216c:	0052      	lsls	r2, r2, #1
    216e:	4b0e      	ldr	r3, [pc, #56]	; (21a8 <SDCard_WriteSingleBlock+0xcc>)
    2170:	619a      	str	r2, [r3, #24]
			{

			  SDCard_SS(1);
			   return 1 ;
    2172:	2001      	movs	r0, #1
    2174:	e013      	b.n	219e <SDCard_WriteSingleBlock+0xc2>
			UART3_Write_Text("CRC Write Fail");
    2176:	480f      	ldr	r0, [pc, #60]	; (21b4 <SDCard_WriteSingleBlock+0xd8>)
    2178:	4b0f      	ldr	r3, [pc, #60]	; (21b8 <SDCard_WriteSingleBlock+0xdc>)
    217a:	4798      	blx	r3
		SPI_CS_HIGH();
    217c:	2280      	movs	r2, #128	; 0x80
    217e:	0052      	lsls	r2, r2, #1
    2180:	4b09      	ldr	r3, [pc, #36]	; (21a8 <SDCard_WriteSingleBlock+0xcc>)
    2182:	619a      	str	r2, [r3, #24]
			return 1;
    2184:	2001      	movs	r0, #1
    2186:	e00a      	b.n	219e <SDCard_WriteSingleBlock+0xc2>
		SPI_CS_HIGH();
    2188:	2280      	movs	r2, #128	; 0x80
    218a:	0052      	lsls	r2, r2, #1
    218c:	4b06      	ldr	r3, [pc, #24]	; (21a8 <SDCard_WriteSingleBlock+0xcc>)
    218e:	619a      	str	r2, [r3, #24]
			 }
		}
		
		SDCard_SS(1);
		SPI_SD_Send_Byte(0xFF);
    2190:	20ff      	movs	r0, #255	; 0xff
    2192:	4b06      	ldr	r3, [pc, #24]	; (21ac <SDCard_WriteSingleBlock+0xd0>)
    2194:	4798      	blx	r3
		UART3_Write_Text("Write Complete\n");
    2196:	4809      	ldr	r0, [pc, #36]	; (21bc <SDCard_WriteSingleBlock+0xe0>)
    2198:	4b07      	ldr	r3, [pc, #28]	; (21b8 <SDCard_WriteSingleBlock+0xdc>)
    219a:	4798      	blx	r3
		return 0;
    219c:	2000      	movs	r0, #0
}
    219e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    21a0:	2000045e 	.word	0x2000045e
    21a4:	00001d41 	.word	0x00001d41
    21a8:	41004400 	.word	0x41004400
    21ac:	00002429 	.word	0x00002429
    21b0:	0000ffff 	.word	0x0000ffff
    21b4:	00002c68 	.word	0x00002c68
    21b8:	00002505 	.word	0x00002505
    21bc:	00002c78 	.word	0x00002c78

000021c0 <SDCard_WriteMultipleBlock>:

/*-----------------------------------------------------------------------*/
/* Write Multiple Blocks of Data                                         */
/*-----------------------------------------------------------------------*/
uint8_t SDCard_WriteMultipleBlock(uint32_t addr, uint8_t *buf, uint8_t count)
{
    21c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    21c2:	46d6      	mov	lr, sl
    21c4:	464f      	mov	r7, r9
    21c6:	4646      	mov	r6, r8
    21c8:	b5c0      	push	{r6, r7, lr}
    21ca:	0004      	movs	r4, r0
    21cc:	4688      	mov	r8, r1
    21ce:	0017      	movs	r7, r2
     uint16_t i;
	 uint8_t tmp;
	 
     if(SD_Type!=SD_TYPE_V2HC) 
    21d0:	4b33      	ldr	r3, [pc, #204]	; (22a0 <SDCard_WriteMultipleBlock+0xe0>)
    21d2:	79db      	ldrb	r3, [r3, #7]
    21d4:	2b04      	cmp	r3, #4
    21d6:	d04a      	beq.n	226e <SDCard_WriteMultipleBlock+0xae>
     {
          addr=addr<<9;
    21d8:	0244      	lsls	r4, r0, #9
     }
	 
	 if(SD_Type!=SD_TYPE_MMC)
    21da:	2b00      	cmp	r3, #0
    21dc:	d147      	bne.n	226e <SDCard_WriteMultipleBlock+0xae>
     ////////////////////////////////////
     // Write Multiple Block Addresses
     ///////////////////////////////////
	 
	 // try to write blocks of data until stop transmission received
	 if (SDCard_WriteCmd(CMD25,addr,0xFF) != 0x00) 
    21de:	22ff      	movs	r2, #255	; 0xff
    21e0:	0021      	movs	r1, r4
    21e2:	2059      	movs	r0, #89	; 0x59
    21e4:	4b2f      	ldr	r3, [pc, #188]	; (22a4 <SDCard_WriteMultipleBlock+0xe4>)
    21e6:	4798      	blx	r3
    21e8:	2800      	cmp	r0, #0
    21ea:	d146      	bne.n	227a <SDCard_WriteMultipleBlock+0xba>
		SPI_CS_LOW();
    21ec:	2280      	movs	r2, #128	; 0x80
    21ee:	0052      	lsls	r2, r2, #1
    21f0:	4b2d      	ldr	r3, [pc, #180]	; (22a8 <SDCard_WriteMultipleBlock+0xe8>)
    21f2:	615a      	str	r2, [r3, #20]
	 }
	 
	 SDCard_SS(0); 

	 // Wait until SD Card is ready
	 SPI_SD_Send_Byte(0xFF);
    21f4:	20ff      	movs	r0, #255	; 0xff
    21f6:	4c2d      	ldr	r4, [pc, #180]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    21f8:	47a0      	blx	r4
	 SPI_SD_Send_Byte(0xFF);
    21fa:	20ff      	movs	r0, #255	; 0xff
    21fc:	47a0      	blx	r4
	 
	 // Write Data
	 do
	 {
		 // Start block
		 SPI_SD_Send_Byte (0xFC); 
    21fe:	4b2b      	ldr	r3, [pc, #172]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    2200:	469a      	mov	sl, r3
		 
		 // Write Data
		 for (i=0; i<512; i++) 
		 {
				 SPI_SD_Send_Byte(*buf++);
    2202:	001e      	movs	r6, r3
		 }
		 
		 // Send CRC info (dummy)
		 SPI_SD_Send_Byte(0xFF); 
    2204:	4699      	mov	r9, r3
		 SPI_SD_Send_Byte (0xFC); 
    2206:	20fc      	movs	r0, #252	; 0xfc
    2208:	47d0      	blx	sl
    220a:	4644      	mov	r4, r8
    220c:	2380      	movs	r3, #128	; 0x80
    220e:	009b      	lsls	r3, r3, #2
    2210:	469c      	mov	ip, r3
    2212:	44e0      	add	r8, ip
    2214:	4645      	mov	r5, r8
				 SPI_SD_Send_Byte(*buf++);
    2216:	7820      	ldrb	r0, [r4, #0]
    2218:	47b0      	blx	r6
    221a:	3401      	adds	r4, #1
		 for (i=0; i<512; i++) 
    221c:	42ac      	cmp	r4, r5
    221e:	d1fa      	bne.n	2216 <SDCard_WriteMultipleBlock+0x56>
		 SPI_SD_Send_Byte(0xFF); 
    2220:	20ff      	movs	r0, #255	; 0xff
    2222:	47c8      	blx	r9
		 SPI_SD_Send_Byte(0xFF);
    2224:	20ff      	movs	r0, #255	; 0xff
    2226:	47c8      	blx	r9
		 
		 tmp = SPI_SD_Send_Byte(0xFF); 
    2228:	20ff      	movs	r0, #255	; 0xff
    222a:	47c8      	blx	r9
		 tmp &= 0x1F;
		 
		 if(tmp != 0x05)
    222c:	231f      	movs	r3, #31
    222e:	4018      	ands	r0, r3
    2230:	2805      	cmp	r0, #5
    2232:	d12b      	bne.n	228c <SDCard_WriteMultipleBlock+0xcc>
		 {   
			UART3_Write_Text("CRC Multiple Write Failed\n");
			SDCard_SS(1);
			return 1;
		 }
		 while(SPI_SD_Send_Byte (0xFF) == 0x00){;} // BUSY wait
    2234:	4c1d      	ldr	r4, [pc, #116]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    2236:	20ff      	movs	r0, #255	; 0xff
    2238:	47a0      	blx	r4
    223a:	2800      	cmp	r0, #0
    223c:	d0fb      	beq.n	2236 <SDCard_WriteMultipleBlock+0x76>
	 }while (--count);
    223e:	3f01      	subs	r7, #1
    2240:	b2ff      	uxtb	r7, r7
    2242:	2f00      	cmp	r7, #0
    2244:	d1df      	bne.n	2206 <SDCard_WriteMultipleBlock+0x46>
	 
	 // Send 'Stop Tran' Token
	 SPI_SD_Send_Byte (0xFD);
    2246:	20fd      	movs	r0, #253	; 0xfd
    2248:	4b18      	ldr	r3, [pc, #96]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    224a:	4798      	blx	r3
	 while (SPI_SD_Send_Byte (0xFF) == 0x00)
    224c:	4c17      	ldr	r4, [pc, #92]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    224e:	20ff      	movs	r0, #255	; 0xff
    2250:	47a0      	blx	r4
    2252:	2800      	cmp	r0, #0
    2254:	d0fb      	beq.n	224e <SDCard_WriteMultipleBlock+0x8e>
		SPI_CS_HIGH();
    2256:	2280      	movs	r2, #128	; 0x80
    2258:	0052      	lsls	r2, r2, #1
    225a:	4b13      	ldr	r3, [pc, #76]	; (22a8 <SDCard_WriteMultipleBlock+0xe8>)
    225c:	619a      	str	r2, [r3, #24]
	 {
		 
	 }
	 
	 SDCard_SS(1);
	 SPI_SD_Send_Byte(0xFF);
    225e:	20ff      	movs	r0, #255	; 0xff
    2260:	4b12      	ldr	r3, [pc, #72]	; (22ac <SDCard_WriteMultipleBlock+0xec>)
    2262:	4798      	blx	r3
	 UART3_Write_Text("Write Multiple Complete\n");
    2264:	4812      	ldr	r0, [pc, #72]	; (22b0 <SDCard_WriteMultipleBlock+0xf0>)
    2266:	4b13      	ldr	r3, [pc, #76]	; (22b4 <SDCard_WriteMultipleBlock+0xf4>)
    2268:	4798      	blx	r3
	 return 0;
    226a:	0038      	movs	r0, r7
    226c:	e009      	b.n	2282 <SDCard_WriteMultipleBlock+0xc2>
        tmp=SDCard_WriteCmd(CMD23,count,0x00);
    226e:	2200      	movs	r2, #0
    2270:	0039      	movs	r1, r7
    2272:	2057      	movs	r0, #87	; 0x57
    2274:	4b0b      	ldr	r3, [pc, #44]	; (22a4 <SDCard_WriteMultipleBlock+0xe4>)
    2276:	4798      	blx	r3
    2278:	e7b1      	b.n	21de <SDCard_WriteMultipleBlock+0x1e>
		 UART3_Write_Text("Write Multiple Block Address Failed\n");
    227a:	480f      	ldr	r0, [pc, #60]	; (22b8 <SDCard_WriteMultipleBlock+0xf8>)
    227c:	4b0d      	ldr	r3, [pc, #52]	; (22b4 <SDCard_WriteMultipleBlock+0xf4>)
    227e:	4798      	blx	r3
		 return 1;
    2280:	2001      	movs	r0, #1
}
    2282:	bc1c      	pop	{r2, r3, r4}
    2284:	4690      	mov	r8, r2
    2286:	4699      	mov	r9, r3
    2288:	46a2      	mov	sl, r4
    228a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			UART3_Write_Text("CRC Multiple Write Failed\n");
    228c:	480b      	ldr	r0, [pc, #44]	; (22bc <SDCard_WriteMultipleBlock+0xfc>)
    228e:	4b09      	ldr	r3, [pc, #36]	; (22b4 <SDCard_WriteMultipleBlock+0xf4>)
    2290:	4798      	blx	r3
		SPI_CS_HIGH();
    2292:	2280      	movs	r2, #128	; 0x80
    2294:	0052      	lsls	r2, r2, #1
    2296:	4b04      	ldr	r3, [pc, #16]	; (22a8 <SDCard_WriteMultipleBlock+0xe8>)
    2298:	619a      	str	r2, [r3, #24]
			return 1;
    229a:	2001      	movs	r0, #1
    229c:	e7f1      	b.n	2282 <SDCard_WriteMultipleBlock+0xc2>
    229e:	46c0      	nop			; (mov r8, r8)
    22a0:	2000045e 	.word	0x2000045e
    22a4:	00001d41 	.word	0x00001d41
    22a8:	41004400 	.word	0x41004400
    22ac:	00002429 	.word	0x00002429
    22b0:	00002ccc 	.word	0x00002ccc
    22b4:	00002505 	.word	0x00002505
    22b8:	00002c88 	.word	0x00002c88
    22bc:	00002cb0 	.word	0x00002cb0

000022c0 <SPI_Initialize_Fast>:
 *
 ******************************************************************************/
void SPI_Initialize_Fast(void)
{
	  // Wait Sync
	  while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    22c0:	4a20      	ldr	r2, [pc, #128]	; (2344 <SPI_Initialize_Fast+0x84>)
    22c2:	69d3      	ldr	r3, [r2, #28]
    22c4:	079b      	lsls	r3, r3, #30
    22c6:	d4fc      	bmi.n	22c2 <SPI_Initialize_Fast+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM1;								
    22c8:	4a1f      	ldr	r2, [pc, #124]	; (2348 <SPI_Initialize_Fast+0x88>)
    22ca:	6a13      	ldr	r3, [r2, #32]
    22cc:	2108      	movs	r1, #8
    22ce:	430b      	orrs	r3, r1
    22d0:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    22d2:	4a1e      	ldr	r2, [pc, #120]	; (234c <SPI_Initialize_Fast+0x8c>)
    22d4:	4b1e      	ldr	r3, [pc, #120]	; (2350 <SPI_Initialize_Fast+0x90>)
    22d6:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    22d8:	001a      	movs	r2, r3
    22da:	7853      	ldrb	r3, [r2, #1]
    22dc:	09db      	lsrs	r3, r3, #7
    22de:	d1fc      	bne.n	22da <SPI_Initialize_Fast+0x1a>
	  
      /* -------------------------------------------------
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM5 SPI MASTER MISO
	  PORT->Group[0].WRCONFIG.reg =
    22e0:	4b1c      	ldr	r3, [pc, #112]	; (2354 <SPI_Initialize_Fast+0x94>)
    22e2:	4a1d      	ldr	r2, [pc, #116]	; (2358 <SPI_Initialize_Fast+0x98>)
    22e4:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_HWSEL |						 //Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_INEN |									 //Enable input on this pin MISO
	       PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA18) >> 16)); //Selecting which pin is configured  PA17 
	       
	       //Using the WRCONFIG register to bulk configure both PB22 and PB23 for being configured the SERCOM5 SPI MASTER MOSI and SCK pins
	       PORT->Group[0].WRCONFIG.reg =
    22e6:	4a1d      	ldr	r2, [pc, #116]	; (235c <SPI_Initialize_Fast+0x9c>)
    22e8:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_PMUXEN |							 //Enables the PMUX for the pins
	       PORT_WRCONFIG_HWSEL |												//Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_PINMASK ((uint16_t)((PORT_PA16 | PORT_PA19) >> 16));	//Selecting which pin is configured
	         
	       // Set the drive strength to strong
	       PORT->Group[0].PINCFG[19].bit.DRVSTR = 1;
    22ea:	2153      	movs	r1, #83	; 0x53
    22ec:	5c5a      	ldrb	r2, [r3, r1]
    22ee:	2040      	movs	r0, #64	; 0x40
    22f0:	4302      	orrs	r2, r0
    22f2:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM1->SPI.CTRLA.bit.ENABLE = 0;
    22f4:	4a13      	ldr	r2, [pc, #76]	; (2344 <SPI_Initialize_Fast+0x84>)
    22f6:	6813      	ldr	r3, [r2, #0]
    22f8:	3951      	subs	r1, #81	; 0x51
    22fa:	438b      	bics	r3, r1
    22fc:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM1->SPI.SYNCBUSY.bit.SWRST)
    22fe:	69d3      	ldr	r3, [r2, #28]
    2300:	07db      	lsls	r3, r3, #31
    2302:	d4fc      	bmi.n	22fe <SPI_Initialize_Fast+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM1->SPI.CTRLA.bit.SWRST = 1;
    2304:	4a0f      	ldr	r2, [pc, #60]	; (2344 <SPI_Initialize_Fast+0x84>)
    2306:	6813      	ldr	r3, [r2, #0]
    2308:	2101      	movs	r1, #1
    230a:	430b      	orrs	r3, r1
    230c:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM1->SPI.CTRLA.bit.SWRST)
    230e:	6813      	ldr	r3, [r2, #0]
    2310:	07db      	lsls	r3, r3, #31
    2312:	d4fc      	bmi.n	230e <SPI_Initialize_Fast+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM1->SPI.SYNCBUSY.bit.SWRST || SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    2314:	4a0b      	ldr	r2, [pc, #44]	; (2344 <SPI_Initialize_Fast+0x84>)
    2316:	69d3      	ldr	r3, [r2, #28]
    2318:	07db      	lsls	r3, r3, #31
    231a:	d4fc      	bmi.n	2316 <SPI_Initialize_Fast+0x56>
    231c:	69d3      	ldr	r3, [r2, #28]
    231e:	079b      	lsls	r3, r3, #30
    2320:	d4f9      	bmi.n	2316 <SPI_Initialize_Fast+0x56>

	   SERCOM1->SPI.CTRLA.reg = 
    2322:	4b08      	ldr	r3, [pc, #32]	; (2344 <SPI_Initialize_Fast+0x84>)
    2324:	4a0e      	ldr	r2, [pc, #56]	; (2360 <SPI_Initialize_Fast+0xa0>)
    2326:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM1->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    2328:	2280      	movs	r2, #128	; 0x80
    232a:	0292      	lsls	r2, r2, #10
    232c:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 12000000)) - 1;	//Calculate BAUD value
	   SERCOM1->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    232e:	2201      	movs	r2, #1
    2330:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM1->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    2332:	681a      	ldr	r2, [r3, #0]
    2334:	2102      	movs	r1, #2
    2336:	430a      	orrs	r2, r1
    2338:	601a      	str	r2, [r3, #0]
	    while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    233a:	001a      	movs	r2, r3
    233c:	69d3      	ldr	r3, [r2, #28]
    233e:	079b      	lsls	r3, r3, #30
    2340:	d4fc      	bmi.n	233c <SPI_Initialize_Fast+0x7c>
}
    2342:	4770      	bx	lr
    2344:	42000c00 	.word	0x42000c00
    2348:	40000400 	.word	0x40000400
    234c:	00004015 	.word	0x00004015
    2350:	40000c00 	.word	0x40000c00
    2354:	41004400 	.word	0x41004400
    2358:	d2030004 	.word	0xd2030004
    235c:	d2010009 	.word	0xd2010009
    2360:	0023000c 	.word	0x0023000c

00002364 <SPI_Initialize_Slow>:
 *
 ******************************************************************************/
void SPI_Initialize_Slow(void)
{
	  // Wait Sync
	  while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    2364:	4a20      	ldr	r2, [pc, #128]	; (23e8 <SPI_Initialize_Slow+0x84>)
    2366:	69d3      	ldr	r3, [r2, #28]
    2368:	079b      	lsls	r3, r3, #30
    236a:	d4fc      	bmi.n	2366 <SPI_Initialize_Slow+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM1;								
    236c:	4a1f      	ldr	r2, [pc, #124]	; (23ec <SPI_Initialize_Slow+0x88>)
    236e:	6a13      	ldr	r3, [r2, #32]
    2370:	2108      	movs	r1, #8
    2372:	430b      	orrs	r3, r1
    2374:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    2376:	4a1e      	ldr	r2, [pc, #120]	; (23f0 <SPI_Initialize_Slow+0x8c>)
    2378:	4b1e      	ldr	r3, [pc, #120]	; (23f4 <SPI_Initialize_Slow+0x90>)
    237a:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    237c:	001a      	movs	r2, r3
    237e:	7853      	ldrb	r3, [r2, #1]
    2380:	09db      	lsrs	r3, r3, #7
    2382:	d1fc      	bne.n	237e <SPI_Initialize_Slow+0x1a>
	  
      /* -------------------------------------------------
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM5 SPI MASTER MISO
	  PORT->Group[0].WRCONFIG.reg =
    2384:	4b1c      	ldr	r3, [pc, #112]	; (23f8 <SPI_Initialize_Slow+0x94>)
    2386:	4a1d      	ldr	r2, [pc, #116]	; (23fc <SPI_Initialize_Slow+0x98>)
    2388:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_HWSEL |						 //Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_INEN |									 //Enable input on this pin MISO
	       PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA18) >> 16)); //Selecting which pin is configured  PA17 
	       
	       //Using the WRCONFIG register to bulk configure both PB22 and PB23 for being configured the SERCOM5 SPI MASTER MOSI and SCK pins
	       PORT->Group[0].WRCONFIG.reg =
    238a:	4a1d      	ldr	r2, [pc, #116]	; (2400 <SPI_Initialize_Slow+0x9c>)
    238c:	629a      	str	r2, [r3, #40]	; 0x28
	       PORT_WRCONFIG_PMUXEN |							 //Enables the PMUX for the pins
	       PORT_WRCONFIG_HWSEL |												//Select the correct pin configurations for 16-31
	       PORT_WRCONFIG_PINMASK ((uint16_t)((PORT_PA16 | PORT_PA19) >> 16));	//Selecting which pin is configured
	         
	       // Set the drive strength to strong
	       PORT->Group[0].PINCFG[19].bit.DRVSTR = 1;
    238e:	2153      	movs	r1, #83	; 0x53
    2390:	5c5a      	ldrb	r2, [r3, r1]
    2392:	2040      	movs	r0, #64	; 0x40
    2394:	4302      	orrs	r2, r0
    2396:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM1->SPI.CTRLA.bit.ENABLE = 0;
    2398:	4a13      	ldr	r2, [pc, #76]	; (23e8 <SPI_Initialize_Slow+0x84>)
    239a:	6813      	ldr	r3, [r2, #0]
    239c:	3951      	subs	r1, #81	; 0x51
    239e:	438b      	bics	r3, r1
    23a0:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM1->SPI.SYNCBUSY.bit.SWRST)
    23a2:	69d3      	ldr	r3, [r2, #28]
    23a4:	07db      	lsls	r3, r3, #31
    23a6:	d4fc      	bmi.n	23a2 <SPI_Initialize_Slow+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM1->SPI.CTRLA.bit.SWRST = 1;
    23a8:	4a0f      	ldr	r2, [pc, #60]	; (23e8 <SPI_Initialize_Slow+0x84>)
    23aa:	6813      	ldr	r3, [r2, #0]
    23ac:	2101      	movs	r1, #1
    23ae:	430b      	orrs	r3, r1
    23b0:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM1->SPI.CTRLA.bit.SWRST)
    23b2:	6813      	ldr	r3, [r2, #0]
    23b4:	07db      	lsls	r3, r3, #31
    23b6:	d4fc      	bmi.n	23b2 <SPI_Initialize_Slow+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM1->SPI.SYNCBUSY.bit.SWRST || SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    23b8:	4a0b      	ldr	r2, [pc, #44]	; (23e8 <SPI_Initialize_Slow+0x84>)
    23ba:	69d3      	ldr	r3, [r2, #28]
    23bc:	07db      	lsls	r3, r3, #31
    23be:	d4fc      	bmi.n	23ba <SPI_Initialize_Slow+0x56>
    23c0:	69d3      	ldr	r3, [r2, #28]
    23c2:	079b      	lsls	r3, r3, #30
    23c4:	d4f9      	bmi.n	23ba <SPI_Initialize_Slow+0x56>

	   SERCOM1->SPI.CTRLA.reg = 
    23c6:	4b08      	ldr	r3, [pc, #32]	; (23e8 <SPI_Initialize_Slow+0x84>)
    23c8:	4a0e      	ldr	r2, [pc, #56]	; (2404 <SPI_Initialize_Slow+0xa0>)
    23ca:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM1->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    23cc:	2280      	movs	r2, #128	; 0x80
    23ce:	0292      	lsls	r2, r2, #10
    23d0:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 400000)) - 1;	//Calculate BAUD value
	   SERCOM1->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    23d2:	223b      	movs	r2, #59	; 0x3b
    23d4:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM1->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    23d6:	681a      	ldr	r2, [r3, #0]
    23d8:	2102      	movs	r1, #2
    23da:	430a      	orrs	r2, r1
    23dc:	601a      	str	r2, [r3, #0]
	    while(SERCOM1->SPI.SYNCBUSY.bit.ENABLE);
    23de:	001a      	movs	r2, r3
    23e0:	69d3      	ldr	r3, [r2, #28]
    23e2:	079b      	lsls	r3, r3, #30
    23e4:	d4fc      	bmi.n	23e0 <SPI_Initialize_Slow+0x7c>
}
    23e6:	4770      	bx	lr
    23e8:	42000c00 	.word	0x42000c00
    23ec:	40000400 	.word	0x40000400
    23f0:	00004015 	.word	0x00004015
    23f4:	40000c00 	.word	0x40000c00
    23f8:	41004400 	.word	0x41004400
    23fc:	d2030004 	.word	0xd2030004
    2400:	d2010009 	.word	0xd2010009
    2404:	0023000c 	.word	0x0023000c

00002408 <SPI_Exchange8bit>:
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_Exchange8bit(uint8_t data)
{
	while(SERCOM1->SPI.INTFLAG.bit.DRE == 0);
    2408:	4a06      	ldr	r2, [pc, #24]	; (2424 <SPI_Exchange8bit+0x1c>)
    240a:	7e13      	ldrb	r3, [r2, #24]
    240c:	07db      	lsls	r3, r3, #31
    240e:	d5fc      	bpl.n	240a <SPI_Exchange8bit+0x2>
	SERCOM1->SPI.DATA.reg = data;
    2410:	4b04      	ldr	r3, [pc, #16]	; (2424 <SPI_Exchange8bit+0x1c>)
    2412:	6298      	str	r0, [r3, #40]	; 0x28
	
	while(SERCOM1->SPI.INTFLAG.bit.RXC == 0);
    2414:	001a      	movs	r2, r3
    2416:	7e13      	ldrb	r3, [r2, #24]
    2418:	075b      	lsls	r3, r3, #29
    241a:	d5fc      	bpl.n	2416 <SPI_Exchange8bit+0xe>
	return (uint8_t)SERCOM1->SPI.DATA.reg;
    241c:	4b01      	ldr	r3, [pc, #4]	; (2424 <SPI_Exchange8bit+0x1c>)
    241e:	6a98      	ldr	r0, [r3, #40]	; 0x28
    2420:	b2c0      	uxtb	r0, r0
}
    2422:	4770      	bx	lr
    2424:	42000c00 	.word	0x42000c00

00002428 <SPI_SD_Send_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Send_Byte(uint8_t byte_val)
{
    2428:	b510      	push	{r4, lr}
	uint8_t data;
	
	data = SPI_Exchange8bit(byte_val);
    242a:	4b01      	ldr	r3, [pc, #4]	; (2430 <SPI_SD_Send_Byte+0x8>)
    242c:	4798      	blx	r3
	return data;
}
    242e:	bd10      	pop	{r4, pc}
    2430:	00002409 	.word	0x00002409

00002434 <SPI_SD_Read_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Read_Byte(void)
{
    2434:	b510      	push	{r4, lr}
	uint8_t data;

	data = SPI_Exchange8bit(0xff);
    2436:	20ff      	movs	r0, #255	; 0xff
    2438:	4b01      	ldr	r3, [pc, #4]	; (2440 <SPI_SD_Read_Byte+0xc>)
    243a:	4798      	blx	r3
	return data;
    243c:	bd10      	pop	{r4, pc}
    243e:	46c0      	nop			; (mov r8, r8)
    2440:	00002409 	.word	0x00002409

00002444 <UART3_Init>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Init(uint32_t baud)
{
    2444:	b570      	push	{r4, r5, r6, lr}
	
	/* -------------------------------------------------
	* 1) Enable bus clock to APBC mask
	*/
	REG_PM_APBCMASK |=  PM_APBCMASK_SERCOM3;
    2446:	4a21      	ldr	r2, [pc, #132]	; (24cc <UART3_Init+0x88>)
    2448:	6813      	ldr	r3, [r2, #0]
    244a:	2120      	movs	r1, #32
    244c:	430b      	orrs	r3, r1
    244e:	6013      	str	r3, [r2, #0]
	
    /* -------------------------------------------------
	* 2) select UART clock
	*/
	GCLK->CLKCTRL.reg =  
    2450:	4a1f      	ldr	r2, [pc, #124]	; (24d0 <UART3_Init+0x8c>)
    2452:	4b20      	ldr	r3, [pc, #128]	; (24d4 <UART3_Init+0x90>)
    2454:	805a      	strh	r2, [r3, #2]
	
	/* --------------------------------------------------
	* 3) Configure PA22 as TX Pin
	*/
	// Set pin direction to output
	PORT->Group[0].DIRSET.reg = (1 << 22);     
    2456:	4b20      	ldr	r3, [pc, #128]	; (24d8 <UART3_Init+0x94>)
    2458:	2280      	movs	r2, #128	; 0x80
    245a:	03d2      	lsls	r2, r2, #15
    245c:	609a      	str	r2, [r3, #8]
	
    // Enable PMUX
	PORT->Group[0].PINCFG[22].reg |= PORT_PINCFG_PMUXEN;   
    245e:	2256      	movs	r2, #86	; 0x56
    2460:	5c99      	ldrb	r1, [r3, r2]
    2462:	2601      	movs	r6, #1
    2464:	4331      	orrs	r1, r6
    2466:	b2c9      	uxtb	r1, r1
    2468:	5499      	strb	r1, [r3, r2]
	
	// Enable PMUX and set the PMUX bit, since pin is even we use PMUXE
	PORT->Group[0].PMUX[22>>1].bit.PMUXE = PORT_PMUX_PMUXE_C_Val;
    246a:	243b      	movs	r4, #59	; 0x3b
    246c:	5d19      	ldrb	r1, [r3, r4]
    246e:	3a47      	subs	r2, #71	; 0x47
    2470:	4391      	bics	r1, r2
    2472:	2202      	movs	r2, #2
    2474:	4311      	orrs	r1, r2
    2476:	5519      	strb	r1, [r3, r4]
	
	/* ---------------------------------------------------
	* 4) Configure PA23 as RX Pin
	*/
	// Set pin direction to input
	PORT->Group[0].DIRCLR.reg = (1 << 23);       
    2478:	2280      	movs	r2, #128	; 0x80
    247a:	0412      	lsls	r2, r2, #16
    247c:	605a      	str	r2, [r3, #4]

	// Enable pull down resistor
	PORT->Group[0].PINCFG[23].reg &= ~PORT_PINCFG_PULLEN;   
    247e:	2157      	movs	r1, #87	; 0x57
    2480:	5c5d      	ldrb	r5, [r3, r1]
    2482:	2204      	movs	r2, #4
    2484:	4395      	bics	r5, r2
    2486:	545d      	strb	r5, [r3, r1]
	
	// Enable PMUX and set the PMUX bit, since pin is odd we use PMUX0
	PORT->Group[0].PINCFG[23].reg |= PORT_PINCFG_PMUXEN; 
    2488:	5c5a      	ldrb	r2, [r3, r1]
    248a:	4332      	orrs	r2, r6
    248c:	b2d2      	uxtb	r2, r2
    248e:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PMUX[23>>1].bit.PMUXO = PORT_PMUX_PMUXO_C_Val; 
    2490:	5d19      	ldrb	r1, [r3, r4]
    2492:	220f      	movs	r2, #15
    2494:	400a      	ands	r2, r1
    2496:	2120      	movs	r1, #32
    2498:	430a      	orrs	r2, r1
    249a:	551a      	strb	r2, [r3, r4]
	
	
	/* ----------------------------------------------------
	* 5) Configure USART via Control A and Control B 
	*/
	SERCOM3->USART.CTRLA.reg =                  // USART is ASYNCHRONOUS
    249c:	4c0f      	ldr	r4, [pc, #60]	; (24dc <UART3_Init+0x98>)
    249e:	4b10      	ldr	r3, [pc, #64]	; (24e0 <UART3_Init+0x9c>)
    24a0:	6023      	str	r3, [r4, #0]
	   SERCOM_USART_CTRLA_MODE_USART_INT_CLK |  // Set Internal Clock 
	   SERCOM_USART_CTRLA_RXPO(1) |             // Use SERCOM pad 1 for data reception
	   SERCOM_USART_CTRLA_TXPO(0/*PAD0*/);      // Set SERCOM pad 0 for data transmission
	
	
	SERCOM3->USART.CTRLB.reg =        // We don't use PARITY
    24a2:	23c0      	movs	r3, #192	; 0xc0
    24a4:	029b      	lsls	r3, r3, #10
    24a6:	6063      	str	r3, [r4, #4]
	
	/* -----------------------------------------------------
	* 6) Set USART Baud Rate
	*/
	// Baud rate is (65536) * (CPU_CLock - 16 * wanted baud) / CPU_Clock
	uint64_t baudRate = (uint64_t)65536 * (F_CPU - 16 * baud) / F_CPU;
    24a8:	0100      	lsls	r0, r0, #4
    24aa:	4240      	negs	r0, r0
    24ac:	4b0d      	ldr	r3, [pc, #52]	; (24e4 <UART3_Init+0xa0>)
    24ae:	469c      	mov	ip, r3
    24b0:	4460      	add	r0, ip
    24b2:	0c01      	lsrs	r1, r0, #16
    24b4:	0400      	lsls	r0, r0, #16
    24b6:	4a0b      	ldr	r2, [pc, #44]	; (24e4 <UART3_Init+0xa0>)
    24b8:	2300      	movs	r3, #0
    24ba:	4d0b      	ldr	r5, [pc, #44]	; (24e8 <UART3_Init+0xa4>)
    24bc:	47a8      	blx	r5
	
	// Set Baud Rate
	SERCOM3->USART.BAUD.reg = (uint32_t)baudRate;
    24be:	b280      	uxth	r0, r0
    24c0:	81a0      	strh	r0, [r4, #12]

    /* ------------------------------------------------------
	* 7) Enable the USART
	*/
	// SERCOM3 peripheral enabled
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    24c2:	6823      	ldr	r3, [r4, #0]
    24c4:	2202      	movs	r2, #2
    24c6:	4313      	orrs	r3, r2
    24c8:	6023      	str	r3, [r4, #0]
}  // UART3_Init()
    24ca:	bd70      	pop	{r4, r5, r6, pc}
    24cc:	40000420 	.word	0x40000420
    24d0:	00004017 	.word	0x00004017
    24d4:	40000c00 	.word	0x40000c00
    24d8:	41004400 	.word	0x41004400
    24dc:	42001400 	.word	0x42001400
    24e0:	40100004 	.word	0x40100004
    24e4:	02dc6c00 	.word	0x02dc6c00
    24e8:	0000263d 	.word	0x0000263d

000024ec <UART3_Write>:
 *
 ******************************************************************************/
void UART3_Write(char data)
{
	// Wait on interrupt flag and Write some data
	while(!(REG_SERCOM3_USART_INTFLAG) & 1)
    24ec:	4a03      	ldr	r2, [pc, #12]	; (24fc <UART3_Write+0x10>)
    24ee:	7813      	ldrb	r3, [r2, #0]
    24f0:	2b00      	cmp	r3, #0
    24f2:	d0fc      	beq.n	24ee <UART3_Write+0x2>
	{
		
	}
	
	REG_SERCOM3_USART_DATA = data;
    24f4:	b280      	uxth	r0, r0
    24f6:	4b02      	ldr	r3, [pc, #8]	; (2500 <UART3_Write+0x14>)
    24f8:	8018      	strh	r0, [r3, #0]
} //UART3_Write()
    24fa:	4770      	bx	lr
    24fc:	42001418 	.word	0x42001418
    2500:	42001428 	.word	0x42001428

00002504 <UART3_Write_Text>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Write_Text(char *text)
{
    2504:	b570      	push	{r4, r5, r6, lr}
    2506:	0004      	movs	r4, r0
	// we write text until we reach EOL
	for(int i=0;text[i]!='\0';i++)
    2508:	7800      	ldrb	r0, [r0, #0]
    250a:	2800      	cmp	r0, #0
    250c:	d007      	beq.n	251e <UART3_Write_Text+0x1a>
    250e:	3401      	adds	r4, #1
	{
		UART3_Write(text[i]);
    2510:	4d03      	ldr	r5, [pc, #12]	; (2520 <UART3_Write_Text+0x1c>)
    2512:	47a8      	blx	r5
    2514:	3401      	adds	r4, #1
	for(int i=0;text[i]!='\0';i++)
    2516:	1e63      	subs	r3, r4, #1
    2518:	7818      	ldrb	r0, [r3, #0]
    251a:	2800      	cmp	r0, #0
    251c:	d1f9      	bne.n	2512 <UART3_Write_Text+0xe>
	}
	
} // UART3_Write_Text()
    251e:	bd70      	pop	{r4, r5, r6, pc}
    2520:	000024ed 	.word	0x000024ed

00002524 <__udivsi3>:
    2524:	2200      	movs	r2, #0
    2526:	0843      	lsrs	r3, r0, #1
    2528:	428b      	cmp	r3, r1
    252a:	d374      	bcc.n	2616 <__udivsi3+0xf2>
    252c:	0903      	lsrs	r3, r0, #4
    252e:	428b      	cmp	r3, r1
    2530:	d35f      	bcc.n	25f2 <__udivsi3+0xce>
    2532:	0a03      	lsrs	r3, r0, #8
    2534:	428b      	cmp	r3, r1
    2536:	d344      	bcc.n	25c2 <__udivsi3+0x9e>
    2538:	0b03      	lsrs	r3, r0, #12
    253a:	428b      	cmp	r3, r1
    253c:	d328      	bcc.n	2590 <__udivsi3+0x6c>
    253e:	0c03      	lsrs	r3, r0, #16
    2540:	428b      	cmp	r3, r1
    2542:	d30d      	bcc.n	2560 <__udivsi3+0x3c>
    2544:	22ff      	movs	r2, #255	; 0xff
    2546:	0209      	lsls	r1, r1, #8
    2548:	ba12      	rev	r2, r2
    254a:	0c03      	lsrs	r3, r0, #16
    254c:	428b      	cmp	r3, r1
    254e:	d302      	bcc.n	2556 <__udivsi3+0x32>
    2550:	1212      	asrs	r2, r2, #8
    2552:	0209      	lsls	r1, r1, #8
    2554:	d065      	beq.n	2622 <__udivsi3+0xfe>
    2556:	0b03      	lsrs	r3, r0, #12
    2558:	428b      	cmp	r3, r1
    255a:	d319      	bcc.n	2590 <__udivsi3+0x6c>
    255c:	e000      	b.n	2560 <__udivsi3+0x3c>
    255e:	0a09      	lsrs	r1, r1, #8
    2560:	0bc3      	lsrs	r3, r0, #15
    2562:	428b      	cmp	r3, r1
    2564:	d301      	bcc.n	256a <__udivsi3+0x46>
    2566:	03cb      	lsls	r3, r1, #15
    2568:	1ac0      	subs	r0, r0, r3
    256a:	4152      	adcs	r2, r2
    256c:	0b83      	lsrs	r3, r0, #14
    256e:	428b      	cmp	r3, r1
    2570:	d301      	bcc.n	2576 <__udivsi3+0x52>
    2572:	038b      	lsls	r3, r1, #14
    2574:	1ac0      	subs	r0, r0, r3
    2576:	4152      	adcs	r2, r2
    2578:	0b43      	lsrs	r3, r0, #13
    257a:	428b      	cmp	r3, r1
    257c:	d301      	bcc.n	2582 <__udivsi3+0x5e>
    257e:	034b      	lsls	r3, r1, #13
    2580:	1ac0      	subs	r0, r0, r3
    2582:	4152      	adcs	r2, r2
    2584:	0b03      	lsrs	r3, r0, #12
    2586:	428b      	cmp	r3, r1
    2588:	d301      	bcc.n	258e <__udivsi3+0x6a>
    258a:	030b      	lsls	r3, r1, #12
    258c:	1ac0      	subs	r0, r0, r3
    258e:	4152      	adcs	r2, r2
    2590:	0ac3      	lsrs	r3, r0, #11
    2592:	428b      	cmp	r3, r1
    2594:	d301      	bcc.n	259a <__udivsi3+0x76>
    2596:	02cb      	lsls	r3, r1, #11
    2598:	1ac0      	subs	r0, r0, r3
    259a:	4152      	adcs	r2, r2
    259c:	0a83      	lsrs	r3, r0, #10
    259e:	428b      	cmp	r3, r1
    25a0:	d301      	bcc.n	25a6 <__udivsi3+0x82>
    25a2:	028b      	lsls	r3, r1, #10
    25a4:	1ac0      	subs	r0, r0, r3
    25a6:	4152      	adcs	r2, r2
    25a8:	0a43      	lsrs	r3, r0, #9
    25aa:	428b      	cmp	r3, r1
    25ac:	d301      	bcc.n	25b2 <__udivsi3+0x8e>
    25ae:	024b      	lsls	r3, r1, #9
    25b0:	1ac0      	subs	r0, r0, r3
    25b2:	4152      	adcs	r2, r2
    25b4:	0a03      	lsrs	r3, r0, #8
    25b6:	428b      	cmp	r3, r1
    25b8:	d301      	bcc.n	25be <__udivsi3+0x9a>
    25ba:	020b      	lsls	r3, r1, #8
    25bc:	1ac0      	subs	r0, r0, r3
    25be:	4152      	adcs	r2, r2
    25c0:	d2cd      	bcs.n	255e <__udivsi3+0x3a>
    25c2:	09c3      	lsrs	r3, r0, #7
    25c4:	428b      	cmp	r3, r1
    25c6:	d301      	bcc.n	25cc <__udivsi3+0xa8>
    25c8:	01cb      	lsls	r3, r1, #7
    25ca:	1ac0      	subs	r0, r0, r3
    25cc:	4152      	adcs	r2, r2
    25ce:	0983      	lsrs	r3, r0, #6
    25d0:	428b      	cmp	r3, r1
    25d2:	d301      	bcc.n	25d8 <__udivsi3+0xb4>
    25d4:	018b      	lsls	r3, r1, #6
    25d6:	1ac0      	subs	r0, r0, r3
    25d8:	4152      	adcs	r2, r2
    25da:	0943      	lsrs	r3, r0, #5
    25dc:	428b      	cmp	r3, r1
    25de:	d301      	bcc.n	25e4 <__udivsi3+0xc0>
    25e0:	014b      	lsls	r3, r1, #5
    25e2:	1ac0      	subs	r0, r0, r3
    25e4:	4152      	adcs	r2, r2
    25e6:	0903      	lsrs	r3, r0, #4
    25e8:	428b      	cmp	r3, r1
    25ea:	d301      	bcc.n	25f0 <__udivsi3+0xcc>
    25ec:	010b      	lsls	r3, r1, #4
    25ee:	1ac0      	subs	r0, r0, r3
    25f0:	4152      	adcs	r2, r2
    25f2:	08c3      	lsrs	r3, r0, #3
    25f4:	428b      	cmp	r3, r1
    25f6:	d301      	bcc.n	25fc <__udivsi3+0xd8>
    25f8:	00cb      	lsls	r3, r1, #3
    25fa:	1ac0      	subs	r0, r0, r3
    25fc:	4152      	adcs	r2, r2
    25fe:	0883      	lsrs	r3, r0, #2
    2600:	428b      	cmp	r3, r1
    2602:	d301      	bcc.n	2608 <__udivsi3+0xe4>
    2604:	008b      	lsls	r3, r1, #2
    2606:	1ac0      	subs	r0, r0, r3
    2608:	4152      	adcs	r2, r2
    260a:	0843      	lsrs	r3, r0, #1
    260c:	428b      	cmp	r3, r1
    260e:	d301      	bcc.n	2614 <__udivsi3+0xf0>
    2610:	004b      	lsls	r3, r1, #1
    2612:	1ac0      	subs	r0, r0, r3
    2614:	4152      	adcs	r2, r2
    2616:	1a41      	subs	r1, r0, r1
    2618:	d200      	bcs.n	261c <__udivsi3+0xf8>
    261a:	4601      	mov	r1, r0
    261c:	4152      	adcs	r2, r2
    261e:	4610      	mov	r0, r2
    2620:	4770      	bx	lr
    2622:	e7ff      	b.n	2624 <__udivsi3+0x100>
    2624:	b501      	push	{r0, lr}
    2626:	2000      	movs	r0, #0
    2628:	f000 f806 	bl	2638 <__aeabi_idiv0>
    262c:	bd02      	pop	{r1, pc}
    262e:	46c0      	nop			; (mov r8, r8)

00002630 <__aeabi_uidivmod>:
    2630:	2900      	cmp	r1, #0
    2632:	d0f7      	beq.n	2624 <__udivsi3+0x100>
    2634:	e776      	b.n	2524 <__udivsi3>
    2636:	4770      	bx	lr

00002638 <__aeabi_idiv0>:
    2638:	4770      	bx	lr
    263a:	46c0      	nop			; (mov r8, r8)

0000263c <__aeabi_uldivmod>:
    263c:	2b00      	cmp	r3, #0
    263e:	d111      	bne.n	2664 <__aeabi_uldivmod+0x28>
    2640:	2a00      	cmp	r2, #0
    2642:	d10f      	bne.n	2664 <__aeabi_uldivmod+0x28>
    2644:	2900      	cmp	r1, #0
    2646:	d100      	bne.n	264a <__aeabi_uldivmod+0xe>
    2648:	2800      	cmp	r0, #0
    264a:	d002      	beq.n	2652 <__aeabi_uldivmod+0x16>
    264c:	2100      	movs	r1, #0
    264e:	43c9      	mvns	r1, r1
    2650:	1c08      	adds	r0, r1, #0
    2652:	b407      	push	{r0, r1, r2}
    2654:	4802      	ldr	r0, [pc, #8]	; (2660 <__aeabi_uldivmod+0x24>)
    2656:	a102      	add	r1, pc, #8	; (adr r1, 2660 <__aeabi_uldivmod+0x24>)
    2658:	1840      	adds	r0, r0, r1
    265a:	9002      	str	r0, [sp, #8]
    265c:	bd03      	pop	{r0, r1, pc}
    265e:	46c0      	nop			; (mov r8, r8)
    2660:	ffffffd9 	.word	0xffffffd9
    2664:	b403      	push	{r0, r1}
    2666:	4668      	mov	r0, sp
    2668:	b501      	push	{r0, lr}
    266a:	9802      	ldr	r0, [sp, #8]
    266c:	f000 f806 	bl	267c <__udivmoddi4>
    2670:	9b01      	ldr	r3, [sp, #4]
    2672:	469e      	mov	lr, r3
    2674:	b002      	add	sp, #8
    2676:	bc0c      	pop	{r2, r3}
    2678:	4770      	bx	lr
    267a:	46c0      	nop			; (mov r8, r8)

0000267c <__udivmoddi4>:
    267c:	b5f0      	push	{r4, r5, r6, r7, lr}
    267e:	4657      	mov	r7, sl
    2680:	464e      	mov	r6, r9
    2682:	4645      	mov	r5, r8
    2684:	46de      	mov	lr, fp
    2686:	b5e0      	push	{r5, r6, r7, lr}
    2688:	0004      	movs	r4, r0
    268a:	b083      	sub	sp, #12
    268c:	000d      	movs	r5, r1
    268e:	4692      	mov	sl, r2
    2690:	4699      	mov	r9, r3
    2692:	428b      	cmp	r3, r1
    2694:	d82f      	bhi.n	26f6 <__udivmoddi4+0x7a>
    2696:	d02c      	beq.n	26f2 <__udivmoddi4+0x76>
    2698:	4649      	mov	r1, r9
    269a:	4650      	mov	r0, sl
    269c:	f000 f8ae 	bl	27fc <__clzdi2>
    26a0:	0029      	movs	r1, r5
    26a2:	0006      	movs	r6, r0
    26a4:	0020      	movs	r0, r4
    26a6:	f000 f8a9 	bl	27fc <__clzdi2>
    26aa:	1a33      	subs	r3, r6, r0
    26ac:	4698      	mov	r8, r3
    26ae:	3b20      	subs	r3, #32
    26b0:	469b      	mov	fp, r3
    26b2:	d500      	bpl.n	26b6 <__udivmoddi4+0x3a>
    26b4:	e074      	b.n	27a0 <__udivmoddi4+0x124>
    26b6:	4653      	mov	r3, sl
    26b8:	465a      	mov	r2, fp
    26ba:	4093      	lsls	r3, r2
    26bc:	001f      	movs	r7, r3
    26be:	4653      	mov	r3, sl
    26c0:	4642      	mov	r2, r8
    26c2:	4093      	lsls	r3, r2
    26c4:	001e      	movs	r6, r3
    26c6:	42af      	cmp	r7, r5
    26c8:	d829      	bhi.n	271e <__udivmoddi4+0xa2>
    26ca:	d026      	beq.n	271a <__udivmoddi4+0x9e>
    26cc:	465b      	mov	r3, fp
    26ce:	1ba4      	subs	r4, r4, r6
    26d0:	41bd      	sbcs	r5, r7
    26d2:	2b00      	cmp	r3, #0
    26d4:	da00      	bge.n	26d8 <__udivmoddi4+0x5c>
    26d6:	e079      	b.n	27cc <__udivmoddi4+0x150>
    26d8:	2200      	movs	r2, #0
    26da:	2300      	movs	r3, #0
    26dc:	9200      	str	r2, [sp, #0]
    26de:	9301      	str	r3, [sp, #4]
    26e0:	2301      	movs	r3, #1
    26e2:	465a      	mov	r2, fp
    26e4:	4093      	lsls	r3, r2
    26e6:	9301      	str	r3, [sp, #4]
    26e8:	2301      	movs	r3, #1
    26ea:	4642      	mov	r2, r8
    26ec:	4093      	lsls	r3, r2
    26ee:	9300      	str	r3, [sp, #0]
    26f0:	e019      	b.n	2726 <__udivmoddi4+0xaa>
    26f2:	4282      	cmp	r2, r0
    26f4:	d9d0      	bls.n	2698 <__udivmoddi4+0x1c>
    26f6:	2200      	movs	r2, #0
    26f8:	2300      	movs	r3, #0
    26fa:	9200      	str	r2, [sp, #0]
    26fc:	9301      	str	r3, [sp, #4]
    26fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2700:	2b00      	cmp	r3, #0
    2702:	d001      	beq.n	2708 <__udivmoddi4+0x8c>
    2704:	601c      	str	r4, [r3, #0]
    2706:	605d      	str	r5, [r3, #4]
    2708:	9800      	ldr	r0, [sp, #0]
    270a:	9901      	ldr	r1, [sp, #4]
    270c:	b003      	add	sp, #12
    270e:	bc3c      	pop	{r2, r3, r4, r5}
    2710:	4690      	mov	r8, r2
    2712:	4699      	mov	r9, r3
    2714:	46a2      	mov	sl, r4
    2716:	46ab      	mov	fp, r5
    2718:	bdf0      	pop	{r4, r5, r6, r7, pc}
    271a:	42a3      	cmp	r3, r4
    271c:	d9d6      	bls.n	26cc <__udivmoddi4+0x50>
    271e:	2200      	movs	r2, #0
    2720:	2300      	movs	r3, #0
    2722:	9200      	str	r2, [sp, #0]
    2724:	9301      	str	r3, [sp, #4]
    2726:	4643      	mov	r3, r8
    2728:	2b00      	cmp	r3, #0
    272a:	d0e8      	beq.n	26fe <__udivmoddi4+0x82>
    272c:	07fb      	lsls	r3, r7, #31
    272e:	0872      	lsrs	r2, r6, #1
    2730:	431a      	orrs	r2, r3
    2732:	4646      	mov	r6, r8
    2734:	087b      	lsrs	r3, r7, #1
    2736:	e00e      	b.n	2756 <__udivmoddi4+0xda>
    2738:	42ab      	cmp	r3, r5
    273a:	d101      	bne.n	2740 <__udivmoddi4+0xc4>
    273c:	42a2      	cmp	r2, r4
    273e:	d80c      	bhi.n	275a <__udivmoddi4+0xde>
    2740:	1aa4      	subs	r4, r4, r2
    2742:	419d      	sbcs	r5, r3
    2744:	2001      	movs	r0, #1
    2746:	1924      	adds	r4, r4, r4
    2748:	416d      	adcs	r5, r5
    274a:	2100      	movs	r1, #0
    274c:	3e01      	subs	r6, #1
    274e:	1824      	adds	r4, r4, r0
    2750:	414d      	adcs	r5, r1
    2752:	2e00      	cmp	r6, #0
    2754:	d006      	beq.n	2764 <__udivmoddi4+0xe8>
    2756:	42ab      	cmp	r3, r5
    2758:	d9ee      	bls.n	2738 <__udivmoddi4+0xbc>
    275a:	3e01      	subs	r6, #1
    275c:	1924      	adds	r4, r4, r4
    275e:	416d      	adcs	r5, r5
    2760:	2e00      	cmp	r6, #0
    2762:	d1f8      	bne.n	2756 <__udivmoddi4+0xda>
    2764:	465b      	mov	r3, fp
    2766:	9800      	ldr	r0, [sp, #0]
    2768:	9901      	ldr	r1, [sp, #4]
    276a:	1900      	adds	r0, r0, r4
    276c:	4169      	adcs	r1, r5
    276e:	2b00      	cmp	r3, #0
    2770:	db22      	blt.n	27b8 <__udivmoddi4+0x13c>
    2772:	002b      	movs	r3, r5
    2774:	465a      	mov	r2, fp
    2776:	40d3      	lsrs	r3, r2
    2778:	002a      	movs	r2, r5
    277a:	4644      	mov	r4, r8
    277c:	40e2      	lsrs	r2, r4
    277e:	001c      	movs	r4, r3
    2780:	465b      	mov	r3, fp
    2782:	0015      	movs	r5, r2
    2784:	2b00      	cmp	r3, #0
    2786:	db2c      	blt.n	27e2 <__udivmoddi4+0x166>
    2788:	0026      	movs	r6, r4
    278a:	409e      	lsls	r6, r3
    278c:	0033      	movs	r3, r6
    278e:	0026      	movs	r6, r4
    2790:	4647      	mov	r7, r8
    2792:	40be      	lsls	r6, r7
    2794:	0032      	movs	r2, r6
    2796:	1a80      	subs	r0, r0, r2
    2798:	4199      	sbcs	r1, r3
    279a:	9000      	str	r0, [sp, #0]
    279c:	9101      	str	r1, [sp, #4]
    279e:	e7ae      	b.n	26fe <__udivmoddi4+0x82>
    27a0:	4642      	mov	r2, r8
    27a2:	2320      	movs	r3, #32
    27a4:	1a9b      	subs	r3, r3, r2
    27a6:	4652      	mov	r2, sl
    27a8:	40da      	lsrs	r2, r3
    27aa:	4641      	mov	r1, r8
    27ac:	0013      	movs	r3, r2
    27ae:	464a      	mov	r2, r9
    27b0:	408a      	lsls	r2, r1
    27b2:	0017      	movs	r7, r2
    27b4:	431f      	orrs	r7, r3
    27b6:	e782      	b.n	26be <__udivmoddi4+0x42>
    27b8:	4642      	mov	r2, r8
    27ba:	2320      	movs	r3, #32
    27bc:	1a9b      	subs	r3, r3, r2
    27be:	002a      	movs	r2, r5
    27c0:	4646      	mov	r6, r8
    27c2:	409a      	lsls	r2, r3
    27c4:	0023      	movs	r3, r4
    27c6:	40f3      	lsrs	r3, r6
    27c8:	4313      	orrs	r3, r2
    27ca:	e7d5      	b.n	2778 <__udivmoddi4+0xfc>
    27cc:	4642      	mov	r2, r8
    27ce:	2320      	movs	r3, #32
    27d0:	2100      	movs	r1, #0
    27d2:	1a9b      	subs	r3, r3, r2
    27d4:	2200      	movs	r2, #0
    27d6:	9100      	str	r1, [sp, #0]
    27d8:	9201      	str	r2, [sp, #4]
    27da:	2201      	movs	r2, #1
    27dc:	40da      	lsrs	r2, r3
    27de:	9201      	str	r2, [sp, #4]
    27e0:	e782      	b.n	26e8 <__udivmoddi4+0x6c>
    27e2:	4642      	mov	r2, r8
    27e4:	2320      	movs	r3, #32
    27e6:	0026      	movs	r6, r4
    27e8:	1a9b      	subs	r3, r3, r2
    27ea:	40de      	lsrs	r6, r3
    27ec:	002f      	movs	r7, r5
    27ee:	46b4      	mov	ip, r6
    27f0:	4097      	lsls	r7, r2
    27f2:	4666      	mov	r6, ip
    27f4:	003b      	movs	r3, r7
    27f6:	4333      	orrs	r3, r6
    27f8:	e7c9      	b.n	278e <__udivmoddi4+0x112>
    27fa:	46c0      	nop			; (mov r8, r8)

000027fc <__clzdi2>:
    27fc:	b510      	push	{r4, lr}
    27fe:	2900      	cmp	r1, #0
    2800:	d103      	bne.n	280a <__clzdi2+0xe>
    2802:	f000 f807 	bl	2814 <__clzsi2>
    2806:	3020      	adds	r0, #32
    2808:	e002      	b.n	2810 <__clzdi2+0x14>
    280a:	1c08      	adds	r0, r1, #0
    280c:	f000 f802 	bl	2814 <__clzsi2>
    2810:	bd10      	pop	{r4, pc}
    2812:	46c0      	nop			; (mov r8, r8)

00002814 <__clzsi2>:
    2814:	211c      	movs	r1, #28
    2816:	2301      	movs	r3, #1
    2818:	041b      	lsls	r3, r3, #16
    281a:	4298      	cmp	r0, r3
    281c:	d301      	bcc.n	2822 <__clzsi2+0xe>
    281e:	0c00      	lsrs	r0, r0, #16
    2820:	3910      	subs	r1, #16
    2822:	0a1b      	lsrs	r3, r3, #8
    2824:	4298      	cmp	r0, r3
    2826:	d301      	bcc.n	282c <__clzsi2+0x18>
    2828:	0a00      	lsrs	r0, r0, #8
    282a:	3908      	subs	r1, #8
    282c:	091b      	lsrs	r3, r3, #4
    282e:	4298      	cmp	r0, r3
    2830:	d301      	bcc.n	2836 <__clzsi2+0x22>
    2832:	0900      	lsrs	r0, r0, #4
    2834:	3904      	subs	r1, #4
    2836:	a202      	add	r2, pc, #8	; (adr r2, 2840 <__clzsi2+0x2c>)
    2838:	5c10      	ldrb	r0, [r2, r0]
    283a:	1840      	adds	r0, r0, r1
    283c:	4770      	bx	lr
    283e:	46c0      	nop			; (mov r8, r8)
    2840:	02020304 	.word	0x02020304
    2844:	01010101 	.word	0x01010101
	...

00002850 <__libc_init_array>:
    2850:	b570      	push	{r4, r5, r6, lr}
    2852:	4e0d      	ldr	r6, [pc, #52]	; (2888 <__libc_init_array+0x38>)
    2854:	4d0d      	ldr	r5, [pc, #52]	; (288c <__libc_init_array+0x3c>)
    2856:	2400      	movs	r4, #0
    2858:	1bad      	subs	r5, r5, r6
    285a:	10ad      	asrs	r5, r5, #2
    285c:	d005      	beq.n	286a <__libc_init_array+0x1a>
    285e:	00a3      	lsls	r3, r4, #2
    2860:	58f3      	ldr	r3, [r6, r3]
    2862:	3401      	adds	r4, #1
    2864:	4798      	blx	r3
    2866:	42a5      	cmp	r5, r4
    2868:	d1f9      	bne.n	285e <__libc_init_array+0xe>
    286a:	f000 fa3f 	bl	2cec <_init>
    286e:	4e08      	ldr	r6, [pc, #32]	; (2890 <__libc_init_array+0x40>)
    2870:	4d08      	ldr	r5, [pc, #32]	; (2894 <__libc_init_array+0x44>)
    2872:	2400      	movs	r4, #0
    2874:	1bad      	subs	r5, r5, r6
    2876:	10ad      	asrs	r5, r5, #2
    2878:	d005      	beq.n	2886 <__libc_init_array+0x36>
    287a:	00a3      	lsls	r3, r4, #2
    287c:	58f3      	ldr	r3, [r6, r3]
    287e:	3401      	adds	r4, #1
    2880:	4798      	blx	r3
    2882:	42a5      	cmp	r5, r4
    2884:	d1f9      	bne.n	287a <__libc_init_array+0x2a>
    2886:	bd70      	pop	{r4, r5, r6, pc}
    2888:	00002cf8 	.word	0x00002cf8
    288c:	00002cf8 	.word	0x00002cf8
    2890:	00002cf8 	.word	0x00002cf8
    2894:	00002d00 	.word	0x00002d00

00002898 <register_fini>:
    2898:	4b03      	ldr	r3, [pc, #12]	; (28a8 <register_fini+0x10>)
    289a:	b510      	push	{r4, lr}
    289c:	2b00      	cmp	r3, #0
    289e:	d002      	beq.n	28a6 <register_fini+0xe>
    28a0:	4802      	ldr	r0, [pc, #8]	; (28ac <register_fini+0x14>)
    28a2:	f000 f805 	bl	28b0 <atexit>
    28a6:	bd10      	pop	{r4, pc}
    28a8:	00000000 	.word	0x00000000
    28ac:	000028c1 	.word	0x000028c1

000028b0 <atexit>:
    28b0:	b510      	push	{r4, lr}
    28b2:	0001      	movs	r1, r0
    28b4:	2300      	movs	r3, #0
    28b6:	2200      	movs	r2, #0
    28b8:	2000      	movs	r0, #0
    28ba:	f000 f81f 	bl	28fc <__register_exitproc>
    28be:	bd10      	pop	{r4, pc}

000028c0 <__libc_fini_array>:
    28c0:	b570      	push	{r4, r5, r6, lr}
    28c2:	4b09      	ldr	r3, [pc, #36]	; (28e8 <__libc_fini_array+0x28>)
    28c4:	4c09      	ldr	r4, [pc, #36]	; (28ec <__libc_fini_array+0x2c>)
    28c6:	1ae4      	subs	r4, r4, r3
    28c8:	10a4      	asrs	r4, r4, #2
    28ca:	d009      	beq.n	28e0 <__libc_fini_array+0x20>
    28cc:	4a08      	ldr	r2, [pc, #32]	; (28f0 <__libc_fini_array+0x30>)
    28ce:	18a5      	adds	r5, r4, r2
    28d0:	00ad      	lsls	r5, r5, #2
    28d2:	18ed      	adds	r5, r5, r3
    28d4:	682b      	ldr	r3, [r5, #0]
    28d6:	3c01      	subs	r4, #1
    28d8:	4798      	blx	r3
    28da:	3d04      	subs	r5, #4
    28dc:	2c00      	cmp	r4, #0
    28de:	d1f9      	bne.n	28d4 <__libc_fini_array+0x14>
    28e0:	f000 fa0e 	bl	2d00 <_fini>
    28e4:	bd70      	pop	{r4, r5, r6, pc}
    28e6:	46c0      	nop			; (mov r8, r8)
    28e8:	00002d0c 	.word	0x00002d0c
    28ec:	00002d10 	.word	0x00002d10
    28f0:	3fffffff 	.word	0x3fffffff

000028f4 <__retarget_lock_acquire_recursive>:
    28f4:	4770      	bx	lr
    28f6:	46c0      	nop			; (mov r8, r8)

000028f8 <__retarget_lock_release_recursive>:
    28f8:	4770      	bx	lr
    28fa:	46c0      	nop			; (mov r8, r8)

000028fc <__register_exitproc>:
    28fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    28fe:	464e      	mov	r6, r9
    2900:	4645      	mov	r5, r8
    2902:	46de      	mov	lr, fp
    2904:	4657      	mov	r7, sl
    2906:	b5e0      	push	{r5, r6, r7, lr}
    2908:	4d36      	ldr	r5, [pc, #216]	; (29e4 <__register_exitproc+0xe8>)
    290a:	b083      	sub	sp, #12
    290c:	0006      	movs	r6, r0
    290e:	6828      	ldr	r0, [r5, #0]
    2910:	4698      	mov	r8, r3
    2912:	000f      	movs	r7, r1
    2914:	4691      	mov	r9, r2
    2916:	f7ff ffed 	bl	28f4 <__retarget_lock_acquire_recursive>
    291a:	4b33      	ldr	r3, [pc, #204]	; (29e8 <__register_exitproc+0xec>)
    291c:	681c      	ldr	r4, [r3, #0]
    291e:	23a4      	movs	r3, #164	; 0xa4
    2920:	005b      	lsls	r3, r3, #1
    2922:	58e0      	ldr	r0, [r4, r3]
    2924:	2800      	cmp	r0, #0
    2926:	d052      	beq.n	29ce <__register_exitproc+0xd2>
    2928:	6843      	ldr	r3, [r0, #4]
    292a:	2b1f      	cmp	r3, #31
    292c:	dc13      	bgt.n	2956 <__register_exitproc+0x5a>
    292e:	1c5a      	adds	r2, r3, #1
    2930:	9201      	str	r2, [sp, #4]
    2932:	2e00      	cmp	r6, #0
    2934:	d128      	bne.n	2988 <__register_exitproc+0x8c>
    2936:	9a01      	ldr	r2, [sp, #4]
    2938:	3302      	adds	r3, #2
    293a:	009b      	lsls	r3, r3, #2
    293c:	6042      	str	r2, [r0, #4]
    293e:	501f      	str	r7, [r3, r0]
    2940:	6828      	ldr	r0, [r5, #0]
    2942:	f7ff ffd9 	bl	28f8 <__retarget_lock_release_recursive>
    2946:	2000      	movs	r0, #0
    2948:	b003      	add	sp, #12
    294a:	bc3c      	pop	{r2, r3, r4, r5}
    294c:	4690      	mov	r8, r2
    294e:	4699      	mov	r9, r3
    2950:	46a2      	mov	sl, r4
    2952:	46ab      	mov	fp, r5
    2954:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2956:	4b25      	ldr	r3, [pc, #148]	; (29ec <__register_exitproc+0xf0>)
    2958:	2b00      	cmp	r3, #0
    295a:	d03d      	beq.n	29d8 <__register_exitproc+0xdc>
    295c:	20c8      	movs	r0, #200	; 0xc8
    295e:	0040      	lsls	r0, r0, #1
    2960:	e000      	b.n	2964 <__register_exitproc+0x68>
    2962:	bf00      	nop
    2964:	2800      	cmp	r0, #0
    2966:	d037      	beq.n	29d8 <__register_exitproc+0xdc>
    2968:	22a4      	movs	r2, #164	; 0xa4
    296a:	2300      	movs	r3, #0
    296c:	0052      	lsls	r2, r2, #1
    296e:	58a1      	ldr	r1, [r4, r2]
    2970:	6043      	str	r3, [r0, #4]
    2972:	6001      	str	r1, [r0, #0]
    2974:	50a0      	str	r0, [r4, r2]
    2976:	3240      	adds	r2, #64	; 0x40
    2978:	5083      	str	r3, [r0, r2]
    297a:	3204      	adds	r2, #4
    297c:	5083      	str	r3, [r0, r2]
    297e:	3301      	adds	r3, #1
    2980:	9301      	str	r3, [sp, #4]
    2982:	2300      	movs	r3, #0
    2984:	2e00      	cmp	r6, #0
    2986:	d0d6      	beq.n	2936 <__register_exitproc+0x3a>
    2988:	009a      	lsls	r2, r3, #2
    298a:	4692      	mov	sl, r2
    298c:	4482      	add	sl, r0
    298e:	464a      	mov	r2, r9
    2990:	2188      	movs	r1, #136	; 0x88
    2992:	4654      	mov	r4, sl
    2994:	5062      	str	r2, [r4, r1]
    2996:	22c4      	movs	r2, #196	; 0xc4
    2998:	0052      	lsls	r2, r2, #1
    299a:	4691      	mov	r9, r2
    299c:	4481      	add	r9, r0
    299e:	464a      	mov	r2, r9
    29a0:	3987      	subs	r1, #135	; 0x87
    29a2:	4099      	lsls	r1, r3
    29a4:	6812      	ldr	r2, [r2, #0]
    29a6:	468b      	mov	fp, r1
    29a8:	430a      	orrs	r2, r1
    29aa:	4694      	mov	ip, r2
    29ac:	464a      	mov	r2, r9
    29ae:	4661      	mov	r1, ip
    29b0:	6011      	str	r1, [r2, #0]
    29b2:	2284      	movs	r2, #132	; 0x84
    29b4:	4641      	mov	r1, r8
    29b6:	0052      	lsls	r2, r2, #1
    29b8:	50a1      	str	r1, [r4, r2]
    29ba:	2e02      	cmp	r6, #2
    29bc:	d1bb      	bne.n	2936 <__register_exitproc+0x3a>
    29be:	0002      	movs	r2, r0
    29c0:	465c      	mov	r4, fp
    29c2:	328d      	adds	r2, #141	; 0x8d
    29c4:	32ff      	adds	r2, #255	; 0xff
    29c6:	6811      	ldr	r1, [r2, #0]
    29c8:	430c      	orrs	r4, r1
    29ca:	6014      	str	r4, [r2, #0]
    29cc:	e7b3      	b.n	2936 <__register_exitproc+0x3a>
    29ce:	0020      	movs	r0, r4
    29d0:	304d      	adds	r0, #77	; 0x4d
    29d2:	30ff      	adds	r0, #255	; 0xff
    29d4:	50e0      	str	r0, [r4, r3]
    29d6:	e7a7      	b.n	2928 <__register_exitproc+0x2c>
    29d8:	6828      	ldr	r0, [r5, #0]
    29da:	f7ff ff8d 	bl	28f8 <__retarget_lock_release_recursive>
    29de:	2001      	movs	r0, #1
    29e0:	4240      	negs	r0, r0
    29e2:	e7b1      	b.n	2948 <__register_exitproc+0x4c>
    29e4:	20000438 	.word	0x20000438
    29e8:	00002ce8 	.word	0x00002ce8
    29ec:	00000000 	.word	0x00000000
    29f0:	72617473 	.word	0x72617473
    29f4:	6e692074 	.word	0x6e692074
    29f8:	000a7469 	.word	0x000a7469
    29fc:	74696e69 	.word	0x74696e69
    2a00:	6e6f6420 	.word	0x6e6f6420
    2a04:	00000a65 	.word	0x00000a65
    2a08:	72617473 	.word	0x72617473
    2a0c:	6f6d2074 	.word	0x6f6d2074
    2a10:	0a746e75 	.word	0x0a746e75
    2a14:	00000000 	.word	0x00000000
    2a18:	20646e65 	.word	0x20646e65
    2a1c:	6e756f6d 	.word	0x6e756f6d
    2a20:	00000a74 	.word	0x00000a74
    2a24:	7272450a 	.word	0x7272450a
    2a28:	6d20726f 	.word	0x6d20726f
    2a2c:	746e756f 	.word	0x746e756f
    2a30:	20676e69 	.word	0x20676e69
    2a34:	656c6966 	.word	0x656c6966
    2a38:	73797320 	.word	0x73797320
    2a3c:	0d6d6574 	.word	0x0d6d6574
    2a40:	0000000a 	.word	0x0000000a
    2a44:	72617473 	.word	0x72617473
    2a48:	706f2074 	.word	0x706f2074
    2a4c:	000a6e65 	.word	0x000a6e65
    2a50:	20646e65 	.word	0x20646e65
    2a54:	6e65706f 	.word	0x6e65706f
    2a58:	0000000a 	.word	0x0000000a
    2a5c:	6f727245 	.word	0x6f727245
    2a60:	706f2072 	.word	0x706f2072
    2a64:	6e696e65 	.word	0x6e696e65
    2a68:	69662067 	.word	0x69662067
    2a6c:	0a0d656c 	.word	0x0a0d656c
    2a70:	00000000 	.word	0x00000000
    2a74:	61746144 	.word	0x61746144
    2a78:	442c2031 	.word	0x442c2031
    2a7c:	32617461 	.word	0x32617461
    2a80:	61442c20 	.word	0x61442c20
    2a84:	20336174 	.word	0x20336174
    2a88:	7461442c 	.word	0x7461442c
    2a8c:	0d203461 	.word	0x0d203461
    2a90:	0000000a 	.word	0x0000000a
    2a94:	7272450a 	.word	0x7272450a
    2a98:	7720726f 	.word	0x7720726f
    2a9c:	69746972 	.word	0x69746972
    2aa0:	7420676e 	.word	0x7420676e
    2aa4:	6966206f 	.word	0x6966206f
    2aa8:	0a0d656c 	.word	0x0a0d656c
    2aac:	00000000 	.word	0x00000000
    2ab0:	7272450a 	.word	0x7272450a
    2ab4:	6320726f 	.word	0x6320726f
    2ab8:	69736f6c 	.word	0x69736f6c
    2abc:	6620676e 	.word	0x6620676e
    2ac0:	0d656c69 	.word	0x0d656c69
    2ac4:	0000000a 	.word	0x0000000a
    2ac8:	63637553 	.word	0x63637553
    2acc:	66737365 	.word	0x66737365
    2ad0:	57206c75 	.word	0x57206c75
    2ad4:	65746972 	.word	0x65746972
    2ad8:	6c694620 	.word	0x6c694620
    2adc:	6f442065 	.word	0x6f442065
    2ae0:	0a21656e 	.word	0x0a21656e
    2ae4:	00000000 	.word	0x00000000
    2ae8:	72617453 	.word	0x72617453
    2aec:	65522074 	.word	0x65522074
    2af0:	000a6461 	.word	0x000a6461
    2af4:	64616552 	.word	0x64616552
    2af8:	20676e69 	.word	0x20676e69
    2afc:	646f6f47 	.word	0x646f6f47
    2b00:	0000000a 	.word	0x0000000a
    2b04:	64616552 	.word	0x64616552
    2b08:	72724520 	.word	0x72724520
    2b0c:	000a726f 	.word	0x000a726f
    2b10:	20656854 	.word	0x20656854
    2b14:	656c6966 	.word	0x656c6966
    2b18:	6e6f6320 	.word	0x6e6f6320
    2b1c:	6e696174 	.word	0x6e696174
    2b20:	0a203a73 	.word	0x0a203a73
    2b24:	00000000 	.word	0x00000000
    2b28:	64616552 	.word	0x64616552
    2b2c:	20676e69 	.word	0x20676e69
    2b30:	656e6f44 	.word	0x656e6f44
    2b34:	0000000a 	.word	0x0000000a
    2b38:	736f6c43 	.word	0x736f6c43
    2b3c:	20676e69 	.word	0x20676e69
    2b40:	656c6946 	.word	0x656c6946
    2b44:	0000000a 	.word	0x0000000a
    2b48:	736f6c43 	.word	0x736f6c43
    2b4c:	65522065 	.word	0x65522065
    2b50:	45206461 	.word	0x45206461
    2b54:	726f7272 	.word	0x726f7272
    2b58:	0000000a 	.word	0x0000000a
    2b5c:	736f6c43 	.word	0x736f6c43
    2b60:	20676e69 	.word	0x20676e69
    2b64:	63637553 	.word	0x63637553
    2b68:	0a737365 	.word	0x0a737365
    2b6c:	00000000 	.word	0x00000000
    2b70:	6e756f43 	.word	0x6e756f43
    2b74:	73692074 	.word	0x73692074
    2b78:	000a203a 	.word	0x000a203a
    2b7c:	64616572 	.word	0x64616572
    2b80:	0a203220 	.word	0x0a203220
    2b84:	00000000 	.word	0x00000000
    2b88:	74697277 	.word	0x74697277
    2b8c:	20312065 	.word	0x20312065
    2b90:	0000000a 	.word	0x0000000a
    2b94:	74697277 	.word	0x74697277
    2b98:	20322065 	.word	0x20322065
    2b9c:	0000000a 	.word	0x0000000a
    2ba0:	2c2b2a22 	.word	0x2c2b2a22
    2ba4:	3d3c3b3a 	.word	0x3d3c3b3a
    2ba8:	5d5b3f3e 	.word	0x5d5b3f3e
    2bac:	00007f7c 	.word	0x00007f7c
    2bb0:	6c696146 	.word	0x6c696146
    2bb4:	6f742065 	.word	0x6f742065
    2bb8:	73657220 	.word	0x73657220
    2bbc:	63207465 	.word	0x63207465
    2bc0:	00647261 	.word	0x00647261
    2bc4:	626f7250 	.word	0x626f7250
    2bc8:	206d656c 	.word	0x206d656c
    2bcc:	696b6174 	.word	0x696b6174
    2bd0:	4f20676e 	.word	0x4f20676e
    2bd4:	64205243 	.word	0x64205243
    2bd8:	0a617461 	.word	0x0a617461
    2bdc:	00000000 	.word	0x00000000
    2be0:	64726143 	.word	0x64726143
    2be4:	3256203a 	.word	0x3256203a
    2be8:	5320302e 	.word	0x5320302e
    2bec:	0a434844 	.word	0x0a434844
    2bf0:	00000000 	.word	0x00000000
    2bf4:	64726143 	.word	0x64726143
    2bf8:	70795420 	.word	0x70795420
    2bfc:	56203a65 	.word	0x56203a65
    2c00:	0a302e32 	.word	0x0a302e32
    2c04:	00000000 	.word	0x00000000
    2c08:	74696e49 	.word	0x74696e49
    2c0c:	696c6169 	.word	0x696c6169
    2c10:	6974617a 	.word	0x6974617a
    2c14:	43206e6f 	.word	0x43206e6f
    2c18:	6c706d6f 	.word	0x6c706d6f
    2c1c:	20657465 	.word	0x20657465
    2c20:	0000000a 	.word	0x0000000a
    2c24:	20746f4e 	.word	0x20746f4e
    2c28:	545f4453 	.word	0x545f4453
    2c2c:	5f455059 	.word	0x5f455059
    2c30:	43483256 	.word	0x43483256
    2c34:	0000000a 	.word	0x0000000a
    2c38:	64616552 	.word	0x64616552
    2c3c:	6f6c6220 	.word	0x6f6c6220
    2c40:	61206b63 	.word	0x61206b63
    2c44:	65726464 	.word	0x65726464
    2c48:	000a7373 	.word	0x000a7373
    2c4c:	64616552 	.word	0x64616552
    2c50:	0a676e69 	.word	0x0a676e69
    2c54:	00000000 	.word	0x00000000
    2c58:	64616552 	.word	0x64616552
    2c5c:	6d6f6320 	.word	0x6d6f6320
    2c60:	74656c70 	.word	0x74656c70
    2c64:	00000a65 	.word	0x00000a65
    2c68:	20435243 	.word	0x20435243
    2c6c:	74697257 	.word	0x74697257
    2c70:	61462065 	.word	0x61462065
    2c74:	00006c69 	.word	0x00006c69
    2c78:	74697257 	.word	0x74697257
    2c7c:	6f432065 	.word	0x6f432065
    2c80:	656c706d 	.word	0x656c706d
    2c84:	000a6574 	.word	0x000a6574
    2c88:	74697257 	.word	0x74697257
    2c8c:	754d2065 	.word	0x754d2065
    2c90:	7069746c 	.word	0x7069746c
    2c94:	4220656c 	.word	0x4220656c
    2c98:	6b636f6c 	.word	0x6b636f6c
    2c9c:	64644120 	.word	0x64644120
    2ca0:	73736572 	.word	0x73736572
    2ca4:	69614620 	.word	0x69614620
    2ca8:	0a64656c 	.word	0x0a64656c
    2cac:	00000000 	.word	0x00000000
    2cb0:	20435243 	.word	0x20435243
    2cb4:	746c754d 	.word	0x746c754d
    2cb8:	656c7069 	.word	0x656c7069
    2cbc:	69725720 	.word	0x69725720
    2cc0:	46206574 	.word	0x46206574
    2cc4:	656c6961 	.word	0x656c6961
    2cc8:	00000a64 	.word	0x00000a64
    2ccc:	74697257 	.word	0x74697257
    2cd0:	754d2065 	.word	0x754d2065
    2cd4:	7069746c 	.word	0x7069746c
    2cd8:	4320656c 	.word	0x4320656c
    2cdc:	6c706d6f 	.word	0x6c706d6f
    2ce0:	0a657465 	.word	0x0a657465
    2ce4:	00000000 	.word	0x00000000

00002ce8 <_global_impure_ptr>:
    2ce8:	20000010                                ... 

00002cec <_init>:
    2cec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2cee:	46c0      	nop			; (mov r8, r8)
    2cf0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2cf2:	bc08      	pop	{r3}
    2cf4:	469e      	mov	lr, r3
    2cf6:	4770      	bx	lr

00002cf8 <__init_array_start>:
    2cf8:	00002899 	.word	0x00002899

00002cfc <__frame_dummy_init_array_entry>:
    2cfc:	000000dd                                ....

00002d00 <_fini>:
    2d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2d02:	46c0      	nop			; (mov r8, r8)
    2d04:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2d06:	bc08      	pop	{r3}
    2d08:	469e      	mov	lr, r3
    2d0a:	4770      	bx	lr

00002d0c <__fini_array_start>:
    2d0c:	000000b5 	.word	0x000000b5
